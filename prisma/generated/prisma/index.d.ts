
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model user_addresses
 * 
 */
export type user_addresses = $Result.DefaultSelection<Prisma.$user_addressesPayload>
/**
 * Model resumes
 * 
 */
export type resumes = $Result.DefaultSelection<Prisma.$resumesPayload>
/**
 * Model educations
 * 
 */
export type educations = $Result.DefaultSelection<Prisma.$educationsPayload>
/**
 * Model work_experiences
 * 
 */
export type work_experiences = $Result.DefaultSelection<Prisma.$work_experiencesPayload>
/**
 * Model skills
 * 
 */
export type skills = $Result.DefaultSelection<Prisma.$skillsPayload>
/**
 * Model languages
 * 
 */
export type languages = $Result.DefaultSelection<Prisma.$languagesPayload>
/**
 * Model certifications
 * 
 */
export type certifications = $Result.DefaultSelection<Prisma.$certificationsPayload>
/**
 * Model visa_information
 * 
 */
export type visa_information = $Result.DefaultSelection<Prisma.$visa_informationPayload>
/**
 * Model companies
 * 
 */
export type companies = $Result.DefaultSelection<Prisma.$companiesPayload>
/**
 * Model company_locations
 * 
 */
export type company_locations = $Result.DefaultSelection<Prisma.$company_locationsPayload>
/**
 * Model jobs
 * 
 */
export type jobs = $Result.DefaultSelection<Prisma.$jobsPayload>
/**
 * Model job_requirements
 * 
 */
export type job_requirements = $Result.DefaultSelection<Prisma.$job_requirementsPayload>
/**
 * Model job_responsibilites
 * 
 */
export type job_responsibilites = $Result.DefaultSelection<Prisma.$job_responsibilitesPayload>
/**
 * Model job_benefits
 * 
 */
export type job_benefits = $Result.DefaultSelection<Prisma.$job_benefitsPayload>
/**
 * Model applications
 * 
 */
export type applications = $Result.DefaultSelection<Prisma.$applicationsPayload>
/**
 * Model application_documents
 * 
 */
export type application_documents = $Result.DefaultSelection<Prisma.$application_documentsPayload>
/**
 * Model interviews
 * 
 */
export type interviews = $Result.DefaultSelection<Prisma.$interviewsPayload>
/**
 * Model contacts
 * 
 */
export type contacts = $Result.DefaultSelection<Prisma.$contactsPayload>
/**
 * Model notifications
 * 
 */
export type notifications = $Result.DefaultSelection<Prisma.$notificationsPayload>
/**
 * Model saved_jobs
 * 
 */
export type saved_jobs = $Result.DefaultSelection<Prisma.$saved_jobsPayload>
/**
 * Model job_searches
 * 
 */
export type job_searches = $Result.DefaultSelection<Prisma.$job_searchesPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const userstatus: {
  active: 'active',
  inactive: 'inactive'
};

export type userstatus = (typeof userstatus)[keyof typeof userstatus]


export const skillsstatus: {
  beginner: 'beginner',
  intermediate: 'intermediate',
  advanced: 'advanced',
  expert: 'expert'
};

export type skillsstatus = (typeof skillsstatus)[keyof typeof skillsstatus]


export const proficiencylanguages: {
  basic: 'basic',
  conversational: 'conversational',
  fluent: 'fluent',
  native: 'native'
};

export type proficiencylanguages = (typeof proficiencylanguages)[keyof typeof proficiencylanguages]


export const companySize: {
  SIZE_1_10: 'SIZE_1_10',
  SIZE_11_50: 'SIZE_11_50',
  SIZE_51_200: 'SIZE_51_200',
  SIZE_201_500: 'SIZE_201_500',
  SIZE_501_1000: 'SIZE_501_1000',
  SIZE_1001_5000: 'SIZE_1001_5000',
  SIZE_5000_PLUS: 'SIZE_5000_PLUS'
};

export type companySize = (typeof companySize)[keyof typeof companySize]


export const jobType: {
  full_time: 'full_time',
  part_time: 'part_time',
  contact: 'contact',
  temporary: 'temporary',
  intership: 'intership',
  remote: 'remote'
};

export type jobType = (typeof jobType)[keyof typeof jobType]


export const salaryPeriod: {
  hourly: 'hourly',
  weekly: 'weekly',
  monthly: 'monthly',
  yearly: 'yearly'
};

export type salaryPeriod = (typeof salaryPeriod)[keyof typeof salaryPeriod]


export const visaSponsorship: {
  none: 'none',
  possible: 'possible',
  available: 'available'
};

export type visaSponsorship = (typeof visaSponsorship)[keyof typeof visaSponsorship]


export const expLevel: {
  entry: 'entry',
  mid: 'mid',
  senior: 'senior',
  execution: 'execution'
};

export type expLevel = (typeof expLevel)[keyof typeof expLevel]


export const jobStatus: {
  draft: 'draft',
  published: 'published',
  closed: 'closed'
};

export type jobStatus = (typeof jobStatus)[keyof typeof jobStatus]


export const jobRequirements: {
  skill: 'skill',
  educaiton: 'educaiton',
  experience: 'experience',
  languages: 'languages',
  certifiaction: 'certifiaction',
  other: 'other'
};

export type jobRequirements = (typeof jobRequirements)[keyof typeof jobRequirements]


export const jobBenefit: {
  health: 'health',
  housing: 'housing',
  transportation: 'transportation',
  bonus: 'bonus',
  training: 'training',
  other: 'other'
};

export type jobBenefit = (typeof jobBenefit)[keyof typeof jobBenefit]


export const applicationStatus: {
  submitted: 'submitted',
  under_review: 'under_review',
  shortlisted: 'shortlisted',
  interviewing: 'interviewing',
  rejected: 'rejected',
  withdrawn: 'withdrawn',
  hired: 'hired'
};

export type applicationStatus = (typeof applicationStatus)[keyof typeof applicationStatus]


export const appDocumentStatus: {
  resume: 'resume',
  cover_letter: 'cover_letter',
  protfolio: 'protfolio',
  certificate: 'certificate',
  reference: 'reference',
  other: 'other'
};

export type appDocumentStatus = (typeof appDocumentStatus)[keyof typeof appDocumentStatus]


export const interviewType: {
  phone: 'phone',
  video: 'video',
  in_person: 'in_person',
  assessment: 'assessment'
};

export type interviewType = (typeof interviewType)[keyof typeof interviewType]


export const interviewStatus: {
  scheduled: 'scheduled',
  completed: 'completed',
  cancelled: 'cancelled',
  rescheduled: 'rescheduled'
};

export type interviewStatus = (typeof interviewStatus)[keyof typeof interviewStatus]


export const contactType: {
  full_time: 'full_time',
  part_time: 'part_time',
  fixed_term: 'fixed_term',
  intership: 'intership'
};

export type contactType = (typeof contactType)[keyof typeof contactType]


export const contactSalaryPaymentPeriod: {
  hourly: 'hourly',
  weekly: 'weekly',
  monthly: 'monthly',
  yearly: 'yearly'
};

export type contactSalaryPaymentPeriod = (typeof contactSalaryPaymentPeriod)[keyof typeof contactSalaryPaymentPeriod]


export const contactStatus: {
  draft: 'draft',
  active: 'active',
  terminated: 'terminated',
  completed: 'completed'
};

export type contactStatus = (typeof contactStatus)[keyof typeof contactStatus]

}

export type userstatus = $Enums.userstatus

export const userstatus: typeof $Enums.userstatus

export type skillsstatus = $Enums.skillsstatus

export const skillsstatus: typeof $Enums.skillsstatus

export type proficiencylanguages = $Enums.proficiencylanguages

export const proficiencylanguages: typeof $Enums.proficiencylanguages

export type companySize = $Enums.companySize

export const companySize: typeof $Enums.companySize

export type jobType = $Enums.jobType

export const jobType: typeof $Enums.jobType

export type salaryPeriod = $Enums.salaryPeriod

export const salaryPeriod: typeof $Enums.salaryPeriod

export type visaSponsorship = $Enums.visaSponsorship

export const visaSponsorship: typeof $Enums.visaSponsorship

export type expLevel = $Enums.expLevel

export const expLevel: typeof $Enums.expLevel

export type jobStatus = $Enums.jobStatus

export const jobStatus: typeof $Enums.jobStatus

export type jobRequirements = $Enums.jobRequirements

export const jobRequirements: typeof $Enums.jobRequirements

export type jobBenefit = $Enums.jobBenefit

export const jobBenefit: typeof $Enums.jobBenefit

export type applicationStatus = $Enums.applicationStatus

export const applicationStatus: typeof $Enums.applicationStatus

export type appDocumentStatus = $Enums.appDocumentStatus

export const appDocumentStatus: typeof $Enums.appDocumentStatus

export type interviewType = $Enums.interviewType

export const interviewType: typeof $Enums.interviewType

export type interviewStatus = $Enums.interviewStatus

export const interviewStatus: typeof $Enums.interviewStatus

export type contactType = $Enums.contactType

export const contactType: typeof $Enums.contactType

export type contactSalaryPaymentPeriod = $Enums.contactSalaryPaymentPeriod

export const contactSalaryPaymentPeriod: typeof $Enums.contactSalaryPaymentPeriod

export type contactStatus = $Enums.contactStatus

export const contactStatus: typeof $Enums.contactStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.users.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.users.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user_addresses`: Exposes CRUD operations for the **user_addresses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_addresses
    * const user_addresses = await prisma.user_addresses.findMany()
    * ```
    */
  get user_addresses(): Prisma.user_addressesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resumes`: Exposes CRUD operations for the **resumes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Resumes
    * const resumes = await prisma.resumes.findMany()
    * ```
    */
  get resumes(): Prisma.resumesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.educations`: Exposes CRUD operations for the **educations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Educations
    * const educations = await prisma.educations.findMany()
    * ```
    */
  get educations(): Prisma.educationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.work_experiences`: Exposes CRUD operations for the **work_experiences** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Work_experiences
    * const work_experiences = await prisma.work_experiences.findMany()
    * ```
    */
  get work_experiences(): Prisma.work_experiencesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.skills`: Exposes CRUD operations for the **skills** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Skills
    * const skills = await prisma.skills.findMany()
    * ```
    */
  get skills(): Prisma.skillsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.languages`: Exposes CRUD operations for the **languages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Languages
    * const languages = await prisma.languages.findMany()
    * ```
    */
  get languages(): Prisma.languagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.certifications`: Exposes CRUD operations for the **certifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Certifications
    * const certifications = await prisma.certifications.findMany()
    * ```
    */
  get certifications(): Prisma.certificationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.visa_information`: Exposes CRUD operations for the **visa_information** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Visa_informations
    * const visa_informations = await prisma.visa_information.findMany()
    * ```
    */
  get visa_information(): Prisma.visa_informationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companies`: Exposes CRUD operations for the **companies** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.companies.findMany()
    * ```
    */
  get companies(): Prisma.companiesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.company_locations`: Exposes CRUD operations for the **company_locations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Company_locations
    * const company_locations = await prisma.company_locations.findMany()
    * ```
    */
  get company_locations(): Prisma.company_locationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobs`: Exposes CRUD operations for the **jobs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Jobs
    * const jobs = await prisma.jobs.findMany()
    * ```
    */
  get jobs(): Prisma.jobsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.job_requirements`: Exposes CRUD operations for the **job_requirements** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Job_requirements
    * const job_requirements = await prisma.job_requirements.findMany()
    * ```
    */
  get job_requirements(): Prisma.job_requirementsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.job_responsibilites`: Exposes CRUD operations for the **job_responsibilites** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Job_responsibilites
    * const job_responsibilites = await prisma.job_responsibilites.findMany()
    * ```
    */
  get job_responsibilites(): Prisma.job_responsibilitesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.job_benefits`: Exposes CRUD operations for the **job_benefits** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Job_benefits
    * const job_benefits = await prisma.job_benefits.findMany()
    * ```
    */
  get job_benefits(): Prisma.job_benefitsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.applications`: Exposes CRUD operations for the **applications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Applications
    * const applications = await prisma.applications.findMany()
    * ```
    */
  get applications(): Prisma.applicationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.application_documents`: Exposes CRUD operations for the **application_documents** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Application_documents
    * const application_documents = await prisma.application_documents.findMany()
    * ```
    */
  get application_documents(): Prisma.application_documentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.interviews`: Exposes CRUD operations for the **interviews** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Interviews
    * const interviews = await prisma.interviews.findMany()
    * ```
    */
  get interviews(): Prisma.interviewsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contacts`: Exposes CRUD operations for the **contacts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contacts.findMany()
    * ```
    */
  get contacts(): Prisma.contactsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notifications`: Exposes CRUD operations for the **notifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notifications.findMany()
    * ```
    */
  get notifications(): Prisma.notificationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.saved_jobs`: Exposes CRUD operations for the **saved_jobs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Saved_jobs
    * const saved_jobs = await prisma.saved_jobs.findMany()
    * ```
    */
  get saved_jobs(): Prisma.saved_jobsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.job_searches`: Exposes CRUD operations for the **job_searches** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Job_searches
    * const job_searches = await prisma.job_searches.findMany()
    * ```
    */
  get job_searches(): Prisma.job_searchesDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    users: 'users',
    user_addresses: 'user_addresses',
    resumes: 'resumes',
    educations: 'educations',
    work_experiences: 'work_experiences',
    skills: 'skills',
    languages: 'languages',
    certifications: 'certifications',
    visa_information: 'visa_information',
    companies: 'companies',
    company_locations: 'company_locations',
    jobs: 'jobs',
    job_requirements: 'job_requirements',
    job_responsibilites: 'job_responsibilites',
    job_benefits: 'job_benefits',
    applications: 'applications',
    application_documents: 'application_documents',
    interviews: 'interviews',
    contacts: 'contacts',
    notifications: 'notifications',
    saved_jobs: 'saved_jobs',
    job_searches: 'job_searches'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "users" | "user_addresses" | "resumes" | "educations" | "work_experiences" | "skills" | "languages" | "certifications" | "visa_information" | "companies" | "company_locations" | "jobs" | "job_requirements" | "job_responsibilites" | "job_benefits" | "applications" | "application_documents" | "interviews" | "contacts" | "notifications" | "saved_jobs" | "job_searches"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.usersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      user_addresses: {
        payload: Prisma.$user_addressesPayload<ExtArgs>
        fields: Prisma.user_addressesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_addressesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_addressesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_addressesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_addressesPayload>
          }
          findFirst: {
            args: Prisma.user_addressesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_addressesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_addressesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_addressesPayload>
          }
          findMany: {
            args: Prisma.user_addressesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_addressesPayload>[]
          }
          create: {
            args: Prisma.user_addressesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_addressesPayload>
          }
          createMany: {
            args: Prisma.user_addressesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_addressesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_addressesPayload>[]
          }
          delete: {
            args: Prisma.user_addressesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_addressesPayload>
          }
          update: {
            args: Prisma.user_addressesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_addressesPayload>
          }
          deleteMany: {
            args: Prisma.user_addressesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_addressesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.user_addressesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_addressesPayload>[]
          }
          upsert: {
            args: Prisma.user_addressesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_addressesPayload>
          }
          aggregate: {
            args: Prisma.User_addressesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_addresses>
          }
          groupBy: {
            args: Prisma.user_addressesGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_addressesGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_addressesCountArgs<ExtArgs>
            result: $Utils.Optional<User_addressesCountAggregateOutputType> | number
          }
        }
      }
      resumes: {
        payload: Prisma.$resumesPayload<ExtArgs>
        fields: Prisma.resumesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.resumesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resumesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.resumesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resumesPayload>
          }
          findFirst: {
            args: Prisma.resumesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resumesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.resumesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resumesPayload>
          }
          findMany: {
            args: Prisma.resumesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resumesPayload>[]
          }
          create: {
            args: Prisma.resumesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resumesPayload>
          }
          createMany: {
            args: Prisma.resumesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.resumesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resumesPayload>[]
          }
          delete: {
            args: Prisma.resumesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resumesPayload>
          }
          update: {
            args: Prisma.resumesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resumesPayload>
          }
          deleteMany: {
            args: Prisma.resumesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.resumesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.resumesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resumesPayload>[]
          }
          upsert: {
            args: Prisma.resumesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resumesPayload>
          }
          aggregate: {
            args: Prisma.ResumesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResumes>
          }
          groupBy: {
            args: Prisma.resumesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResumesGroupByOutputType>[]
          }
          count: {
            args: Prisma.resumesCountArgs<ExtArgs>
            result: $Utils.Optional<ResumesCountAggregateOutputType> | number
          }
        }
      }
      educations: {
        payload: Prisma.$educationsPayload<ExtArgs>
        fields: Prisma.educationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.educationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$educationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.educationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$educationsPayload>
          }
          findFirst: {
            args: Prisma.educationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$educationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.educationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$educationsPayload>
          }
          findMany: {
            args: Prisma.educationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$educationsPayload>[]
          }
          create: {
            args: Prisma.educationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$educationsPayload>
          }
          createMany: {
            args: Prisma.educationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.educationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$educationsPayload>[]
          }
          delete: {
            args: Prisma.educationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$educationsPayload>
          }
          update: {
            args: Prisma.educationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$educationsPayload>
          }
          deleteMany: {
            args: Prisma.educationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.educationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.educationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$educationsPayload>[]
          }
          upsert: {
            args: Prisma.educationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$educationsPayload>
          }
          aggregate: {
            args: Prisma.EducationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEducations>
          }
          groupBy: {
            args: Prisma.educationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<EducationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.educationsCountArgs<ExtArgs>
            result: $Utils.Optional<EducationsCountAggregateOutputType> | number
          }
        }
      }
      work_experiences: {
        payload: Prisma.$work_experiencesPayload<ExtArgs>
        fields: Prisma.work_experiencesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.work_experiencesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_experiencesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.work_experiencesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_experiencesPayload>
          }
          findFirst: {
            args: Prisma.work_experiencesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_experiencesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.work_experiencesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_experiencesPayload>
          }
          findMany: {
            args: Prisma.work_experiencesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_experiencesPayload>[]
          }
          create: {
            args: Prisma.work_experiencesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_experiencesPayload>
          }
          createMany: {
            args: Prisma.work_experiencesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.work_experiencesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_experiencesPayload>[]
          }
          delete: {
            args: Prisma.work_experiencesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_experiencesPayload>
          }
          update: {
            args: Prisma.work_experiencesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_experiencesPayload>
          }
          deleteMany: {
            args: Prisma.work_experiencesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.work_experiencesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.work_experiencesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_experiencesPayload>[]
          }
          upsert: {
            args: Prisma.work_experiencesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_experiencesPayload>
          }
          aggregate: {
            args: Prisma.Work_experiencesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWork_experiences>
          }
          groupBy: {
            args: Prisma.work_experiencesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Work_experiencesGroupByOutputType>[]
          }
          count: {
            args: Prisma.work_experiencesCountArgs<ExtArgs>
            result: $Utils.Optional<Work_experiencesCountAggregateOutputType> | number
          }
        }
      }
      skills: {
        payload: Prisma.$skillsPayload<ExtArgs>
        fields: Prisma.skillsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.skillsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.skillsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillsPayload>
          }
          findFirst: {
            args: Prisma.skillsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.skillsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillsPayload>
          }
          findMany: {
            args: Prisma.skillsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillsPayload>[]
          }
          create: {
            args: Prisma.skillsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillsPayload>
          }
          createMany: {
            args: Prisma.skillsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.skillsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillsPayload>[]
          }
          delete: {
            args: Prisma.skillsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillsPayload>
          }
          update: {
            args: Prisma.skillsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillsPayload>
          }
          deleteMany: {
            args: Prisma.skillsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.skillsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.skillsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillsPayload>[]
          }
          upsert: {
            args: Prisma.skillsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillsPayload>
          }
          aggregate: {
            args: Prisma.SkillsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkills>
          }
          groupBy: {
            args: Prisma.skillsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkillsGroupByOutputType>[]
          }
          count: {
            args: Prisma.skillsCountArgs<ExtArgs>
            result: $Utils.Optional<SkillsCountAggregateOutputType> | number
          }
        }
      }
      languages: {
        payload: Prisma.$languagesPayload<ExtArgs>
        fields: Prisma.languagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.languagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$languagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.languagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$languagesPayload>
          }
          findFirst: {
            args: Prisma.languagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$languagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.languagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$languagesPayload>
          }
          findMany: {
            args: Prisma.languagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$languagesPayload>[]
          }
          create: {
            args: Prisma.languagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$languagesPayload>
          }
          createMany: {
            args: Prisma.languagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.languagesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$languagesPayload>[]
          }
          delete: {
            args: Prisma.languagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$languagesPayload>
          }
          update: {
            args: Prisma.languagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$languagesPayload>
          }
          deleteMany: {
            args: Prisma.languagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.languagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.languagesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$languagesPayload>[]
          }
          upsert: {
            args: Prisma.languagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$languagesPayload>
          }
          aggregate: {
            args: Prisma.LanguagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLanguages>
          }
          groupBy: {
            args: Prisma.languagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<LanguagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.languagesCountArgs<ExtArgs>
            result: $Utils.Optional<LanguagesCountAggregateOutputType> | number
          }
        }
      }
      certifications: {
        payload: Prisma.$certificationsPayload<ExtArgs>
        fields: Prisma.certificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.certificationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.certificationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificationsPayload>
          }
          findFirst: {
            args: Prisma.certificationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.certificationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificationsPayload>
          }
          findMany: {
            args: Prisma.certificationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificationsPayload>[]
          }
          create: {
            args: Prisma.certificationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificationsPayload>
          }
          createMany: {
            args: Prisma.certificationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.certificationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificationsPayload>[]
          }
          delete: {
            args: Prisma.certificationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificationsPayload>
          }
          update: {
            args: Prisma.certificationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificationsPayload>
          }
          deleteMany: {
            args: Prisma.certificationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.certificationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.certificationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificationsPayload>[]
          }
          upsert: {
            args: Prisma.certificationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificationsPayload>
          }
          aggregate: {
            args: Prisma.CertificationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCertifications>
          }
          groupBy: {
            args: Prisma.certificationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CertificationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.certificationsCountArgs<ExtArgs>
            result: $Utils.Optional<CertificationsCountAggregateOutputType> | number
          }
        }
      }
      visa_information: {
        payload: Prisma.$visa_informationPayload<ExtArgs>
        fields: Prisma.visa_informationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.visa_informationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$visa_informationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.visa_informationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$visa_informationPayload>
          }
          findFirst: {
            args: Prisma.visa_informationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$visa_informationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.visa_informationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$visa_informationPayload>
          }
          findMany: {
            args: Prisma.visa_informationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$visa_informationPayload>[]
          }
          create: {
            args: Prisma.visa_informationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$visa_informationPayload>
          }
          createMany: {
            args: Prisma.visa_informationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.visa_informationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$visa_informationPayload>[]
          }
          delete: {
            args: Prisma.visa_informationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$visa_informationPayload>
          }
          update: {
            args: Prisma.visa_informationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$visa_informationPayload>
          }
          deleteMany: {
            args: Prisma.visa_informationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.visa_informationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.visa_informationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$visa_informationPayload>[]
          }
          upsert: {
            args: Prisma.visa_informationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$visa_informationPayload>
          }
          aggregate: {
            args: Prisma.Visa_informationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVisa_information>
          }
          groupBy: {
            args: Prisma.visa_informationGroupByArgs<ExtArgs>
            result: $Utils.Optional<Visa_informationGroupByOutputType>[]
          }
          count: {
            args: Prisma.visa_informationCountArgs<ExtArgs>
            result: $Utils.Optional<Visa_informationCountAggregateOutputType> | number
          }
        }
      }
      companies: {
        payload: Prisma.$companiesPayload<ExtArgs>
        fields: Prisma.companiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.companiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.companiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          findFirst: {
            args: Prisma.companiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.companiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          findMany: {
            args: Prisma.companiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>[]
          }
          create: {
            args: Prisma.companiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          createMany: {
            args: Prisma.companiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.companiesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>[]
          }
          delete: {
            args: Prisma.companiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          update: {
            args: Prisma.companiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          deleteMany: {
            args: Prisma.companiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.companiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.companiesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>[]
          }
          upsert: {
            args: Prisma.companiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          aggregate: {
            args: Prisma.CompaniesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanies>
          }
          groupBy: {
            args: Prisma.companiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompaniesGroupByOutputType>[]
          }
          count: {
            args: Prisma.companiesCountArgs<ExtArgs>
            result: $Utils.Optional<CompaniesCountAggregateOutputType> | number
          }
        }
      }
      company_locations: {
        payload: Prisma.$company_locationsPayload<ExtArgs>
        fields: Prisma.company_locationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.company_locationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_locationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.company_locationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_locationsPayload>
          }
          findFirst: {
            args: Prisma.company_locationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_locationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.company_locationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_locationsPayload>
          }
          findMany: {
            args: Prisma.company_locationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_locationsPayload>[]
          }
          create: {
            args: Prisma.company_locationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_locationsPayload>
          }
          createMany: {
            args: Prisma.company_locationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.company_locationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_locationsPayload>[]
          }
          delete: {
            args: Prisma.company_locationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_locationsPayload>
          }
          update: {
            args: Prisma.company_locationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_locationsPayload>
          }
          deleteMany: {
            args: Prisma.company_locationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.company_locationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.company_locationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_locationsPayload>[]
          }
          upsert: {
            args: Prisma.company_locationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_locationsPayload>
          }
          aggregate: {
            args: Prisma.Company_locationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany_locations>
          }
          groupBy: {
            args: Prisma.company_locationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Company_locationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.company_locationsCountArgs<ExtArgs>
            result: $Utils.Optional<Company_locationsCountAggregateOutputType> | number
          }
        }
      }
      jobs: {
        payload: Prisma.$jobsPayload<ExtArgs>
        fields: Prisma.jobsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.jobsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.jobsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload>
          }
          findFirst: {
            args: Prisma.jobsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.jobsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload>
          }
          findMany: {
            args: Prisma.jobsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload>[]
          }
          create: {
            args: Prisma.jobsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload>
          }
          createMany: {
            args: Prisma.jobsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.jobsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload>[]
          }
          delete: {
            args: Prisma.jobsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload>
          }
          update: {
            args: Prisma.jobsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload>
          }
          deleteMany: {
            args: Prisma.jobsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.jobsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.jobsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload>[]
          }
          upsert: {
            args: Prisma.jobsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload>
          }
          aggregate: {
            args: Prisma.JobsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobs>
          }
          groupBy: {
            args: Prisma.jobsGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobsGroupByOutputType>[]
          }
          count: {
            args: Prisma.jobsCountArgs<ExtArgs>
            result: $Utils.Optional<JobsCountAggregateOutputType> | number
          }
        }
      }
      job_requirements: {
        payload: Prisma.$job_requirementsPayload<ExtArgs>
        fields: Prisma.job_requirementsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.job_requirementsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_requirementsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.job_requirementsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_requirementsPayload>
          }
          findFirst: {
            args: Prisma.job_requirementsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_requirementsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.job_requirementsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_requirementsPayload>
          }
          findMany: {
            args: Prisma.job_requirementsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_requirementsPayload>[]
          }
          create: {
            args: Prisma.job_requirementsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_requirementsPayload>
          }
          createMany: {
            args: Prisma.job_requirementsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.job_requirementsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_requirementsPayload>[]
          }
          delete: {
            args: Prisma.job_requirementsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_requirementsPayload>
          }
          update: {
            args: Prisma.job_requirementsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_requirementsPayload>
          }
          deleteMany: {
            args: Prisma.job_requirementsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.job_requirementsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.job_requirementsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_requirementsPayload>[]
          }
          upsert: {
            args: Prisma.job_requirementsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_requirementsPayload>
          }
          aggregate: {
            args: Prisma.Job_requirementsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJob_requirements>
          }
          groupBy: {
            args: Prisma.job_requirementsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Job_requirementsGroupByOutputType>[]
          }
          count: {
            args: Prisma.job_requirementsCountArgs<ExtArgs>
            result: $Utils.Optional<Job_requirementsCountAggregateOutputType> | number
          }
        }
      }
      job_responsibilites: {
        payload: Prisma.$job_responsibilitesPayload<ExtArgs>
        fields: Prisma.job_responsibilitesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.job_responsibilitesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_responsibilitesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.job_responsibilitesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_responsibilitesPayload>
          }
          findFirst: {
            args: Prisma.job_responsibilitesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_responsibilitesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.job_responsibilitesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_responsibilitesPayload>
          }
          findMany: {
            args: Prisma.job_responsibilitesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_responsibilitesPayload>[]
          }
          create: {
            args: Prisma.job_responsibilitesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_responsibilitesPayload>
          }
          createMany: {
            args: Prisma.job_responsibilitesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.job_responsibilitesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_responsibilitesPayload>[]
          }
          delete: {
            args: Prisma.job_responsibilitesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_responsibilitesPayload>
          }
          update: {
            args: Prisma.job_responsibilitesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_responsibilitesPayload>
          }
          deleteMany: {
            args: Prisma.job_responsibilitesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.job_responsibilitesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.job_responsibilitesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_responsibilitesPayload>[]
          }
          upsert: {
            args: Prisma.job_responsibilitesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_responsibilitesPayload>
          }
          aggregate: {
            args: Prisma.Job_responsibilitesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJob_responsibilites>
          }
          groupBy: {
            args: Prisma.job_responsibilitesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Job_responsibilitesGroupByOutputType>[]
          }
          count: {
            args: Prisma.job_responsibilitesCountArgs<ExtArgs>
            result: $Utils.Optional<Job_responsibilitesCountAggregateOutputType> | number
          }
        }
      }
      job_benefits: {
        payload: Prisma.$job_benefitsPayload<ExtArgs>
        fields: Prisma.job_benefitsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.job_benefitsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_benefitsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.job_benefitsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_benefitsPayload>
          }
          findFirst: {
            args: Prisma.job_benefitsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_benefitsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.job_benefitsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_benefitsPayload>
          }
          findMany: {
            args: Prisma.job_benefitsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_benefitsPayload>[]
          }
          create: {
            args: Prisma.job_benefitsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_benefitsPayload>
          }
          createMany: {
            args: Prisma.job_benefitsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.job_benefitsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_benefitsPayload>[]
          }
          delete: {
            args: Prisma.job_benefitsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_benefitsPayload>
          }
          update: {
            args: Prisma.job_benefitsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_benefitsPayload>
          }
          deleteMany: {
            args: Prisma.job_benefitsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.job_benefitsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.job_benefitsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_benefitsPayload>[]
          }
          upsert: {
            args: Prisma.job_benefitsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_benefitsPayload>
          }
          aggregate: {
            args: Prisma.Job_benefitsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJob_benefits>
          }
          groupBy: {
            args: Prisma.job_benefitsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Job_benefitsGroupByOutputType>[]
          }
          count: {
            args: Prisma.job_benefitsCountArgs<ExtArgs>
            result: $Utils.Optional<Job_benefitsCountAggregateOutputType> | number
          }
        }
      }
      applications: {
        payload: Prisma.$applicationsPayload<ExtArgs>
        fields: Prisma.applicationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.applicationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.applicationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationsPayload>
          }
          findFirst: {
            args: Prisma.applicationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.applicationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationsPayload>
          }
          findMany: {
            args: Prisma.applicationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationsPayload>[]
          }
          create: {
            args: Prisma.applicationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationsPayload>
          }
          createMany: {
            args: Prisma.applicationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.applicationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationsPayload>[]
          }
          delete: {
            args: Prisma.applicationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationsPayload>
          }
          update: {
            args: Prisma.applicationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationsPayload>
          }
          deleteMany: {
            args: Prisma.applicationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.applicationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.applicationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationsPayload>[]
          }
          upsert: {
            args: Prisma.applicationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationsPayload>
          }
          aggregate: {
            args: Prisma.ApplicationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApplications>
          }
          groupBy: {
            args: Prisma.applicationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApplicationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.applicationsCountArgs<ExtArgs>
            result: $Utils.Optional<ApplicationsCountAggregateOutputType> | number
          }
        }
      }
      application_documents: {
        payload: Prisma.$application_documentsPayload<ExtArgs>
        fields: Prisma.application_documentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.application_documentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$application_documentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.application_documentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$application_documentsPayload>
          }
          findFirst: {
            args: Prisma.application_documentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$application_documentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.application_documentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$application_documentsPayload>
          }
          findMany: {
            args: Prisma.application_documentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$application_documentsPayload>[]
          }
          create: {
            args: Prisma.application_documentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$application_documentsPayload>
          }
          createMany: {
            args: Prisma.application_documentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.application_documentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$application_documentsPayload>[]
          }
          delete: {
            args: Prisma.application_documentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$application_documentsPayload>
          }
          update: {
            args: Prisma.application_documentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$application_documentsPayload>
          }
          deleteMany: {
            args: Prisma.application_documentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.application_documentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.application_documentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$application_documentsPayload>[]
          }
          upsert: {
            args: Prisma.application_documentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$application_documentsPayload>
          }
          aggregate: {
            args: Prisma.Application_documentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApplication_documents>
          }
          groupBy: {
            args: Prisma.application_documentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Application_documentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.application_documentsCountArgs<ExtArgs>
            result: $Utils.Optional<Application_documentsCountAggregateOutputType> | number
          }
        }
      }
      interviews: {
        payload: Prisma.$interviewsPayload<ExtArgs>
        fields: Prisma.interviewsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.interviewsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$interviewsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.interviewsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$interviewsPayload>
          }
          findFirst: {
            args: Prisma.interviewsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$interviewsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.interviewsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$interviewsPayload>
          }
          findMany: {
            args: Prisma.interviewsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$interviewsPayload>[]
          }
          create: {
            args: Prisma.interviewsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$interviewsPayload>
          }
          createMany: {
            args: Prisma.interviewsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.interviewsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$interviewsPayload>[]
          }
          delete: {
            args: Prisma.interviewsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$interviewsPayload>
          }
          update: {
            args: Prisma.interviewsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$interviewsPayload>
          }
          deleteMany: {
            args: Prisma.interviewsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.interviewsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.interviewsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$interviewsPayload>[]
          }
          upsert: {
            args: Prisma.interviewsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$interviewsPayload>
          }
          aggregate: {
            args: Prisma.InterviewsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInterviews>
          }
          groupBy: {
            args: Prisma.interviewsGroupByArgs<ExtArgs>
            result: $Utils.Optional<InterviewsGroupByOutputType>[]
          }
          count: {
            args: Prisma.interviewsCountArgs<ExtArgs>
            result: $Utils.Optional<InterviewsCountAggregateOutputType> | number
          }
        }
      }
      contacts: {
        payload: Prisma.$contactsPayload<ExtArgs>
        fields: Prisma.contactsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.contactsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.contactsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactsPayload>
          }
          findFirst: {
            args: Prisma.contactsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.contactsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactsPayload>
          }
          findMany: {
            args: Prisma.contactsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactsPayload>[]
          }
          create: {
            args: Prisma.contactsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactsPayload>
          }
          createMany: {
            args: Prisma.contactsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.contactsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactsPayload>[]
          }
          delete: {
            args: Prisma.contactsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactsPayload>
          }
          update: {
            args: Prisma.contactsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactsPayload>
          }
          deleteMany: {
            args: Prisma.contactsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.contactsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.contactsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactsPayload>[]
          }
          upsert: {
            args: Prisma.contactsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactsPayload>
          }
          aggregate: {
            args: Prisma.ContactsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContacts>
          }
          groupBy: {
            args: Prisma.contactsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactsGroupByOutputType>[]
          }
          count: {
            args: Prisma.contactsCountArgs<ExtArgs>
            result: $Utils.Optional<ContactsCountAggregateOutputType> | number
          }
        }
      }
      notifications: {
        payload: Prisma.$notificationsPayload<ExtArgs>
        fields: Prisma.notificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notificationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notificationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          findFirst: {
            args: Prisma.notificationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notificationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          findMany: {
            args: Prisma.notificationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>[]
          }
          create: {
            args: Prisma.notificationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          createMany: {
            args: Prisma.notificationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.notificationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>[]
          }
          delete: {
            args: Prisma.notificationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          update: {
            args: Prisma.notificationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          deleteMany: {
            args: Prisma.notificationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notificationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.notificationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>[]
          }
          upsert: {
            args: Prisma.notificationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          aggregate: {
            args: Prisma.NotificationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotifications>
          }
          groupBy: {
            args: Prisma.notificationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.notificationsCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationsCountAggregateOutputType> | number
          }
        }
      }
      saved_jobs: {
        payload: Prisma.$saved_jobsPayload<ExtArgs>
        fields: Prisma.saved_jobsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.saved_jobsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saved_jobsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.saved_jobsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saved_jobsPayload>
          }
          findFirst: {
            args: Prisma.saved_jobsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saved_jobsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.saved_jobsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saved_jobsPayload>
          }
          findMany: {
            args: Prisma.saved_jobsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saved_jobsPayload>[]
          }
          create: {
            args: Prisma.saved_jobsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saved_jobsPayload>
          }
          createMany: {
            args: Prisma.saved_jobsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.saved_jobsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saved_jobsPayload>[]
          }
          delete: {
            args: Prisma.saved_jobsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saved_jobsPayload>
          }
          update: {
            args: Prisma.saved_jobsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saved_jobsPayload>
          }
          deleteMany: {
            args: Prisma.saved_jobsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.saved_jobsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.saved_jobsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saved_jobsPayload>[]
          }
          upsert: {
            args: Prisma.saved_jobsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saved_jobsPayload>
          }
          aggregate: {
            args: Prisma.Saved_jobsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSaved_jobs>
          }
          groupBy: {
            args: Prisma.saved_jobsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Saved_jobsGroupByOutputType>[]
          }
          count: {
            args: Prisma.saved_jobsCountArgs<ExtArgs>
            result: $Utils.Optional<Saved_jobsCountAggregateOutputType> | number
          }
        }
      }
      job_searches: {
        payload: Prisma.$job_searchesPayload<ExtArgs>
        fields: Prisma.job_searchesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.job_searchesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_searchesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.job_searchesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_searchesPayload>
          }
          findFirst: {
            args: Prisma.job_searchesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_searchesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.job_searchesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_searchesPayload>
          }
          findMany: {
            args: Prisma.job_searchesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_searchesPayload>[]
          }
          create: {
            args: Prisma.job_searchesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_searchesPayload>
          }
          createMany: {
            args: Prisma.job_searchesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.job_searchesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_searchesPayload>[]
          }
          delete: {
            args: Prisma.job_searchesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_searchesPayload>
          }
          update: {
            args: Prisma.job_searchesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_searchesPayload>
          }
          deleteMany: {
            args: Prisma.job_searchesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.job_searchesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.job_searchesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_searchesPayload>[]
          }
          upsert: {
            args: Prisma.job_searchesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_searchesPayload>
          }
          aggregate: {
            args: Prisma.Job_searchesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJob_searches>
          }
          groupBy: {
            args: Prisma.job_searchesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Job_searchesGroupByOutputType>[]
          }
          count: {
            args: Prisma.job_searchesCountArgs<ExtArgs>
            result: $Utils.Optional<Job_searchesCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    users?: usersOmit
    user_addresses?: user_addressesOmit
    resumes?: resumesOmit
    educations?: educationsOmit
    work_experiences?: work_experiencesOmit
    skills?: skillsOmit
    languages?: languagesOmit
    certifications?: certificationsOmit
    visa_information?: visa_informationOmit
    companies?: companiesOmit
    company_locations?: company_locationsOmit
    jobs?: jobsOmit
    job_requirements?: job_requirementsOmit
    job_responsibilites?: job_responsibilitesOmit
    job_benefits?: job_benefitsOmit
    applications?: applicationsOmit
    application_documents?: application_documentsOmit
    interviews?: interviewsOmit
    contacts?: contactsOmit
    notifications?: notificationsOmit
    saved_jobs?: saved_jobsOmit
    job_searches?: job_searchesOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    addresses: number
    resumes: number
    educations: number
    experiences: number
    skills: number
    languages: number
    certifications: number
    visa: number
    application: number
    contacts: number
    notification: number
    savedjob: number
    searches: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    addresses?: boolean | UsersCountOutputTypeCountAddressesArgs
    resumes?: boolean | UsersCountOutputTypeCountResumesArgs
    educations?: boolean | UsersCountOutputTypeCountEducationsArgs
    experiences?: boolean | UsersCountOutputTypeCountExperiencesArgs
    skills?: boolean | UsersCountOutputTypeCountSkillsArgs
    languages?: boolean | UsersCountOutputTypeCountLanguagesArgs
    certifications?: boolean | UsersCountOutputTypeCountCertificationsArgs
    visa?: boolean | UsersCountOutputTypeCountVisaArgs
    application?: boolean | UsersCountOutputTypeCountApplicationArgs
    contacts?: boolean | UsersCountOutputTypeCountContactsArgs
    notification?: boolean | UsersCountOutputTypeCountNotificationArgs
    savedjob?: boolean | UsersCountOutputTypeCountSavedjobArgs
    searches?: boolean | UsersCountOutputTypeCountSearchesArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountAddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_addressesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountResumesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: resumesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountEducationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: educationsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountExperiencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: work_experiencesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: skillsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountLanguagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: languagesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountCertificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: certificationsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountVisaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: visa_informationWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: applicationsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contactsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountSavedjobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: saved_jobsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountSearchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: job_searchesWhereInput
  }


  /**
   * Count Type ResumesCountOutputType
   */

  export type ResumesCountOutputType = {
    applications: number
  }

  export type ResumesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applications?: boolean | ResumesCountOutputTypeCountApplicationsArgs
  }

  // Custom InputTypes
  /**
   * ResumesCountOutputType without action
   */
  export type ResumesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumesCountOutputType
     */
    select?: ResumesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ResumesCountOutputType without action
   */
  export type ResumesCountOutputTypeCountApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: applicationsWhereInput
  }


  /**
   * Count Type CompaniesCountOutputType
   */

  export type CompaniesCountOutputType = {
    companies: number
    job: number
    contacts: number
  }

  export type CompaniesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | CompaniesCountOutputTypeCountCompaniesArgs
    job?: boolean | CompaniesCountOutputTypeCountJobArgs
    contacts?: boolean | CompaniesCountOutputTypeCountContactsArgs
  }

  // Custom InputTypes
  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesCountOutputType
     */
    select?: CompaniesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeCountCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: company_locationsWhereInput
  }

  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeCountJobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: jobsWhereInput
  }

  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contactsWhereInput
  }


  /**
   * Count Type JobsCountOutputType
   */

  export type JobsCountOutputType = {
    requirements: number
    responsibilites: number
    benefits: number
    application: number
    contact: number
    savedjob: number
  }

  export type JobsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requirements?: boolean | JobsCountOutputTypeCountRequirementsArgs
    responsibilites?: boolean | JobsCountOutputTypeCountResponsibilitesArgs
    benefits?: boolean | JobsCountOutputTypeCountBenefitsArgs
    application?: boolean | JobsCountOutputTypeCountApplicationArgs
    contact?: boolean | JobsCountOutputTypeCountContactArgs
    savedjob?: boolean | JobsCountOutputTypeCountSavedjobArgs
  }

  // Custom InputTypes
  /**
   * JobsCountOutputType without action
   */
  export type JobsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobsCountOutputType
     */
    select?: JobsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JobsCountOutputType without action
   */
  export type JobsCountOutputTypeCountRequirementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: job_requirementsWhereInput
  }

  /**
   * JobsCountOutputType without action
   */
  export type JobsCountOutputTypeCountResponsibilitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: job_responsibilitesWhereInput
  }

  /**
   * JobsCountOutputType without action
   */
  export type JobsCountOutputTypeCountBenefitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: job_benefitsWhereInput
  }

  /**
   * JobsCountOutputType without action
   */
  export type JobsCountOutputTypeCountApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: applicationsWhereInput
  }

  /**
   * JobsCountOutputType without action
   */
  export type JobsCountOutputTypeCountContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contactsWhereInput
  }

  /**
   * JobsCountOutputType without action
   */
  export type JobsCountOutputTypeCountSavedjobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: saved_jobsWhereInput
  }


  /**
   * Count Type ApplicationsCountOutputType
   */

  export type ApplicationsCountOutputType = {
    document: number
    interview: number
  }

  export type ApplicationsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | ApplicationsCountOutputTypeCountDocumentArgs
    interview?: boolean | ApplicationsCountOutputTypeCountInterviewArgs
  }

  // Custom InputTypes
  /**
   * ApplicationsCountOutputType without action
   */
  export type ApplicationsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationsCountOutputType
     */
    select?: ApplicationsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ApplicationsCountOutputType without action
   */
  export type ApplicationsCountOutputTypeCountDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: application_documentsWhereInput
  }

  /**
   * ApplicationsCountOutputType without action
   */
  export type ApplicationsCountOutputTypeCountInterviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: interviewsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id: number | null
  }

  export type UsersSumAggregateOutputType = {
    id: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: number | null
    first_name: string | null
    last_name: string | null
    email: string | null
    password_hash: string | null
    phone_number: string | null
    country_code: string | null
    date_of_birth: Date | null
    gender: string | null
    profile_picture_url: string | null
    bio: string | null
    created_at: Date | null
    updated_at: Date | null
    last_login_at: Date | null
    status: $Enums.userstatus | null
  }

  export type UsersMaxAggregateOutputType = {
    id: number | null
    first_name: string | null
    last_name: string | null
    email: string | null
    password_hash: string | null
    phone_number: string | null
    country_code: string | null
    date_of_birth: Date | null
    gender: string | null
    profile_picture_url: string | null
    bio: string | null
    created_at: Date | null
    updated_at: Date | null
    last_login_at: Date | null
    status: $Enums.userstatus | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    first_name: number
    last_name: number
    email: number
    password_hash: number
    phone_number: number
    country_code: number
    date_of_birth: number
    gender: number
    profile_picture_url: number
    bio: number
    created_at: number
    updated_at: number
    last_login_at: number
    status: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id?: true
  }

  export type UsersSumAggregateInputType = {
    id?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    password_hash?: true
    phone_number?: true
    country_code?: true
    date_of_birth?: true
    gender?: true
    profile_picture_url?: true
    bio?: true
    created_at?: true
    updated_at?: true
    last_login_at?: true
    status?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    password_hash?: true
    phone_number?: true
    country_code?: true
    date_of_birth?: true
    gender?: true
    profile_picture_url?: true
    bio?: true
    created_at?: true
    updated_at?: true
    last_login_at?: true
    status?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    password_hash?: true
    phone_number?: true
    country_code?: true
    date_of_birth?: true
    gender?: true
    profile_picture_url?: true
    bio?: true
    created_at?: true
    updated_at?: true
    last_login_at?: true
    status?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: number
    first_name: string
    last_name: string
    email: string
    password_hash: string
    phone_number: string | null
    country_code: string | null
    date_of_birth: Date | null
    gender: string | null
    profile_picture_url: string | null
    bio: string | null
    created_at: Date
    updated_at: Date
    last_login_at: Date | null
    status: $Enums.userstatus
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password_hash?: boolean
    phone_number?: boolean
    country_code?: boolean
    date_of_birth?: boolean
    gender?: boolean
    profile_picture_url?: boolean
    bio?: boolean
    created_at?: boolean
    updated_at?: boolean
    last_login_at?: boolean
    status?: boolean
    addresses?: boolean | users$addressesArgs<ExtArgs>
    resumes?: boolean | users$resumesArgs<ExtArgs>
    educations?: boolean | users$educationsArgs<ExtArgs>
    experiences?: boolean | users$experiencesArgs<ExtArgs>
    skills?: boolean | users$skillsArgs<ExtArgs>
    languages?: boolean | users$languagesArgs<ExtArgs>
    certifications?: boolean | users$certificationsArgs<ExtArgs>
    visa?: boolean | users$visaArgs<ExtArgs>
    application?: boolean | users$applicationArgs<ExtArgs>
    contacts?: boolean | users$contactsArgs<ExtArgs>
    notification?: boolean | users$notificationArgs<ExtArgs>
    savedjob?: boolean | users$savedjobArgs<ExtArgs>
    searches?: boolean | users$searchesArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password_hash?: boolean
    phone_number?: boolean
    country_code?: boolean
    date_of_birth?: boolean
    gender?: boolean
    profile_picture_url?: boolean
    bio?: boolean
    created_at?: boolean
    updated_at?: boolean
    last_login_at?: boolean
    status?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password_hash?: boolean
    phone_number?: boolean
    country_code?: boolean
    date_of_birth?: boolean
    gender?: boolean
    profile_picture_url?: boolean
    bio?: boolean
    created_at?: boolean
    updated_at?: boolean
    last_login_at?: boolean
    status?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password_hash?: boolean
    phone_number?: boolean
    country_code?: boolean
    date_of_birth?: boolean
    gender?: boolean
    profile_picture_url?: boolean
    bio?: boolean
    created_at?: boolean
    updated_at?: boolean
    last_login_at?: boolean
    status?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "first_name" | "last_name" | "email" | "password_hash" | "phone_number" | "country_code" | "date_of_birth" | "gender" | "profile_picture_url" | "bio" | "created_at" | "updated_at" | "last_login_at" | "status", ExtArgs["result"]["users"]>
  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    addresses?: boolean | users$addressesArgs<ExtArgs>
    resumes?: boolean | users$resumesArgs<ExtArgs>
    educations?: boolean | users$educationsArgs<ExtArgs>
    experiences?: boolean | users$experiencesArgs<ExtArgs>
    skills?: boolean | users$skillsArgs<ExtArgs>
    languages?: boolean | users$languagesArgs<ExtArgs>
    certifications?: boolean | users$certificationsArgs<ExtArgs>
    visa?: boolean | users$visaArgs<ExtArgs>
    application?: boolean | users$applicationArgs<ExtArgs>
    contacts?: boolean | users$contactsArgs<ExtArgs>
    notification?: boolean | users$notificationArgs<ExtArgs>
    savedjob?: boolean | users$savedjobArgs<ExtArgs>
    searches?: boolean | users$searchesArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type usersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type usersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      addresses: Prisma.$user_addressesPayload<ExtArgs>[]
      resumes: Prisma.$resumesPayload<ExtArgs>[]
      educations: Prisma.$educationsPayload<ExtArgs>[]
      experiences: Prisma.$work_experiencesPayload<ExtArgs>[]
      skills: Prisma.$skillsPayload<ExtArgs>[]
      languages: Prisma.$languagesPayload<ExtArgs>[]
      certifications: Prisma.$certificationsPayload<ExtArgs>[]
      visa: Prisma.$visa_informationPayload<ExtArgs>[]
      application: Prisma.$applicationsPayload<ExtArgs>[]
      contacts: Prisma.$contactsPayload<ExtArgs>[]
      notification: Prisma.$notificationsPayload<ExtArgs>[]
      savedjob: Prisma.$saved_jobsPayload<ExtArgs>[]
      searches: Prisma.$job_searchesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      first_name: string
      last_name: string
      email: string
      password_hash: string
      phone_number: string | null
      country_code: string | null
      date_of_birth: Date | null
      gender: string | null
      profile_picture_url: string | null
      bio: string | null
      created_at: Date
      updated_at: Date
      last_login_at: Date | null
      status: $Enums.userstatus
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {usersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends usersUpdateManyAndReturnArgs>(args: SelectSubset<T, usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    addresses<T extends users$addressesArgs<ExtArgs> = {}>(args?: Subset<T, users$addressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_addressesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    resumes<T extends users$resumesArgs<ExtArgs> = {}>(args?: Subset<T, users$resumesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$resumesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    educations<T extends users$educationsArgs<ExtArgs> = {}>(args?: Subset<T, users$educationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$educationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    experiences<T extends users$experiencesArgs<ExtArgs> = {}>(args?: Subset<T, users$experiencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$work_experiencesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    skills<T extends users$skillsArgs<ExtArgs> = {}>(args?: Subset<T, users$skillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    languages<T extends users$languagesArgs<ExtArgs> = {}>(args?: Subset<T, users$languagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$languagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    certifications<T extends users$certificationsArgs<ExtArgs> = {}>(args?: Subset<T, users$certificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$certificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    visa<T extends users$visaArgs<ExtArgs> = {}>(args?: Subset<T, users$visaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$visa_informationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    application<T extends users$applicationArgs<ExtArgs> = {}>(args?: Subset<T, users$applicationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$applicationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contacts<T extends users$contactsArgs<ExtArgs> = {}>(args?: Subset<T, users$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notification<T extends users$notificationArgs<ExtArgs> = {}>(args?: Subset<T, users$notificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    savedjob<T extends users$savedjobArgs<ExtArgs> = {}>(args?: Subset<T, users$savedjobArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$saved_jobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    searches<T extends users$searchesArgs<ExtArgs> = {}>(args?: Subset<T, users$searchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_searchesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'Int'>
    readonly first_name: FieldRef<"users", 'String'>
    readonly last_name: FieldRef<"users", 'String'>
    readonly email: FieldRef<"users", 'String'>
    readonly password_hash: FieldRef<"users", 'String'>
    readonly phone_number: FieldRef<"users", 'String'>
    readonly country_code: FieldRef<"users", 'String'>
    readonly date_of_birth: FieldRef<"users", 'DateTime'>
    readonly gender: FieldRef<"users", 'String'>
    readonly profile_picture_url: FieldRef<"users", 'String'>
    readonly bio: FieldRef<"users", 'String'>
    readonly created_at: FieldRef<"users", 'DateTime'>
    readonly updated_at: FieldRef<"users", 'DateTime'>
    readonly last_login_at: FieldRef<"users", 'DateTime'>
    readonly status: FieldRef<"users", 'userstatus'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users createManyAndReturn
   */
  export type usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users updateManyAndReturn
   */
  export type usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * users.addresses
   */
  export type users$addressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_addresses
     */
    select?: user_addressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_addresses
     */
    omit?: user_addressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_addressesInclude<ExtArgs> | null
    where?: user_addressesWhereInput
    orderBy?: user_addressesOrderByWithRelationInput | user_addressesOrderByWithRelationInput[]
    cursor?: user_addressesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_addressesScalarFieldEnum | User_addressesScalarFieldEnum[]
  }

  /**
   * users.resumes
   */
  export type users$resumesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resumes
     */
    select?: resumesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resumes
     */
    omit?: resumesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resumesInclude<ExtArgs> | null
    where?: resumesWhereInput
    orderBy?: resumesOrderByWithRelationInput | resumesOrderByWithRelationInput[]
    cursor?: resumesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResumesScalarFieldEnum | ResumesScalarFieldEnum[]
  }

  /**
   * users.educations
   */
  export type users$educationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the educations
     */
    select?: educationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the educations
     */
    omit?: educationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: educationsInclude<ExtArgs> | null
    where?: educationsWhereInput
    orderBy?: educationsOrderByWithRelationInput | educationsOrderByWithRelationInput[]
    cursor?: educationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EducationsScalarFieldEnum | EducationsScalarFieldEnum[]
  }

  /**
   * users.experiences
   */
  export type users$experiencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_experiences
     */
    select?: work_experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_experiences
     */
    omit?: work_experiencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_experiencesInclude<ExtArgs> | null
    where?: work_experiencesWhereInput
    orderBy?: work_experiencesOrderByWithRelationInput | work_experiencesOrderByWithRelationInput[]
    cursor?: work_experiencesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Work_experiencesScalarFieldEnum | Work_experiencesScalarFieldEnum[]
  }

  /**
   * users.skills
   */
  export type users$skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skills
     */
    omit?: skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillsInclude<ExtArgs> | null
    where?: skillsWhereInput
    orderBy?: skillsOrderByWithRelationInput | skillsOrderByWithRelationInput[]
    cursor?: skillsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SkillsScalarFieldEnum | SkillsScalarFieldEnum[]
  }

  /**
   * users.languages
   */
  export type users$languagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the languages
     */
    select?: languagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the languages
     */
    omit?: languagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: languagesInclude<ExtArgs> | null
    where?: languagesWhereInput
    orderBy?: languagesOrderByWithRelationInput | languagesOrderByWithRelationInput[]
    cursor?: languagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LanguagesScalarFieldEnum | LanguagesScalarFieldEnum[]
  }

  /**
   * users.certifications
   */
  export type users$certificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certifications
     */
    select?: certificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certifications
     */
    omit?: certificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificationsInclude<ExtArgs> | null
    where?: certificationsWhereInput
    orderBy?: certificationsOrderByWithRelationInput | certificationsOrderByWithRelationInput[]
    cursor?: certificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificationsScalarFieldEnum | CertificationsScalarFieldEnum[]
  }

  /**
   * users.visa
   */
  export type users$visaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the visa_information
     */
    select?: visa_informationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the visa_information
     */
    omit?: visa_informationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: visa_informationInclude<ExtArgs> | null
    where?: visa_informationWhereInput
    orderBy?: visa_informationOrderByWithRelationInput | visa_informationOrderByWithRelationInput[]
    cursor?: visa_informationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Visa_informationScalarFieldEnum | Visa_informationScalarFieldEnum[]
  }

  /**
   * users.application
   */
  export type users$applicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applications
     */
    select?: applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applications
     */
    omit?: applicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationsInclude<ExtArgs> | null
    where?: applicationsWhereInput
    orderBy?: applicationsOrderByWithRelationInput | applicationsOrderByWithRelationInput[]
    cursor?: applicationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApplicationsScalarFieldEnum | ApplicationsScalarFieldEnum[]
  }

  /**
   * users.contacts
   */
  export type users$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contacts
     */
    omit?: contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactsInclude<ExtArgs> | null
    where?: contactsWhereInput
    orderBy?: contactsOrderByWithRelationInput | contactsOrderByWithRelationInput[]
    cursor?: contactsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactsScalarFieldEnum | ContactsScalarFieldEnum[]
  }

  /**
   * users.notification
   */
  export type users$notificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    where?: notificationsWhereInput
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    cursor?: notificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * users.savedjob
   */
  export type users$savedjobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saved_jobs
     */
    select?: saved_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saved_jobs
     */
    omit?: saved_jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saved_jobsInclude<ExtArgs> | null
    where?: saved_jobsWhereInput
    orderBy?: saved_jobsOrderByWithRelationInput | saved_jobsOrderByWithRelationInput[]
    cursor?: saved_jobsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Saved_jobsScalarFieldEnum | Saved_jobsScalarFieldEnum[]
  }

  /**
   * users.searches
   */
  export type users$searchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_searches
     */
    select?: job_searchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_searches
     */
    omit?: job_searchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_searchesInclude<ExtArgs> | null
    where?: job_searchesWhereInput
    orderBy?: job_searchesOrderByWithRelationInput | job_searchesOrderByWithRelationInput[]
    cursor?: job_searchesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Job_searchesScalarFieldEnum | Job_searchesScalarFieldEnum[]
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Model user_addresses
   */

  export type AggregateUser_addresses = {
    _count: User_addressesCountAggregateOutputType | null
    _avg: User_addressesAvgAggregateOutputType | null
    _sum: User_addressesSumAggregateOutputType | null
    _min: User_addressesMinAggregateOutputType | null
    _max: User_addressesMaxAggregateOutputType | null
  }

  export type User_addressesAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type User_addressesSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type User_addressesMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    adress_line1: string | null
    adress_line2: string | null
    city: string | null
    state: string | null
    postal_code: string | null
    country: string | null
    is_primary: boolean | null
    created_at: Date | null
  }

  export type User_addressesMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    adress_line1: string | null
    adress_line2: string | null
    city: string | null
    state: string | null
    postal_code: string | null
    country: string | null
    is_primary: boolean | null
    created_at: Date | null
  }

  export type User_addressesCountAggregateOutputType = {
    id: number
    user_id: number
    adress_line1: number
    adress_line2: number
    city: number
    state: number
    postal_code: number
    country: number
    is_primary: number
    created_at: number
    _all: number
  }


  export type User_addressesAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type User_addressesSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type User_addressesMinAggregateInputType = {
    id?: true
    user_id?: true
    adress_line1?: true
    adress_line2?: true
    city?: true
    state?: true
    postal_code?: true
    country?: true
    is_primary?: true
    created_at?: true
  }

  export type User_addressesMaxAggregateInputType = {
    id?: true
    user_id?: true
    adress_line1?: true
    adress_line2?: true
    city?: true
    state?: true
    postal_code?: true
    country?: true
    is_primary?: true
    created_at?: true
  }

  export type User_addressesCountAggregateInputType = {
    id?: true
    user_id?: true
    adress_line1?: true
    adress_line2?: true
    city?: true
    state?: true
    postal_code?: true
    country?: true
    is_primary?: true
    created_at?: true
    _all?: true
  }

  export type User_addressesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_addresses to aggregate.
     */
    where?: user_addressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_addresses to fetch.
     */
    orderBy?: user_addressesOrderByWithRelationInput | user_addressesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_addressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_addresses
    **/
    _count?: true | User_addressesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_addressesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_addressesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_addressesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_addressesMaxAggregateInputType
  }

  export type GetUser_addressesAggregateType<T extends User_addressesAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_addresses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_addresses[P]>
      : GetScalarType<T[P], AggregateUser_addresses[P]>
  }




  export type user_addressesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_addressesWhereInput
    orderBy?: user_addressesOrderByWithAggregationInput | user_addressesOrderByWithAggregationInput[]
    by: User_addressesScalarFieldEnum[] | User_addressesScalarFieldEnum
    having?: user_addressesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_addressesCountAggregateInputType | true
    _avg?: User_addressesAvgAggregateInputType
    _sum?: User_addressesSumAggregateInputType
    _min?: User_addressesMinAggregateInputType
    _max?: User_addressesMaxAggregateInputType
  }

  export type User_addressesGroupByOutputType = {
    id: number
    user_id: number
    adress_line1: string
    adress_line2: string | null
    city: string
    state: string | null
    postal_code: string | null
    country: string
    is_primary: boolean | null
    created_at: Date | null
    _count: User_addressesCountAggregateOutputType | null
    _avg: User_addressesAvgAggregateOutputType | null
    _sum: User_addressesSumAggregateOutputType | null
    _min: User_addressesMinAggregateOutputType | null
    _max: User_addressesMaxAggregateOutputType | null
  }

  type GetUser_addressesGroupByPayload<T extends user_addressesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_addressesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_addressesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_addressesGroupByOutputType[P]>
            : GetScalarType<T[P], User_addressesGroupByOutputType[P]>
        }
      >
    >


  export type user_addressesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    adress_line1?: boolean
    adress_line2?: boolean
    city?: boolean
    state?: boolean
    postal_code?: boolean
    country?: boolean
    is_primary?: boolean
    created_at?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_addresses"]>

  export type user_addressesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    adress_line1?: boolean
    adress_line2?: boolean
    city?: boolean
    state?: boolean
    postal_code?: boolean
    country?: boolean
    is_primary?: boolean
    created_at?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_addresses"]>

  export type user_addressesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    adress_line1?: boolean
    adress_line2?: boolean
    city?: boolean
    state?: boolean
    postal_code?: boolean
    country?: boolean
    is_primary?: boolean
    created_at?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_addresses"]>

  export type user_addressesSelectScalar = {
    id?: boolean
    user_id?: boolean
    adress_line1?: boolean
    adress_line2?: boolean
    city?: boolean
    state?: boolean
    postal_code?: boolean
    country?: boolean
    is_primary?: boolean
    created_at?: boolean
  }

  export type user_addressesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "adress_line1" | "adress_line2" | "city" | "state" | "postal_code" | "country" | "is_primary" | "created_at", ExtArgs["result"]["user_addresses"]>
  export type user_addressesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type user_addressesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type user_addressesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $user_addressesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_addresses"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      adress_line1: string
      adress_line2: string | null
      city: string
      state: string | null
      postal_code: string | null
      country: string
      is_primary: boolean | null
      created_at: Date | null
    }, ExtArgs["result"]["user_addresses"]>
    composites: {}
  }

  type user_addressesGetPayload<S extends boolean | null | undefined | user_addressesDefaultArgs> = $Result.GetResult<Prisma.$user_addressesPayload, S>

  type user_addressesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<user_addressesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: User_addressesCountAggregateInputType | true
    }

  export interface user_addressesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_addresses'], meta: { name: 'user_addresses' } }
    /**
     * Find zero or one User_addresses that matches the filter.
     * @param {user_addressesFindUniqueArgs} args - Arguments to find a User_addresses
     * @example
     * // Get one User_addresses
     * const user_addresses = await prisma.user_addresses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_addressesFindUniqueArgs>(args: SelectSubset<T, user_addressesFindUniqueArgs<ExtArgs>>): Prisma__user_addressesClient<$Result.GetResult<Prisma.$user_addressesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User_addresses that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {user_addressesFindUniqueOrThrowArgs} args - Arguments to find a User_addresses
     * @example
     * // Get one User_addresses
     * const user_addresses = await prisma.user_addresses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_addressesFindUniqueOrThrowArgs>(args: SelectSubset<T, user_addressesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_addressesClient<$Result.GetResult<Prisma.$user_addressesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_addressesFindFirstArgs} args - Arguments to find a User_addresses
     * @example
     * // Get one User_addresses
     * const user_addresses = await prisma.user_addresses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_addressesFindFirstArgs>(args?: SelectSubset<T, user_addressesFindFirstArgs<ExtArgs>>): Prisma__user_addressesClient<$Result.GetResult<Prisma.$user_addressesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_addresses that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_addressesFindFirstOrThrowArgs} args - Arguments to find a User_addresses
     * @example
     * // Get one User_addresses
     * const user_addresses = await prisma.user_addresses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_addressesFindFirstOrThrowArgs>(args?: SelectSubset<T, user_addressesFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_addressesClient<$Result.GetResult<Prisma.$user_addressesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more User_addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_addressesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_addresses
     * const user_addresses = await prisma.user_addresses.findMany()
     * 
     * // Get first 10 User_addresses
     * const user_addresses = await prisma.user_addresses.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_addressesWithIdOnly = await prisma.user_addresses.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends user_addressesFindManyArgs>(args?: SelectSubset<T, user_addressesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_addressesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User_addresses.
     * @param {user_addressesCreateArgs} args - Arguments to create a User_addresses.
     * @example
     * // Create one User_addresses
     * const User_addresses = await prisma.user_addresses.create({
     *   data: {
     *     // ... data to create a User_addresses
     *   }
     * })
     * 
     */
    create<T extends user_addressesCreateArgs>(args: SelectSubset<T, user_addressesCreateArgs<ExtArgs>>): Prisma__user_addressesClient<$Result.GetResult<Prisma.$user_addressesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many User_addresses.
     * @param {user_addressesCreateManyArgs} args - Arguments to create many User_addresses.
     * @example
     * // Create many User_addresses
     * const user_addresses = await prisma.user_addresses.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_addressesCreateManyArgs>(args?: SelectSubset<T, user_addressesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_addresses and returns the data saved in the database.
     * @param {user_addressesCreateManyAndReturnArgs} args - Arguments to create many User_addresses.
     * @example
     * // Create many User_addresses
     * const user_addresses = await prisma.user_addresses.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_addresses and only return the `id`
     * const user_addressesWithIdOnly = await prisma.user_addresses.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_addressesCreateManyAndReturnArgs>(args?: SelectSubset<T, user_addressesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_addressesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User_addresses.
     * @param {user_addressesDeleteArgs} args - Arguments to delete one User_addresses.
     * @example
     * // Delete one User_addresses
     * const User_addresses = await prisma.user_addresses.delete({
     *   where: {
     *     // ... filter to delete one User_addresses
     *   }
     * })
     * 
     */
    delete<T extends user_addressesDeleteArgs>(args: SelectSubset<T, user_addressesDeleteArgs<ExtArgs>>): Prisma__user_addressesClient<$Result.GetResult<Prisma.$user_addressesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User_addresses.
     * @param {user_addressesUpdateArgs} args - Arguments to update one User_addresses.
     * @example
     * // Update one User_addresses
     * const user_addresses = await prisma.user_addresses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_addressesUpdateArgs>(args: SelectSubset<T, user_addressesUpdateArgs<ExtArgs>>): Prisma__user_addressesClient<$Result.GetResult<Prisma.$user_addressesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more User_addresses.
     * @param {user_addressesDeleteManyArgs} args - Arguments to filter User_addresses to delete.
     * @example
     * // Delete a few User_addresses
     * const { count } = await prisma.user_addresses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_addressesDeleteManyArgs>(args?: SelectSubset<T, user_addressesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_addressesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_addresses
     * const user_addresses = await prisma.user_addresses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_addressesUpdateManyArgs>(args: SelectSubset<T, user_addressesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_addresses and returns the data updated in the database.
     * @param {user_addressesUpdateManyAndReturnArgs} args - Arguments to update many User_addresses.
     * @example
     * // Update many User_addresses
     * const user_addresses = await prisma.user_addresses.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more User_addresses and only return the `id`
     * const user_addressesWithIdOnly = await prisma.user_addresses.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends user_addressesUpdateManyAndReturnArgs>(args: SelectSubset<T, user_addressesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_addressesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User_addresses.
     * @param {user_addressesUpsertArgs} args - Arguments to update or create a User_addresses.
     * @example
     * // Update or create a User_addresses
     * const user_addresses = await prisma.user_addresses.upsert({
     *   create: {
     *     // ... data to create a User_addresses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_addresses we want to update
     *   }
     * })
     */
    upsert<T extends user_addressesUpsertArgs>(args: SelectSubset<T, user_addressesUpsertArgs<ExtArgs>>): Prisma__user_addressesClient<$Result.GetResult<Prisma.$user_addressesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of User_addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_addressesCountArgs} args - Arguments to filter User_addresses to count.
     * @example
     * // Count the number of User_addresses
     * const count = await prisma.user_addresses.count({
     *   where: {
     *     // ... the filter for the User_addresses we want to count
     *   }
     * })
    **/
    count<T extends user_addressesCountArgs>(
      args?: Subset<T, user_addressesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_addressesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_addressesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_addressesAggregateArgs>(args: Subset<T, User_addressesAggregateArgs>): Prisma.PrismaPromise<GetUser_addressesAggregateType<T>>

    /**
     * Group by User_addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_addressesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_addressesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_addressesGroupByArgs['orderBy'] }
        : { orderBy?: user_addressesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_addressesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_addressesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_addresses model
   */
  readonly fields: user_addressesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_addresses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_addressesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_addresses model
   */
  interface user_addressesFieldRefs {
    readonly id: FieldRef<"user_addresses", 'Int'>
    readonly user_id: FieldRef<"user_addresses", 'Int'>
    readonly adress_line1: FieldRef<"user_addresses", 'String'>
    readonly adress_line2: FieldRef<"user_addresses", 'String'>
    readonly city: FieldRef<"user_addresses", 'String'>
    readonly state: FieldRef<"user_addresses", 'String'>
    readonly postal_code: FieldRef<"user_addresses", 'String'>
    readonly country: FieldRef<"user_addresses", 'String'>
    readonly is_primary: FieldRef<"user_addresses", 'Boolean'>
    readonly created_at: FieldRef<"user_addresses", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user_addresses findUnique
   */
  export type user_addressesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_addresses
     */
    select?: user_addressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_addresses
     */
    omit?: user_addressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_addressesInclude<ExtArgs> | null
    /**
     * Filter, which user_addresses to fetch.
     */
    where: user_addressesWhereUniqueInput
  }

  /**
   * user_addresses findUniqueOrThrow
   */
  export type user_addressesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_addresses
     */
    select?: user_addressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_addresses
     */
    omit?: user_addressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_addressesInclude<ExtArgs> | null
    /**
     * Filter, which user_addresses to fetch.
     */
    where: user_addressesWhereUniqueInput
  }

  /**
   * user_addresses findFirst
   */
  export type user_addressesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_addresses
     */
    select?: user_addressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_addresses
     */
    omit?: user_addressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_addressesInclude<ExtArgs> | null
    /**
     * Filter, which user_addresses to fetch.
     */
    where?: user_addressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_addresses to fetch.
     */
    orderBy?: user_addressesOrderByWithRelationInput | user_addressesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_addresses.
     */
    cursor?: user_addressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_addresses.
     */
    distinct?: User_addressesScalarFieldEnum | User_addressesScalarFieldEnum[]
  }

  /**
   * user_addresses findFirstOrThrow
   */
  export type user_addressesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_addresses
     */
    select?: user_addressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_addresses
     */
    omit?: user_addressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_addressesInclude<ExtArgs> | null
    /**
     * Filter, which user_addresses to fetch.
     */
    where?: user_addressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_addresses to fetch.
     */
    orderBy?: user_addressesOrderByWithRelationInput | user_addressesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_addresses.
     */
    cursor?: user_addressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_addresses.
     */
    distinct?: User_addressesScalarFieldEnum | User_addressesScalarFieldEnum[]
  }

  /**
   * user_addresses findMany
   */
  export type user_addressesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_addresses
     */
    select?: user_addressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_addresses
     */
    omit?: user_addressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_addressesInclude<ExtArgs> | null
    /**
     * Filter, which user_addresses to fetch.
     */
    where?: user_addressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_addresses to fetch.
     */
    orderBy?: user_addressesOrderByWithRelationInput | user_addressesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_addresses.
     */
    cursor?: user_addressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_addresses.
     */
    skip?: number
    distinct?: User_addressesScalarFieldEnum | User_addressesScalarFieldEnum[]
  }

  /**
   * user_addresses create
   */
  export type user_addressesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_addresses
     */
    select?: user_addressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_addresses
     */
    omit?: user_addressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_addressesInclude<ExtArgs> | null
    /**
     * The data needed to create a user_addresses.
     */
    data: XOR<user_addressesCreateInput, user_addressesUncheckedCreateInput>
  }

  /**
   * user_addresses createMany
   */
  export type user_addressesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_addresses.
     */
    data: user_addressesCreateManyInput | user_addressesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_addresses createManyAndReturn
   */
  export type user_addressesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_addresses
     */
    select?: user_addressesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_addresses
     */
    omit?: user_addressesOmit<ExtArgs> | null
    /**
     * The data used to create many user_addresses.
     */
    data: user_addressesCreateManyInput | user_addressesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_addressesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_addresses update
   */
  export type user_addressesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_addresses
     */
    select?: user_addressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_addresses
     */
    omit?: user_addressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_addressesInclude<ExtArgs> | null
    /**
     * The data needed to update a user_addresses.
     */
    data: XOR<user_addressesUpdateInput, user_addressesUncheckedUpdateInput>
    /**
     * Choose, which user_addresses to update.
     */
    where: user_addressesWhereUniqueInput
  }

  /**
   * user_addresses updateMany
   */
  export type user_addressesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_addresses.
     */
    data: XOR<user_addressesUpdateManyMutationInput, user_addressesUncheckedUpdateManyInput>
    /**
     * Filter which user_addresses to update
     */
    where?: user_addressesWhereInput
    /**
     * Limit how many user_addresses to update.
     */
    limit?: number
  }

  /**
   * user_addresses updateManyAndReturn
   */
  export type user_addressesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_addresses
     */
    select?: user_addressesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_addresses
     */
    omit?: user_addressesOmit<ExtArgs> | null
    /**
     * The data used to update user_addresses.
     */
    data: XOR<user_addressesUpdateManyMutationInput, user_addressesUncheckedUpdateManyInput>
    /**
     * Filter which user_addresses to update
     */
    where?: user_addressesWhereInput
    /**
     * Limit how many user_addresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_addressesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_addresses upsert
   */
  export type user_addressesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_addresses
     */
    select?: user_addressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_addresses
     */
    omit?: user_addressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_addressesInclude<ExtArgs> | null
    /**
     * The filter to search for the user_addresses to update in case it exists.
     */
    where: user_addressesWhereUniqueInput
    /**
     * In case the user_addresses found by the `where` argument doesn't exist, create a new user_addresses with this data.
     */
    create: XOR<user_addressesCreateInput, user_addressesUncheckedCreateInput>
    /**
     * In case the user_addresses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_addressesUpdateInput, user_addressesUncheckedUpdateInput>
  }

  /**
   * user_addresses delete
   */
  export type user_addressesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_addresses
     */
    select?: user_addressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_addresses
     */
    omit?: user_addressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_addressesInclude<ExtArgs> | null
    /**
     * Filter which user_addresses to delete.
     */
    where: user_addressesWhereUniqueInput
  }

  /**
   * user_addresses deleteMany
   */
  export type user_addressesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_addresses to delete
     */
    where?: user_addressesWhereInput
    /**
     * Limit how many user_addresses to delete.
     */
    limit?: number
  }

  /**
   * user_addresses without action
   */
  export type user_addressesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_addresses
     */
    select?: user_addressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_addresses
     */
    omit?: user_addressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_addressesInclude<ExtArgs> | null
  }


  /**
   * Model resumes
   */

  export type AggregateResumes = {
    _count: ResumesCountAggregateOutputType | null
    _avg: ResumesAvgAggregateOutputType | null
    _sum: ResumesSumAggregateOutputType | null
    _min: ResumesMinAggregateOutputType | null
    _max: ResumesMaxAggregateOutputType | null
  }

  export type ResumesAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type ResumesSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type ResumesMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    title: string | null
    file_url: string | null
    is_default: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ResumesMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    title: string | null
    file_url: string | null
    is_default: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ResumesCountAggregateOutputType = {
    id: number
    user_id: number
    title: number
    file_url: number
    is_default: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ResumesAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type ResumesSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type ResumesMinAggregateInputType = {
    id?: true
    user_id?: true
    title?: true
    file_url?: true
    is_default?: true
    created_at?: true
    updated_at?: true
  }

  export type ResumesMaxAggregateInputType = {
    id?: true
    user_id?: true
    title?: true
    file_url?: true
    is_default?: true
    created_at?: true
    updated_at?: true
  }

  export type ResumesCountAggregateInputType = {
    id?: true
    user_id?: true
    title?: true
    file_url?: true
    is_default?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ResumesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which resumes to aggregate.
     */
    where?: resumesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of resumes to fetch.
     */
    orderBy?: resumesOrderByWithRelationInput | resumesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: resumesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` resumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` resumes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned resumes
    **/
    _count?: true | ResumesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResumesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResumesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResumesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResumesMaxAggregateInputType
  }

  export type GetResumesAggregateType<T extends ResumesAggregateArgs> = {
        [P in keyof T & keyof AggregateResumes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResumes[P]>
      : GetScalarType<T[P], AggregateResumes[P]>
  }




  export type resumesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: resumesWhereInput
    orderBy?: resumesOrderByWithAggregationInput | resumesOrderByWithAggregationInput[]
    by: ResumesScalarFieldEnum[] | ResumesScalarFieldEnum
    having?: resumesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResumesCountAggregateInputType | true
    _avg?: ResumesAvgAggregateInputType
    _sum?: ResumesSumAggregateInputType
    _min?: ResumesMinAggregateInputType
    _max?: ResumesMaxAggregateInputType
  }

  export type ResumesGroupByOutputType = {
    id: number
    user_id: number
    title: string
    file_url: string
    is_default: boolean
    created_at: Date
    updated_at: Date
    _count: ResumesCountAggregateOutputType | null
    _avg: ResumesAvgAggregateOutputType | null
    _sum: ResumesSumAggregateOutputType | null
    _min: ResumesMinAggregateOutputType | null
    _max: ResumesMaxAggregateOutputType | null
  }

  type GetResumesGroupByPayload<T extends resumesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResumesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResumesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResumesGroupByOutputType[P]>
            : GetScalarType<T[P], ResumesGroupByOutputType[P]>
        }
      >
    >


  export type resumesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    title?: boolean
    file_url?: boolean
    is_default?: boolean
    created_at?: boolean
    updated_at?: boolean
    applications?: boolean | resumes$applicationsArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | ResumesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resumes"]>

  export type resumesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    title?: boolean
    file_url?: boolean
    is_default?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resumes"]>

  export type resumesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    title?: boolean
    file_url?: boolean
    is_default?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resumes"]>

  export type resumesSelectScalar = {
    id?: boolean
    user_id?: boolean
    title?: boolean
    file_url?: boolean
    is_default?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type resumesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "title" | "file_url" | "is_default" | "created_at" | "updated_at", ExtArgs["result"]["resumes"]>
  export type resumesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applications?: boolean | resumes$applicationsArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | ResumesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type resumesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type resumesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $resumesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "resumes"
    objects: {
      applications: Prisma.$applicationsPayload<ExtArgs>[]
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      title: string
      file_url: string
      is_default: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["resumes"]>
    composites: {}
  }

  type resumesGetPayload<S extends boolean | null | undefined | resumesDefaultArgs> = $Result.GetResult<Prisma.$resumesPayload, S>

  type resumesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<resumesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResumesCountAggregateInputType | true
    }

  export interface resumesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['resumes'], meta: { name: 'resumes' } }
    /**
     * Find zero or one Resumes that matches the filter.
     * @param {resumesFindUniqueArgs} args - Arguments to find a Resumes
     * @example
     * // Get one Resumes
     * const resumes = await prisma.resumes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends resumesFindUniqueArgs>(args: SelectSubset<T, resumesFindUniqueArgs<ExtArgs>>): Prisma__resumesClient<$Result.GetResult<Prisma.$resumesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Resumes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {resumesFindUniqueOrThrowArgs} args - Arguments to find a Resumes
     * @example
     * // Get one Resumes
     * const resumes = await prisma.resumes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends resumesFindUniqueOrThrowArgs>(args: SelectSubset<T, resumesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__resumesClient<$Result.GetResult<Prisma.$resumesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resumes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resumesFindFirstArgs} args - Arguments to find a Resumes
     * @example
     * // Get one Resumes
     * const resumes = await prisma.resumes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends resumesFindFirstArgs>(args?: SelectSubset<T, resumesFindFirstArgs<ExtArgs>>): Prisma__resumesClient<$Result.GetResult<Prisma.$resumesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resumes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resumesFindFirstOrThrowArgs} args - Arguments to find a Resumes
     * @example
     * // Get one Resumes
     * const resumes = await prisma.resumes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends resumesFindFirstOrThrowArgs>(args?: SelectSubset<T, resumesFindFirstOrThrowArgs<ExtArgs>>): Prisma__resumesClient<$Result.GetResult<Prisma.$resumesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Resumes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resumesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Resumes
     * const resumes = await prisma.resumes.findMany()
     * 
     * // Get first 10 Resumes
     * const resumes = await prisma.resumes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resumesWithIdOnly = await prisma.resumes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends resumesFindManyArgs>(args?: SelectSubset<T, resumesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$resumesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Resumes.
     * @param {resumesCreateArgs} args - Arguments to create a Resumes.
     * @example
     * // Create one Resumes
     * const Resumes = await prisma.resumes.create({
     *   data: {
     *     // ... data to create a Resumes
     *   }
     * })
     * 
     */
    create<T extends resumesCreateArgs>(args: SelectSubset<T, resumesCreateArgs<ExtArgs>>): Prisma__resumesClient<$Result.GetResult<Prisma.$resumesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Resumes.
     * @param {resumesCreateManyArgs} args - Arguments to create many Resumes.
     * @example
     * // Create many Resumes
     * const resumes = await prisma.resumes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends resumesCreateManyArgs>(args?: SelectSubset<T, resumesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Resumes and returns the data saved in the database.
     * @param {resumesCreateManyAndReturnArgs} args - Arguments to create many Resumes.
     * @example
     * // Create many Resumes
     * const resumes = await prisma.resumes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Resumes and only return the `id`
     * const resumesWithIdOnly = await prisma.resumes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends resumesCreateManyAndReturnArgs>(args?: SelectSubset<T, resumesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$resumesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Resumes.
     * @param {resumesDeleteArgs} args - Arguments to delete one Resumes.
     * @example
     * // Delete one Resumes
     * const Resumes = await prisma.resumes.delete({
     *   where: {
     *     // ... filter to delete one Resumes
     *   }
     * })
     * 
     */
    delete<T extends resumesDeleteArgs>(args: SelectSubset<T, resumesDeleteArgs<ExtArgs>>): Prisma__resumesClient<$Result.GetResult<Prisma.$resumesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Resumes.
     * @param {resumesUpdateArgs} args - Arguments to update one Resumes.
     * @example
     * // Update one Resumes
     * const resumes = await prisma.resumes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends resumesUpdateArgs>(args: SelectSubset<T, resumesUpdateArgs<ExtArgs>>): Prisma__resumesClient<$Result.GetResult<Prisma.$resumesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Resumes.
     * @param {resumesDeleteManyArgs} args - Arguments to filter Resumes to delete.
     * @example
     * // Delete a few Resumes
     * const { count } = await prisma.resumes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends resumesDeleteManyArgs>(args?: SelectSubset<T, resumesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resumes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resumesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Resumes
     * const resumes = await prisma.resumes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends resumesUpdateManyArgs>(args: SelectSubset<T, resumesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resumes and returns the data updated in the database.
     * @param {resumesUpdateManyAndReturnArgs} args - Arguments to update many Resumes.
     * @example
     * // Update many Resumes
     * const resumes = await prisma.resumes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Resumes and only return the `id`
     * const resumesWithIdOnly = await prisma.resumes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends resumesUpdateManyAndReturnArgs>(args: SelectSubset<T, resumesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$resumesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Resumes.
     * @param {resumesUpsertArgs} args - Arguments to update or create a Resumes.
     * @example
     * // Update or create a Resumes
     * const resumes = await prisma.resumes.upsert({
     *   create: {
     *     // ... data to create a Resumes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Resumes we want to update
     *   }
     * })
     */
    upsert<T extends resumesUpsertArgs>(args: SelectSubset<T, resumesUpsertArgs<ExtArgs>>): Prisma__resumesClient<$Result.GetResult<Prisma.$resumesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Resumes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resumesCountArgs} args - Arguments to filter Resumes to count.
     * @example
     * // Count the number of Resumes
     * const count = await prisma.resumes.count({
     *   where: {
     *     // ... the filter for the Resumes we want to count
     *   }
     * })
    **/
    count<T extends resumesCountArgs>(
      args?: Subset<T, resumesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResumesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Resumes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResumesAggregateArgs>(args: Subset<T, ResumesAggregateArgs>): Prisma.PrismaPromise<GetResumesAggregateType<T>>

    /**
     * Group by Resumes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resumesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends resumesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: resumesGroupByArgs['orderBy'] }
        : { orderBy?: resumesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, resumesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResumesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the resumes model
   */
  readonly fields: resumesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for resumes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__resumesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    applications<T extends resumes$applicationsArgs<ExtArgs> = {}>(args?: Subset<T, resumes$applicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$applicationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the resumes model
   */
  interface resumesFieldRefs {
    readonly id: FieldRef<"resumes", 'Int'>
    readonly user_id: FieldRef<"resumes", 'Int'>
    readonly title: FieldRef<"resumes", 'String'>
    readonly file_url: FieldRef<"resumes", 'String'>
    readonly is_default: FieldRef<"resumes", 'Boolean'>
    readonly created_at: FieldRef<"resumes", 'DateTime'>
    readonly updated_at: FieldRef<"resumes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * resumes findUnique
   */
  export type resumesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resumes
     */
    select?: resumesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resumes
     */
    omit?: resumesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resumesInclude<ExtArgs> | null
    /**
     * Filter, which resumes to fetch.
     */
    where: resumesWhereUniqueInput
  }

  /**
   * resumes findUniqueOrThrow
   */
  export type resumesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resumes
     */
    select?: resumesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resumes
     */
    omit?: resumesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resumesInclude<ExtArgs> | null
    /**
     * Filter, which resumes to fetch.
     */
    where: resumesWhereUniqueInput
  }

  /**
   * resumes findFirst
   */
  export type resumesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resumes
     */
    select?: resumesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resumes
     */
    omit?: resumesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resumesInclude<ExtArgs> | null
    /**
     * Filter, which resumes to fetch.
     */
    where?: resumesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of resumes to fetch.
     */
    orderBy?: resumesOrderByWithRelationInput | resumesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for resumes.
     */
    cursor?: resumesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` resumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` resumes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of resumes.
     */
    distinct?: ResumesScalarFieldEnum | ResumesScalarFieldEnum[]
  }

  /**
   * resumes findFirstOrThrow
   */
  export type resumesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resumes
     */
    select?: resumesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resumes
     */
    omit?: resumesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resumesInclude<ExtArgs> | null
    /**
     * Filter, which resumes to fetch.
     */
    where?: resumesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of resumes to fetch.
     */
    orderBy?: resumesOrderByWithRelationInput | resumesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for resumes.
     */
    cursor?: resumesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` resumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` resumes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of resumes.
     */
    distinct?: ResumesScalarFieldEnum | ResumesScalarFieldEnum[]
  }

  /**
   * resumes findMany
   */
  export type resumesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resumes
     */
    select?: resumesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resumes
     */
    omit?: resumesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resumesInclude<ExtArgs> | null
    /**
     * Filter, which resumes to fetch.
     */
    where?: resumesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of resumes to fetch.
     */
    orderBy?: resumesOrderByWithRelationInput | resumesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing resumes.
     */
    cursor?: resumesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` resumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` resumes.
     */
    skip?: number
    distinct?: ResumesScalarFieldEnum | ResumesScalarFieldEnum[]
  }

  /**
   * resumes create
   */
  export type resumesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resumes
     */
    select?: resumesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resumes
     */
    omit?: resumesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resumesInclude<ExtArgs> | null
    /**
     * The data needed to create a resumes.
     */
    data: XOR<resumesCreateInput, resumesUncheckedCreateInput>
  }

  /**
   * resumes createMany
   */
  export type resumesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many resumes.
     */
    data: resumesCreateManyInput | resumesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * resumes createManyAndReturn
   */
  export type resumesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resumes
     */
    select?: resumesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the resumes
     */
    omit?: resumesOmit<ExtArgs> | null
    /**
     * The data used to create many resumes.
     */
    data: resumesCreateManyInput | resumesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resumesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * resumes update
   */
  export type resumesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resumes
     */
    select?: resumesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resumes
     */
    omit?: resumesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resumesInclude<ExtArgs> | null
    /**
     * The data needed to update a resumes.
     */
    data: XOR<resumesUpdateInput, resumesUncheckedUpdateInput>
    /**
     * Choose, which resumes to update.
     */
    where: resumesWhereUniqueInput
  }

  /**
   * resumes updateMany
   */
  export type resumesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update resumes.
     */
    data: XOR<resumesUpdateManyMutationInput, resumesUncheckedUpdateManyInput>
    /**
     * Filter which resumes to update
     */
    where?: resumesWhereInput
    /**
     * Limit how many resumes to update.
     */
    limit?: number
  }

  /**
   * resumes updateManyAndReturn
   */
  export type resumesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resumes
     */
    select?: resumesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the resumes
     */
    omit?: resumesOmit<ExtArgs> | null
    /**
     * The data used to update resumes.
     */
    data: XOR<resumesUpdateManyMutationInput, resumesUncheckedUpdateManyInput>
    /**
     * Filter which resumes to update
     */
    where?: resumesWhereInput
    /**
     * Limit how many resumes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resumesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * resumes upsert
   */
  export type resumesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resumes
     */
    select?: resumesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resumes
     */
    omit?: resumesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resumesInclude<ExtArgs> | null
    /**
     * The filter to search for the resumes to update in case it exists.
     */
    where: resumesWhereUniqueInput
    /**
     * In case the resumes found by the `where` argument doesn't exist, create a new resumes with this data.
     */
    create: XOR<resumesCreateInput, resumesUncheckedCreateInput>
    /**
     * In case the resumes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<resumesUpdateInput, resumesUncheckedUpdateInput>
  }

  /**
   * resumes delete
   */
  export type resumesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resumes
     */
    select?: resumesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resumes
     */
    omit?: resumesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resumesInclude<ExtArgs> | null
    /**
     * Filter which resumes to delete.
     */
    where: resumesWhereUniqueInput
  }

  /**
   * resumes deleteMany
   */
  export type resumesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which resumes to delete
     */
    where?: resumesWhereInput
    /**
     * Limit how many resumes to delete.
     */
    limit?: number
  }

  /**
   * resumes.applications
   */
  export type resumes$applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applications
     */
    select?: applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applications
     */
    omit?: applicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationsInclude<ExtArgs> | null
    where?: applicationsWhereInput
    orderBy?: applicationsOrderByWithRelationInput | applicationsOrderByWithRelationInput[]
    cursor?: applicationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApplicationsScalarFieldEnum | ApplicationsScalarFieldEnum[]
  }

  /**
   * resumes without action
   */
  export type resumesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resumes
     */
    select?: resumesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resumes
     */
    omit?: resumesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resumesInclude<ExtArgs> | null
  }


  /**
   * Model educations
   */

  export type AggregateEducations = {
    _count: EducationsCountAggregateOutputType | null
    _avg: EducationsAvgAggregateOutputType | null
    _sum: EducationsSumAggregateOutputType | null
    _min: EducationsMinAggregateOutputType | null
    _max: EducationsMaxAggregateOutputType | null
  }

  export type EducationsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type EducationsSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type EducationsMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    institution: string | null
    degree: string | null
    field_of_study: string | null
    start_date: Date | null
    end_date: Date | null
    grade: string | null
    description: string | null
    is_foreign_education: boolean | null
    country: string | null
  }

  export type EducationsMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    institution: string | null
    degree: string | null
    field_of_study: string | null
    start_date: Date | null
    end_date: Date | null
    grade: string | null
    description: string | null
    is_foreign_education: boolean | null
    country: string | null
  }

  export type EducationsCountAggregateOutputType = {
    id: number
    user_id: number
    institution: number
    degree: number
    field_of_study: number
    start_date: number
    end_date: number
    grade: number
    description: number
    is_foreign_education: number
    country: number
    _all: number
  }


  export type EducationsAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type EducationsSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type EducationsMinAggregateInputType = {
    id?: true
    user_id?: true
    institution?: true
    degree?: true
    field_of_study?: true
    start_date?: true
    end_date?: true
    grade?: true
    description?: true
    is_foreign_education?: true
    country?: true
  }

  export type EducationsMaxAggregateInputType = {
    id?: true
    user_id?: true
    institution?: true
    degree?: true
    field_of_study?: true
    start_date?: true
    end_date?: true
    grade?: true
    description?: true
    is_foreign_education?: true
    country?: true
  }

  export type EducationsCountAggregateInputType = {
    id?: true
    user_id?: true
    institution?: true
    degree?: true
    field_of_study?: true
    start_date?: true
    end_date?: true
    grade?: true
    description?: true
    is_foreign_education?: true
    country?: true
    _all?: true
  }

  export type EducationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which educations to aggregate.
     */
    where?: educationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of educations to fetch.
     */
    orderBy?: educationsOrderByWithRelationInput | educationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: educationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` educations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` educations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned educations
    **/
    _count?: true | EducationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EducationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EducationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EducationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EducationsMaxAggregateInputType
  }

  export type GetEducationsAggregateType<T extends EducationsAggregateArgs> = {
        [P in keyof T & keyof AggregateEducations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEducations[P]>
      : GetScalarType<T[P], AggregateEducations[P]>
  }




  export type educationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: educationsWhereInput
    orderBy?: educationsOrderByWithAggregationInput | educationsOrderByWithAggregationInput[]
    by: EducationsScalarFieldEnum[] | EducationsScalarFieldEnum
    having?: educationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EducationsCountAggregateInputType | true
    _avg?: EducationsAvgAggregateInputType
    _sum?: EducationsSumAggregateInputType
    _min?: EducationsMinAggregateInputType
    _max?: EducationsMaxAggregateInputType
  }

  export type EducationsGroupByOutputType = {
    id: number
    user_id: number
    institution: string
    degree: string
    field_of_study: string
    start_date: Date
    end_date: Date
    grade: string
    description: string
    is_foreign_education: boolean
    country: string
    _count: EducationsCountAggregateOutputType | null
    _avg: EducationsAvgAggregateOutputType | null
    _sum: EducationsSumAggregateOutputType | null
    _min: EducationsMinAggregateOutputType | null
    _max: EducationsMaxAggregateOutputType | null
  }

  type GetEducationsGroupByPayload<T extends educationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EducationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EducationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EducationsGroupByOutputType[P]>
            : GetScalarType<T[P], EducationsGroupByOutputType[P]>
        }
      >
    >


  export type educationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    institution?: boolean
    degree?: boolean
    field_of_study?: boolean
    start_date?: boolean
    end_date?: boolean
    grade?: boolean
    description?: boolean
    is_foreign_education?: boolean
    country?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["educations"]>

  export type educationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    institution?: boolean
    degree?: boolean
    field_of_study?: boolean
    start_date?: boolean
    end_date?: boolean
    grade?: boolean
    description?: boolean
    is_foreign_education?: boolean
    country?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["educations"]>

  export type educationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    institution?: boolean
    degree?: boolean
    field_of_study?: boolean
    start_date?: boolean
    end_date?: boolean
    grade?: boolean
    description?: boolean
    is_foreign_education?: boolean
    country?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["educations"]>

  export type educationsSelectScalar = {
    id?: boolean
    user_id?: boolean
    institution?: boolean
    degree?: boolean
    field_of_study?: boolean
    start_date?: boolean
    end_date?: boolean
    grade?: boolean
    description?: boolean
    is_foreign_education?: boolean
    country?: boolean
  }

  export type educationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "institution" | "degree" | "field_of_study" | "start_date" | "end_date" | "grade" | "description" | "is_foreign_education" | "country", ExtArgs["result"]["educations"]>
  export type educationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type educationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type educationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $educationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "educations"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      institution: string
      degree: string
      field_of_study: string
      start_date: Date
      end_date: Date
      grade: string
      description: string
      is_foreign_education: boolean
      country: string
    }, ExtArgs["result"]["educations"]>
    composites: {}
  }

  type educationsGetPayload<S extends boolean | null | undefined | educationsDefaultArgs> = $Result.GetResult<Prisma.$educationsPayload, S>

  type educationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<educationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EducationsCountAggregateInputType | true
    }

  export interface educationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['educations'], meta: { name: 'educations' } }
    /**
     * Find zero or one Educations that matches the filter.
     * @param {educationsFindUniqueArgs} args - Arguments to find a Educations
     * @example
     * // Get one Educations
     * const educations = await prisma.educations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends educationsFindUniqueArgs>(args: SelectSubset<T, educationsFindUniqueArgs<ExtArgs>>): Prisma__educationsClient<$Result.GetResult<Prisma.$educationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Educations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {educationsFindUniqueOrThrowArgs} args - Arguments to find a Educations
     * @example
     * // Get one Educations
     * const educations = await prisma.educations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends educationsFindUniqueOrThrowArgs>(args: SelectSubset<T, educationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__educationsClient<$Result.GetResult<Prisma.$educationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Educations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {educationsFindFirstArgs} args - Arguments to find a Educations
     * @example
     * // Get one Educations
     * const educations = await prisma.educations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends educationsFindFirstArgs>(args?: SelectSubset<T, educationsFindFirstArgs<ExtArgs>>): Prisma__educationsClient<$Result.GetResult<Prisma.$educationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Educations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {educationsFindFirstOrThrowArgs} args - Arguments to find a Educations
     * @example
     * // Get one Educations
     * const educations = await prisma.educations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends educationsFindFirstOrThrowArgs>(args?: SelectSubset<T, educationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__educationsClient<$Result.GetResult<Prisma.$educationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Educations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {educationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Educations
     * const educations = await prisma.educations.findMany()
     * 
     * // Get first 10 Educations
     * const educations = await prisma.educations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const educationsWithIdOnly = await prisma.educations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends educationsFindManyArgs>(args?: SelectSubset<T, educationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$educationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Educations.
     * @param {educationsCreateArgs} args - Arguments to create a Educations.
     * @example
     * // Create one Educations
     * const Educations = await prisma.educations.create({
     *   data: {
     *     // ... data to create a Educations
     *   }
     * })
     * 
     */
    create<T extends educationsCreateArgs>(args: SelectSubset<T, educationsCreateArgs<ExtArgs>>): Prisma__educationsClient<$Result.GetResult<Prisma.$educationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Educations.
     * @param {educationsCreateManyArgs} args - Arguments to create many Educations.
     * @example
     * // Create many Educations
     * const educations = await prisma.educations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends educationsCreateManyArgs>(args?: SelectSubset<T, educationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Educations and returns the data saved in the database.
     * @param {educationsCreateManyAndReturnArgs} args - Arguments to create many Educations.
     * @example
     * // Create many Educations
     * const educations = await prisma.educations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Educations and only return the `id`
     * const educationsWithIdOnly = await prisma.educations.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends educationsCreateManyAndReturnArgs>(args?: SelectSubset<T, educationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$educationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Educations.
     * @param {educationsDeleteArgs} args - Arguments to delete one Educations.
     * @example
     * // Delete one Educations
     * const Educations = await prisma.educations.delete({
     *   where: {
     *     // ... filter to delete one Educations
     *   }
     * })
     * 
     */
    delete<T extends educationsDeleteArgs>(args: SelectSubset<T, educationsDeleteArgs<ExtArgs>>): Prisma__educationsClient<$Result.GetResult<Prisma.$educationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Educations.
     * @param {educationsUpdateArgs} args - Arguments to update one Educations.
     * @example
     * // Update one Educations
     * const educations = await prisma.educations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends educationsUpdateArgs>(args: SelectSubset<T, educationsUpdateArgs<ExtArgs>>): Prisma__educationsClient<$Result.GetResult<Prisma.$educationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Educations.
     * @param {educationsDeleteManyArgs} args - Arguments to filter Educations to delete.
     * @example
     * // Delete a few Educations
     * const { count } = await prisma.educations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends educationsDeleteManyArgs>(args?: SelectSubset<T, educationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Educations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {educationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Educations
     * const educations = await prisma.educations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends educationsUpdateManyArgs>(args: SelectSubset<T, educationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Educations and returns the data updated in the database.
     * @param {educationsUpdateManyAndReturnArgs} args - Arguments to update many Educations.
     * @example
     * // Update many Educations
     * const educations = await prisma.educations.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Educations and only return the `id`
     * const educationsWithIdOnly = await prisma.educations.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends educationsUpdateManyAndReturnArgs>(args: SelectSubset<T, educationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$educationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Educations.
     * @param {educationsUpsertArgs} args - Arguments to update or create a Educations.
     * @example
     * // Update or create a Educations
     * const educations = await prisma.educations.upsert({
     *   create: {
     *     // ... data to create a Educations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Educations we want to update
     *   }
     * })
     */
    upsert<T extends educationsUpsertArgs>(args: SelectSubset<T, educationsUpsertArgs<ExtArgs>>): Prisma__educationsClient<$Result.GetResult<Prisma.$educationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Educations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {educationsCountArgs} args - Arguments to filter Educations to count.
     * @example
     * // Count the number of Educations
     * const count = await prisma.educations.count({
     *   where: {
     *     // ... the filter for the Educations we want to count
     *   }
     * })
    **/
    count<T extends educationsCountArgs>(
      args?: Subset<T, educationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EducationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Educations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EducationsAggregateArgs>(args: Subset<T, EducationsAggregateArgs>): Prisma.PrismaPromise<GetEducationsAggregateType<T>>

    /**
     * Group by Educations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {educationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends educationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: educationsGroupByArgs['orderBy'] }
        : { orderBy?: educationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, educationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEducationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the educations model
   */
  readonly fields: educationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for educations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__educationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the educations model
   */
  interface educationsFieldRefs {
    readonly id: FieldRef<"educations", 'Int'>
    readonly user_id: FieldRef<"educations", 'Int'>
    readonly institution: FieldRef<"educations", 'String'>
    readonly degree: FieldRef<"educations", 'String'>
    readonly field_of_study: FieldRef<"educations", 'String'>
    readonly start_date: FieldRef<"educations", 'DateTime'>
    readonly end_date: FieldRef<"educations", 'DateTime'>
    readonly grade: FieldRef<"educations", 'String'>
    readonly description: FieldRef<"educations", 'String'>
    readonly is_foreign_education: FieldRef<"educations", 'Boolean'>
    readonly country: FieldRef<"educations", 'String'>
  }
    

  // Custom InputTypes
  /**
   * educations findUnique
   */
  export type educationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the educations
     */
    select?: educationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the educations
     */
    omit?: educationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: educationsInclude<ExtArgs> | null
    /**
     * Filter, which educations to fetch.
     */
    where: educationsWhereUniqueInput
  }

  /**
   * educations findUniqueOrThrow
   */
  export type educationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the educations
     */
    select?: educationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the educations
     */
    omit?: educationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: educationsInclude<ExtArgs> | null
    /**
     * Filter, which educations to fetch.
     */
    where: educationsWhereUniqueInput
  }

  /**
   * educations findFirst
   */
  export type educationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the educations
     */
    select?: educationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the educations
     */
    omit?: educationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: educationsInclude<ExtArgs> | null
    /**
     * Filter, which educations to fetch.
     */
    where?: educationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of educations to fetch.
     */
    orderBy?: educationsOrderByWithRelationInput | educationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for educations.
     */
    cursor?: educationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` educations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` educations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of educations.
     */
    distinct?: EducationsScalarFieldEnum | EducationsScalarFieldEnum[]
  }

  /**
   * educations findFirstOrThrow
   */
  export type educationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the educations
     */
    select?: educationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the educations
     */
    omit?: educationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: educationsInclude<ExtArgs> | null
    /**
     * Filter, which educations to fetch.
     */
    where?: educationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of educations to fetch.
     */
    orderBy?: educationsOrderByWithRelationInput | educationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for educations.
     */
    cursor?: educationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` educations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` educations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of educations.
     */
    distinct?: EducationsScalarFieldEnum | EducationsScalarFieldEnum[]
  }

  /**
   * educations findMany
   */
  export type educationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the educations
     */
    select?: educationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the educations
     */
    omit?: educationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: educationsInclude<ExtArgs> | null
    /**
     * Filter, which educations to fetch.
     */
    where?: educationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of educations to fetch.
     */
    orderBy?: educationsOrderByWithRelationInput | educationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing educations.
     */
    cursor?: educationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` educations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` educations.
     */
    skip?: number
    distinct?: EducationsScalarFieldEnum | EducationsScalarFieldEnum[]
  }

  /**
   * educations create
   */
  export type educationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the educations
     */
    select?: educationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the educations
     */
    omit?: educationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: educationsInclude<ExtArgs> | null
    /**
     * The data needed to create a educations.
     */
    data: XOR<educationsCreateInput, educationsUncheckedCreateInput>
  }

  /**
   * educations createMany
   */
  export type educationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many educations.
     */
    data: educationsCreateManyInput | educationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * educations createManyAndReturn
   */
  export type educationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the educations
     */
    select?: educationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the educations
     */
    omit?: educationsOmit<ExtArgs> | null
    /**
     * The data used to create many educations.
     */
    data: educationsCreateManyInput | educationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: educationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * educations update
   */
  export type educationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the educations
     */
    select?: educationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the educations
     */
    omit?: educationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: educationsInclude<ExtArgs> | null
    /**
     * The data needed to update a educations.
     */
    data: XOR<educationsUpdateInput, educationsUncheckedUpdateInput>
    /**
     * Choose, which educations to update.
     */
    where: educationsWhereUniqueInput
  }

  /**
   * educations updateMany
   */
  export type educationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update educations.
     */
    data: XOR<educationsUpdateManyMutationInput, educationsUncheckedUpdateManyInput>
    /**
     * Filter which educations to update
     */
    where?: educationsWhereInput
    /**
     * Limit how many educations to update.
     */
    limit?: number
  }

  /**
   * educations updateManyAndReturn
   */
  export type educationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the educations
     */
    select?: educationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the educations
     */
    omit?: educationsOmit<ExtArgs> | null
    /**
     * The data used to update educations.
     */
    data: XOR<educationsUpdateManyMutationInput, educationsUncheckedUpdateManyInput>
    /**
     * Filter which educations to update
     */
    where?: educationsWhereInput
    /**
     * Limit how many educations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: educationsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * educations upsert
   */
  export type educationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the educations
     */
    select?: educationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the educations
     */
    omit?: educationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: educationsInclude<ExtArgs> | null
    /**
     * The filter to search for the educations to update in case it exists.
     */
    where: educationsWhereUniqueInput
    /**
     * In case the educations found by the `where` argument doesn't exist, create a new educations with this data.
     */
    create: XOR<educationsCreateInput, educationsUncheckedCreateInput>
    /**
     * In case the educations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<educationsUpdateInput, educationsUncheckedUpdateInput>
  }

  /**
   * educations delete
   */
  export type educationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the educations
     */
    select?: educationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the educations
     */
    omit?: educationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: educationsInclude<ExtArgs> | null
    /**
     * Filter which educations to delete.
     */
    where: educationsWhereUniqueInput
  }

  /**
   * educations deleteMany
   */
  export type educationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which educations to delete
     */
    where?: educationsWhereInput
    /**
     * Limit how many educations to delete.
     */
    limit?: number
  }

  /**
   * educations without action
   */
  export type educationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the educations
     */
    select?: educationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the educations
     */
    omit?: educationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: educationsInclude<ExtArgs> | null
  }


  /**
   * Model work_experiences
   */

  export type AggregateWork_experiences = {
    _count: Work_experiencesCountAggregateOutputType | null
    _avg: Work_experiencesAvgAggregateOutputType | null
    _sum: Work_experiencesSumAggregateOutputType | null
    _min: Work_experiencesMinAggregateOutputType | null
    _max: Work_experiencesMaxAggregateOutputType | null
  }

  export type Work_experiencesAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Work_experiencesSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Work_experiencesMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    company_name: string | null
    position: string | null
    location: string | null
    country: string | null
    start_date: Date | null
    end_date: Date | null
    is_current_job: boolean | null
    description: string | null
    is_foregin_experience: boolean | null
  }

  export type Work_experiencesMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    company_name: string | null
    position: string | null
    location: string | null
    country: string | null
    start_date: Date | null
    end_date: Date | null
    is_current_job: boolean | null
    description: string | null
    is_foregin_experience: boolean | null
  }

  export type Work_experiencesCountAggregateOutputType = {
    id: number
    user_id: number
    company_name: number
    position: number
    location: number
    country: number
    start_date: number
    end_date: number
    is_current_job: number
    description: number
    is_foregin_experience: number
    _all: number
  }


  export type Work_experiencesAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Work_experiencesSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Work_experiencesMinAggregateInputType = {
    id?: true
    user_id?: true
    company_name?: true
    position?: true
    location?: true
    country?: true
    start_date?: true
    end_date?: true
    is_current_job?: true
    description?: true
    is_foregin_experience?: true
  }

  export type Work_experiencesMaxAggregateInputType = {
    id?: true
    user_id?: true
    company_name?: true
    position?: true
    location?: true
    country?: true
    start_date?: true
    end_date?: true
    is_current_job?: true
    description?: true
    is_foregin_experience?: true
  }

  export type Work_experiencesCountAggregateInputType = {
    id?: true
    user_id?: true
    company_name?: true
    position?: true
    location?: true
    country?: true
    start_date?: true
    end_date?: true
    is_current_job?: true
    description?: true
    is_foregin_experience?: true
    _all?: true
  }

  export type Work_experiencesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which work_experiences to aggregate.
     */
    where?: work_experiencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of work_experiences to fetch.
     */
    orderBy?: work_experiencesOrderByWithRelationInput | work_experiencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: work_experiencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` work_experiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` work_experiences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned work_experiences
    **/
    _count?: true | Work_experiencesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Work_experiencesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Work_experiencesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Work_experiencesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Work_experiencesMaxAggregateInputType
  }

  export type GetWork_experiencesAggregateType<T extends Work_experiencesAggregateArgs> = {
        [P in keyof T & keyof AggregateWork_experiences]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWork_experiences[P]>
      : GetScalarType<T[P], AggregateWork_experiences[P]>
  }




  export type work_experiencesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: work_experiencesWhereInput
    orderBy?: work_experiencesOrderByWithAggregationInput | work_experiencesOrderByWithAggregationInput[]
    by: Work_experiencesScalarFieldEnum[] | Work_experiencesScalarFieldEnum
    having?: work_experiencesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Work_experiencesCountAggregateInputType | true
    _avg?: Work_experiencesAvgAggregateInputType
    _sum?: Work_experiencesSumAggregateInputType
    _min?: Work_experiencesMinAggregateInputType
    _max?: Work_experiencesMaxAggregateInputType
  }

  export type Work_experiencesGroupByOutputType = {
    id: number
    user_id: number
    company_name: string
    position: string
    location: string
    country: string
    start_date: Date
    end_date: Date
    is_current_job: boolean
    description: string
    is_foregin_experience: boolean
    _count: Work_experiencesCountAggregateOutputType | null
    _avg: Work_experiencesAvgAggregateOutputType | null
    _sum: Work_experiencesSumAggregateOutputType | null
    _min: Work_experiencesMinAggregateOutputType | null
    _max: Work_experiencesMaxAggregateOutputType | null
  }

  type GetWork_experiencesGroupByPayload<T extends work_experiencesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Work_experiencesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Work_experiencesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Work_experiencesGroupByOutputType[P]>
            : GetScalarType<T[P], Work_experiencesGroupByOutputType[P]>
        }
      >
    >


  export type work_experiencesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    company_name?: boolean
    position?: boolean
    location?: boolean
    country?: boolean
    start_date?: boolean
    end_date?: boolean
    is_current_job?: boolean
    description?: boolean
    is_foregin_experience?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["work_experiences"]>

  export type work_experiencesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    company_name?: boolean
    position?: boolean
    location?: boolean
    country?: boolean
    start_date?: boolean
    end_date?: boolean
    is_current_job?: boolean
    description?: boolean
    is_foregin_experience?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["work_experiences"]>

  export type work_experiencesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    company_name?: boolean
    position?: boolean
    location?: boolean
    country?: boolean
    start_date?: boolean
    end_date?: boolean
    is_current_job?: boolean
    description?: boolean
    is_foregin_experience?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["work_experiences"]>

  export type work_experiencesSelectScalar = {
    id?: boolean
    user_id?: boolean
    company_name?: boolean
    position?: boolean
    location?: boolean
    country?: boolean
    start_date?: boolean
    end_date?: boolean
    is_current_job?: boolean
    description?: boolean
    is_foregin_experience?: boolean
  }

  export type work_experiencesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "company_name" | "position" | "location" | "country" | "start_date" | "end_date" | "is_current_job" | "description" | "is_foregin_experience", ExtArgs["result"]["work_experiences"]>
  export type work_experiencesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type work_experiencesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type work_experiencesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $work_experiencesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "work_experiences"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      company_name: string
      position: string
      location: string
      country: string
      start_date: Date
      end_date: Date
      is_current_job: boolean
      description: string
      is_foregin_experience: boolean
    }, ExtArgs["result"]["work_experiences"]>
    composites: {}
  }

  type work_experiencesGetPayload<S extends boolean | null | undefined | work_experiencesDefaultArgs> = $Result.GetResult<Prisma.$work_experiencesPayload, S>

  type work_experiencesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<work_experiencesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Work_experiencesCountAggregateInputType | true
    }

  export interface work_experiencesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['work_experiences'], meta: { name: 'work_experiences' } }
    /**
     * Find zero or one Work_experiences that matches the filter.
     * @param {work_experiencesFindUniqueArgs} args - Arguments to find a Work_experiences
     * @example
     * // Get one Work_experiences
     * const work_experiences = await prisma.work_experiences.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends work_experiencesFindUniqueArgs>(args: SelectSubset<T, work_experiencesFindUniqueArgs<ExtArgs>>): Prisma__work_experiencesClient<$Result.GetResult<Prisma.$work_experiencesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Work_experiences that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {work_experiencesFindUniqueOrThrowArgs} args - Arguments to find a Work_experiences
     * @example
     * // Get one Work_experiences
     * const work_experiences = await prisma.work_experiences.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends work_experiencesFindUniqueOrThrowArgs>(args: SelectSubset<T, work_experiencesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__work_experiencesClient<$Result.GetResult<Prisma.$work_experiencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Work_experiences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {work_experiencesFindFirstArgs} args - Arguments to find a Work_experiences
     * @example
     * // Get one Work_experiences
     * const work_experiences = await prisma.work_experiences.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends work_experiencesFindFirstArgs>(args?: SelectSubset<T, work_experiencesFindFirstArgs<ExtArgs>>): Prisma__work_experiencesClient<$Result.GetResult<Prisma.$work_experiencesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Work_experiences that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {work_experiencesFindFirstOrThrowArgs} args - Arguments to find a Work_experiences
     * @example
     * // Get one Work_experiences
     * const work_experiences = await prisma.work_experiences.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends work_experiencesFindFirstOrThrowArgs>(args?: SelectSubset<T, work_experiencesFindFirstOrThrowArgs<ExtArgs>>): Prisma__work_experiencesClient<$Result.GetResult<Prisma.$work_experiencesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Work_experiences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {work_experiencesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Work_experiences
     * const work_experiences = await prisma.work_experiences.findMany()
     * 
     * // Get first 10 Work_experiences
     * const work_experiences = await prisma.work_experiences.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const work_experiencesWithIdOnly = await prisma.work_experiences.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends work_experiencesFindManyArgs>(args?: SelectSubset<T, work_experiencesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$work_experiencesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Work_experiences.
     * @param {work_experiencesCreateArgs} args - Arguments to create a Work_experiences.
     * @example
     * // Create one Work_experiences
     * const Work_experiences = await prisma.work_experiences.create({
     *   data: {
     *     // ... data to create a Work_experiences
     *   }
     * })
     * 
     */
    create<T extends work_experiencesCreateArgs>(args: SelectSubset<T, work_experiencesCreateArgs<ExtArgs>>): Prisma__work_experiencesClient<$Result.GetResult<Prisma.$work_experiencesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Work_experiences.
     * @param {work_experiencesCreateManyArgs} args - Arguments to create many Work_experiences.
     * @example
     * // Create many Work_experiences
     * const work_experiences = await prisma.work_experiences.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends work_experiencesCreateManyArgs>(args?: SelectSubset<T, work_experiencesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Work_experiences and returns the data saved in the database.
     * @param {work_experiencesCreateManyAndReturnArgs} args - Arguments to create many Work_experiences.
     * @example
     * // Create many Work_experiences
     * const work_experiences = await prisma.work_experiences.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Work_experiences and only return the `id`
     * const work_experiencesWithIdOnly = await prisma.work_experiences.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends work_experiencesCreateManyAndReturnArgs>(args?: SelectSubset<T, work_experiencesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$work_experiencesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Work_experiences.
     * @param {work_experiencesDeleteArgs} args - Arguments to delete one Work_experiences.
     * @example
     * // Delete one Work_experiences
     * const Work_experiences = await prisma.work_experiences.delete({
     *   where: {
     *     // ... filter to delete one Work_experiences
     *   }
     * })
     * 
     */
    delete<T extends work_experiencesDeleteArgs>(args: SelectSubset<T, work_experiencesDeleteArgs<ExtArgs>>): Prisma__work_experiencesClient<$Result.GetResult<Prisma.$work_experiencesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Work_experiences.
     * @param {work_experiencesUpdateArgs} args - Arguments to update one Work_experiences.
     * @example
     * // Update one Work_experiences
     * const work_experiences = await prisma.work_experiences.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends work_experiencesUpdateArgs>(args: SelectSubset<T, work_experiencesUpdateArgs<ExtArgs>>): Prisma__work_experiencesClient<$Result.GetResult<Prisma.$work_experiencesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Work_experiences.
     * @param {work_experiencesDeleteManyArgs} args - Arguments to filter Work_experiences to delete.
     * @example
     * // Delete a few Work_experiences
     * const { count } = await prisma.work_experiences.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends work_experiencesDeleteManyArgs>(args?: SelectSubset<T, work_experiencesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Work_experiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {work_experiencesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Work_experiences
     * const work_experiences = await prisma.work_experiences.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends work_experiencesUpdateManyArgs>(args: SelectSubset<T, work_experiencesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Work_experiences and returns the data updated in the database.
     * @param {work_experiencesUpdateManyAndReturnArgs} args - Arguments to update many Work_experiences.
     * @example
     * // Update many Work_experiences
     * const work_experiences = await prisma.work_experiences.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Work_experiences and only return the `id`
     * const work_experiencesWithIdOnly = await prisma.work_experiences.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends work_experiencesUpdateManyAndReturnArgs>(args: SelectSubset<T, work_experiencesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$work_experiencesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Work_experiences.
     * @param {work_experiencesUpsertArgs} args - Arguments to update or create a Work_experiences.
     * @example
     * // Update or create a Work_experiences
     * const work_experiences = await prisma.work_experiences.upsert({
     *   create: {
     *     // ... data to create a Work_experiences
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Work_experiences we want to update
     *   }
     * })
     */
    upsert<T extends work_experiencesUpsertArgs>(args: SelectSubset<T, work_experiencesUpsertArgs<ExtArgs>>): Prisma__work_experiencesClient<$Result.GetResult<Prisma.$work_experiencesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Work_experiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {work_experiencesCountArgs} args - Arguments to filter Work_experiences to count.
     * @example
     * // Count the number of Work_experiences
     * const count = await prisma.work_experiences.count({
     *   where: {
     *     // ... the filter for the Work_experiences we want to count
     *   }
     * })
    **/
    count<T extends work_experiencesCountArgs>(
      args?: Subset<T, work_experiencesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Work_experiencesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Work_experiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Work_experiencesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Work_experiencesAggregateArgs>(args: Subset<T, Work_experiencesAggregateArgs>): Prisma.PrismaPromise<GetWork_experiencesAggregateType<T>>

    /**
     * Group by Work_experiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {work_experiencesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends work_experiencesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: work_experiencesGroupByArgs['orderBy'] }
        : { orderBy?: work_experiencesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, work_experiencesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWork_experiencesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the work_experiences model
   */
  readonly fields: work_experiencesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for work_experiences.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__work_experiencesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the work_experiences model
   */
  interface work_experiencesFieldRefs {
    readonly id: FieldRef<"work_experiences", 'Int'>
    readonly user_id: FieldRef<"work_experiences", 'Int'>
    readonly company_name: FieldRef<"work_experiences", 'String'>
    readonly position: FieldRef<"work_experiences", 'String'>
    readonly location: FieldRef<"work_experiences", 'String'>
    readonly country: FieldRef<"work_experiences", 'String'>
    readonly start_date: FieldRef<"work_experiences", 'DateTime'>
    readonly end_date: FieldRef<"work_experiences", 'DateTime'>
    readonly is_current_job: FieldRef<"work_experiences", 'Boolean'>
    readonly description: FieldRef<"work_experiences", 'String'>
    readonly is_foregin_experience: FieldRef<"work_experiences", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * work_experiences findUnique
   */
  export type work_experiencesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_experiences
     */
    select?: work_experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_experiences
     */
    omit?: work_experiencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_experiencesInclude<ExtArgs> | null
    /**
     * Filter, which work_experiences to fetch.
     */
    where: work_experiencesWhereUniqueInput
  }

  /**
   * work_experiences findUniqueOrThrow
   */
  export type work_experiencesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_experiences
     */
    select?: work_experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_experiences
     */
    omit?: work_experiencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_experiencesInclude<ExtArgs> | null
    /**
     * Filter, which work_experiences to fetch.
     */
    where: work_experiencesWhereUniqueInput
  }

  /**
   * work_experiences findFirst
   */
  export type work_experiencesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_experiences
     */
    select?: work_experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_experiences
     */
    omit?: work_experiencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_experiencesInclude<ExtArgs> | null
    /**
     * Filter, which work_experiences to fetch.
     */
    where?: work_experiencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of work_experiences to fetch.
     */
    orderBy?: work_experiencesOrderByWithRelationInput | work_experiencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for work_experiences.
     */
    cursor?: work_experiencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` work_experiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` work_experiences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of work_experiences.
     */
    distinct?: Work_experiencesScalarFieldEnum | Work_experiencesScalarFieldEnum[]
  }

  /**
   * work_experiences findFirstOrThrow
   */
  export type work_experiencesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_experiences
     */
    select?: work_experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_experiences
     */
    omit?: work_experiencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_experiencesInclude<ExtArgs> | null
    /**
     * Filter, which work_experiences to fetch.
     */
    where?: work_experiencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of work_experiences to fetch.
     */
    orderBy?: work_experiencesOrderByWithRelationInput | work_experiencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for work_experiences.
     */
    cursor?: work_experiencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` work_experiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` work_experiences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of work_experiences.
     */
    distinct?: Work_experiencesScalarFieldEnum | Work_experiencesScalarFieldEnum[]
  }

  /**
   * work_experiences findMany
   */
  export type work_experiencesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_experiences
     */
    select?: work_experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_experiences
     */
    omit?: work_experiencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_experiencesInclude<ExtArgs> | null
    /**
     * Filter, which work_experiences to fetch.
     */
    where?: work_experiencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of work_experiences to fetch.
     */
    orderBy?: work_experiencesOrderByWithRelationInput | work_experiencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing work_experiences.
     */
    cursor?: work_experiencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` work_experiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` work_experiences.
     */
    skip?: number
    distinct?: Work_experiencesScalarFieldEnum | Work_experiencesScalarFieldEnum[]
  }

  /**
   * work_experiences create
   */
  export type work_experiencesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_experiences
     */
    select?: work_experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_experiences
     */
    omit?: work_experiencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_experiencesInclude<ExtArgs> | null
    /**
     * The data needed to create a work_experiences.
     */
    data: XOR<work_experiencesCreateInput, work_experiencesUncheckedCreateInput>
  }

  /**
   * work_experiences createMany
   */
  export type work_experiencesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many work_experiences.
     */
    data: work_experiencesCreateManyInput | work_experiencesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * work_experiences createManyAndReturn
   */
  export type work_experiencesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_experiences
     */
    select?: work_experiencesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the work_experiences
     */
    omit?: work_experiencesOmit<ExtArgs> | null
    /**
     * The data used to create many work_experiences.
     */
    data: work_experiencesCreateManyInput | work_experiencesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_experiencesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * work_experiences update
   */
  export type work_experiencesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_experiences
     */
    select?: work_experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_experiences
     */
    omit?: work_experiencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_experiencesInclude<ExtArgs> | null
    /**
     * The data needed to update a work_experiences.
     */
    data: XOR<work_experiencesUpdateInput, work_experiencesUncheckedUpdateInput>
    /**
     * Choose, which work_experiences to update.
     */
    where: work_experiencesWhereUniqueInput
  }

  /**
   * work_experiences updateMany
   */
  export type work_experiencesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update work_experiences.
     */
    data: XOR<work_experiencesUpdateManyMutationInput, work_experiencesUncheckedUpdateManyInput>
    /**
     * Filter which work_experiences to update
     */
    where?: work_experiencesWhereInput
    /**
     * Limit how many work_experiences to update.
     */
    limit?: number
  }

  /**
   * work_experiences updateManyAndReturn
   */
  export type work_experiencesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_experiences
     */
    select?: work_experiencesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the work_experiences
     */
    omit?: work_experiencesOmit<ExtArgs> | null
    /**
     * The data used to update work_experiences.
     */
    data: XOR<work_experiencesUpdateManyMutationInput, work_experiencesUncheckedUpdateManyInput>
    /**
     * Filter which work_experiences to update
     */
    where?: work_experiencesWhereInput
    /**
     * Limit how many work_experiences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_experiencesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * work_experiences upsert
   */
  export type work_experiencesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_experiences
     */
    select?: work_experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_experiences
     */
    omit?: work_experiencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_experiencesInclude<ExtArgs> | null
    /**
     * The filter to search for the work_experiences to update in case it exists.
     */
    where: work_experiencesWhereUniqueInput
    /**
     * In case the work_experiences found by the `where` argument doesn't exist, create a new work_experiences with this data.
     */
    create: XOR<work_experiencesCreateInput, work_experiencesUncheckedCreateInput>
    /**
     * In case the work_experiences was found with the provided `where` argument, update it with this data.
     */
    update: XOR<work_experiencesUpdateInput, work_experiencesUncheckedUpdateInput>
  }

  /**
   * work_experiences delete
   */
  export type work_experiencesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_experiences
     */
    select?: work_experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_experiences
     */
    omit?: work_experiencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_experiencesInclude<ExtArgs> | null
    /**
     * Filter which work_experiences to delete.
     */
    where: work_experiencesWhereUniqueInput
  }

  /**
   * work_experiences deleteMany
   */
  export type work_experiencesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which work_experiences to delete
     */
    where?: work_experiencesWhereInput
    /**
     * Limit how many work_experiences to delete.
     */
    limit?: number
  }

  /**
   * work_experiences without action
   */
  export type work_experiencesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_experiences
     */
    select?: work_experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_experiences
     */
    omit?: work_experiencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_experiencesInclude<ExtArgs> | null
  }


  /**
   * Model skills
   */

  export type AggregateSkills = {
    _count: SkillsCountAggregateOutputType | null
    _avg: SkillsAvgAggregateOutputType | null
    _sum: SkillsSumAggregateOutputType | null
    _min: SkillsMinAggregateOutputType | null
    _max: SkillsMaxAggregateOutputType | null
  }

  export type SkillsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    year_of_experience: number | null
  }

  export type SkillsSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    year_of_experience: number | null
  }

  export type SkillsMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    skill_name: string | null
    proficiency: $Enums.skillsstatus | null
    year_of_experience: number | null
    is_certifield: boolean | null
  }

  export type SkillsMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    skill_name: string | null
    proficiency: $Enums.skillsstatus | null
    year_of_experience: number | null
    is_certifield: boolean | null
  }

  export type SkillsCountAggregateOutputType = {
    id: number
    user_id: number
    skill_name: number
    proficiency: number
    year_of_experience: number
    is_certifield: number
    _all: number
  }


  export type SkillsAvgAggregateInputType = {
    id?: true
    user_id?: true
    year_of_experience?: true
  }

  export type SkillsSumAggregateInputType = {
    id?: true
    user_id?: true
    year_of_experience?: true
  }

  export type SkillsMinAggregateInputType = {
    id?: true
    user_id?: true
    skill_name?: true
    proficiency?: true
    year_of_experience?: true
    is_certifield?: true
  }

  export type SkillsMaxAggregateInputType = {
    id?: true
    user_id?: true
    skill_name?: true
    proficiency?: true
    year_of_experience?: true
    is_certifield?: true
  }

  export type SkillsCountAggregateInputType = {
    id?: true
    user_id?: true
    skill_name?: true
    proficiency?: true
    year_of_experience?: true
    is_certifield?: true
    _all?: true
  }

  export type SkillsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which skills to aggregate.
     */
    where?: skillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skills to fetch.
     */
    orderBy?: skillsOrderByWithRelationInput | skillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: skillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned skills
    **/
    _count?: true | SkillsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SkillsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SkillsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkillsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkillsMaxAggregateInputType
  }

  export type GetSkillsAggregateType<T extends SkillsAggregateArgs> = {
        [P in keyof T & keyof AggregateSkills]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkills[P]>
      : GetScalarType<T[P], AggregateSkills[P]>
  }




  export type skillsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: skillsWhereInput
    orderBy?: skillsOrderByWithAggregationInput | skillsOrderByWithAggregationInput[]
    by: SkillsScalarFieldEnum[] | SkillsScalarFieldEnum
    having?: skillsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkillsCountAggregateInputType | true
    _avg?: SkillsAvgAggregateInputType
    _sum?: SkillsSumAggregateInputType
    _min?: SkillsMinAggregateInputType
    _max?: SkillsMaxAggregateInputType
  }

  export type SkillsGroupByOutputType = {
    id: number
    user_id: number
    skill_name: string
    proficiency: $Enums.skillsstatus
    year_of_experience: number
    is_certifield: boolean
    _count: SkillsCountAggregateOutputType | null
    _avg: SkillsAvgAggregateOutputType | null
    _sum: SkillsSumAggregateOutputType | null
    _min: SkillsMinAggregateOutputType | null
    _max: SkillsMaxAggregateOutputType | null
  }

  type GetSkillsGroupByPayload<T extends skillsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkillsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkillsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkillsGroupByOutputType[P]>
            : GetScalarType<T[P], SkillsGroupByOutputType[P]>
        }
      >
    >


  export type skillsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    skill_name?: boolean
    proficiency?: boolean
    year_of_experience?: boolean
    is_certifield?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skills"]>

  export type skillsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    skill_name?: boolean
    proficiency?: boolean
    year_of_experience?: boolean
    is_certifield?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skills"]>

  export type skillsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    skill_name?: boolean
    proficiency?: boolean
    year_of_experience?: boolean
    is_certifield?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skills"]>

  export type skillsSelectScalar = {
    id?: boolean
    user_id?: boolean
    skill_name?: boolean
    proficiency?: boolean
    year_of_experience?: boolean
    is_certifield?: boolean
  }

  export type skillsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "skill_name" | "proficiency" | "year_of_experience" | "is_certifield", ExtArgs["result"]["skills"]>
  export type skillsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type skillsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type skillsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $skillsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "skills"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      skill_name: string
      proficiency: $Enums.skillsstatus
      year_of_experience: number
      is_certifield: boolean
    }, ExtArgs["result"]["skills"]>
    composites: {}
  }

  type skillsGetPayload<S extends boolean | null | undefined | skillsDefaultArgs> = $Result.GetResult<Prisma.$skillsPayload, S>

  type skillsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<skillsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SkillsCountAggregateInputType | true
    }

  export interface skillsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['skills'], meta: { name: 'skills' } }
    /**
     * Find zero or one Skills that matches the filter.
     * @param {skillsFindUniqueArgs} args - Arguments to find a Skills
     * @example
     * // Get one Skills
     * const skills = await prisma.skills.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends skillsFindUniqueArgs>(args: SelectSubset<T, skillsFindUniqueArgs<ExtArgs>>): Prisma__skillsClient<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Skills that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {skillsFindUniqueOrThrowArgs} args - Arguments to find a Skills
     * @example
     * // Get one Skills
     * const skills = await prisma.skills.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends skillsFindUniqueOrThrowArgs>(args: SelectSubset<T, skillsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__skillsClient<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Skills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillsFindFirstArgs} args - Arguments to find a Skills
     * @example
     * // Get one Skills
     * const skills = await prisma.skills.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends skillsFindFirstArgs>(args?: SelectSubset<T, skillsFindFirstArgs<ExtArgs>>): Prisma__skillsClient<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Skills that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillsFindFirstOrThrowArgs} args - Arguments to find a Skills
     * @example
     * // Get one Skills
     * const skills = await prisma.skills.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends skillsFindFirstOrThrowArgs>(args?: SelectSubset<T, skillsFindFirstOrThrowArgs<ExtArgs>>): Prisma__skillsClient<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Skills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Skills
     * const skills = await prisma.skills.findMany()
     * 
     * // Get first 10 Skills
     * const skills = await prisma.skills.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skillsWithIdOnly = await prisma.skills.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends skillsFindManyArgs>(args?: SelectSubset<T, skillsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Skills.
     * @param {skillsCreateArgs} args - Arguments to create a Skills.
     * @example
     * // Create one Skills
     * const Skills = await prisma.skills.create({
     *   data: {
     *     // ... data to create a Skills
     *   }
     * })
     * 
     */
    create<T extends skillsCreateArgs>(args: SelectSubset<T, skillsCreateArgs<ExtArgs>>): Prisma__skillsClient<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Skills.
     * @param {skillsCreateManyArgs} args - Arguments to create many Skills.
     * @example
     * // Create many Skills
     * const skills = await prisma.skills.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends skillsCreateManyArgs>(args?: SelectSubset<T, skillsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Skills and returns the data saved in the database.
     * @param {skillsCreateManyAndReturnArgs} args - Arguments to create many Skills.
     * @example
     * // Create many Skills
     * const skills = await prisma.skills.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Skills and only return the `id`
     * const skillsWithIdOnly = await prisma.skills.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends skillsCreateManyAndReturnArgs>(args?: SelectSubset<T, skillsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Skills.
     * @param {skillsDeleteArgs} args - Arguments to delete one Skills.
     * @example
     * // Delete one Skills
     * const Skills = await prisma.skills.delete({
     *   where: {
     *     // ... filter to delete one Skills
     *   }
     * })
     * 
     */
    delete<T extends skillsDeleteArgs>(args: SelectSubset<T, skillsDeleteArgs<ExtArgs>>): Prisma__skillsClient<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Skills.
     * @param {skillsUpdateArgs} args - Arguments to update one Skills.
     * @example
     * // Update one Skills
     * const skills = await prisma.skills.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends skillsUpdateArgs>(args: SelectSubset<T, skillsUpdateArgs<ExtArgs>>): Prisma__skillsClient<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Skills.
     * @param {skillsDeleteManyArgs} args - Arguments to filter Skills to delete.
     * @example
     * // Delete a few Skills
     * const { count } = await prisma.skills.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends skillsDeleteManyArgs>(args?: SelectSubset<T, skillsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Skills
     * const skills = await prisma.skills.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends skillsUpdateManyArgs>(args: SelectSubset<T, skillsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skills and returns the data updated in the database.
     * @param {skillsUpdateManyAndReturnArgs} args - Arguments to update many Skills.
     * @example
     * // Update many Skills
     * const skills = await prisma.skills.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Skills and only return the `id`
     * const skillsWithIdOnly = await prisma.skills.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends skillsUpdateManyAndReturnArgs>(args: SelectSubset<T, skillsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Skills.
     * @param {skillsUpsertArgs} args - Arguments to update or create a Skills.
     * @example
     * // Update or create a Skills
     * const skills = await prisma.skills.upsert({
     *   create: {
     *     // ... data to create a Skills
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Skills we want to update
     *   }
     * })
     */
    upsert<T extends skillsUpsertArgs>(args: SelectSubset<T, skillsUpsertArgs<ExtArgs>>): Prisma__skillsClient<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillsCountArgs} args - Arguments to filter Skills to count.
     * @example
     * // Count the number of Skills
     * const count = await prisma.skills.count({
     *   where: {
     *     // ... the filter for the Skills we want to count
     *   }
     * })
    **/
    count<T extends skillsCountArgs>(
      args?: Subset<T, skillsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkillsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkillsAggregateArgs>(args: Subset<T, SkillsAggregateArgs>): Prisma.PrismaPromise<GetSkillsAggregateType<T>>

    /**
     * Group by Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends skillsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: skillsGroupByArgs['orderBy'] }
        : { orderBy?: skillsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, skillsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkillsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the skills model
   */
  readonly fields: skillsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for skills.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__skillsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the skills model
   */
  interface skillsFieldRefs {
    readonly id: FieldRef<"skills", 'Int'>
    readonly user_id: FieldRef<"skills", 'Int'>
    readonly skill_name: FieldRef<"skills", 'String'>
    readonly proficiency: FieldRef<"skills", 'skillsstatus'>
    readonly year_of_experience: FieldRef<"skills", 'Int'>
    readonly is_certifield: FieldRef<"skills", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * skills findUnique
   */
  export type skillsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skills
     */
    omit?: skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillsInclude<ExtArgs> | null
    /**
     * Filter, which skills to fetch.
     */
    where: skillsWhereUniqueInput
  }

  /**
   * skills findUniqueOrThrow
   */
  export type skillsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skills
     */
    omit?: skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillsInclude<ExtArgs> | null
    /**
     * Filter, which skills to fetch.
     */
    where: skillsWhereUniqueInput
  }

  /**
   * skills findFirst
   */
  export type skillsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skills
     */
    omit?: skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillsInclude<ExtArgs> | null
    /**
     * Filter, which skills to fetch.
     */
    where?: skillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skills to fetch.
     */
    orderBy?: skillsOrderByWithRelationInput | skillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for skills.
     */
    cursor?: skillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of skills.
     */
    distinct?: SkillsScalarFieldEnum | SkillsScalarFieldEnum[]
  }

  /**
   * skills findFirstOrThrow
   */
  export type skillsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skills
     */
    omit?: skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillsInclude<ExtArgs> | null
    /**
     * Filter, which skills to fetch.
     */
    where?: skillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skills to fetch.
     */
    orderBy?: skillsOrderByWithRelationInput | skillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for skills.
     */
    cursor?: skillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of skills.
     */
    distinct?: SkillsScalarFieldEnum | SkillsScalarFieldEnum[]
  }

  /**
   * skills findMany
   */
  export type skillsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skills
     */
    omit?: skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillsInclude<ExtArgs> | null
    /**
     * Filter, which skills to fetch.
     */
    where?: skillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skills to fetch.
     */
    orderBy?: skillsOrderByWithRelationInput | skillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing skills.
     */
    cursor?: skillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skills.
     */
    skip?: number
    distinct?: SkillsScalarFieldEnum | SkillsScalarFieldEnum[]
  }

  /**
   * skills create
   */
  export type skillsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skills
     */
    omit?: skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillsInclude<ExtArgs> | null
    /**
     * The data needed to create a skills.
     */
    data: XOR<skillsCreateInput, skillsUncheckedCreateInput>
  }

  /**
   * skills createMany
   */
  export type skillsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many skills.
     */
    data: skillsCreateManyInput | skillsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * skills createManyAndReturn
   */
  export type skillsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the skills
     */
    omit?: skillsOmit<ExtArgs> | null
    /**
     * The data used to create many skills.
     */
    data: skillsCreateManyInput | skillsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * skills update
   */
  export type skillsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skills
     */
    omit?: skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillsInclude<ExtArgs> | null
    /**
     * The data needed to update a skills.
     */
    data: XOR<skillsUpdateInput, skillsUncheckedUpdateInput>
    /**
     * Choose, which skills to update.
     */
    where: skillsWhereUniqueInput
  }

  /**
   * skills updateMany
   */
  export type skillsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update skills.
     */
    data: XOR<skillsUpdateManyMutationInput, skillsUncheckedUpdateManyInput>
    /**
     * Filter which skills to update
     */
    where?: skillsWhereInput
    /**
     * Limit how many skills to update.
     */
    limit?: number
  }

  /**
   * skills updateManyAndReturn
   */
  export type skillsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the skills
     */
    omit?: skillsOmit<ExtArgs> | null
    /**
     * The data used to update skills.
     */
    data: XOR<skillsUpdateManyMutationInput, skillsUncheckedUpdateManyInput>
    /**
     * Filter which skills to update
     */
    where?: skillsWhereInput
    /**
     * Limit how many skills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * skills upsert
   */
  export type skillsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skills
     */
    omit?: skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillsInclude<ExtArgs> | null
    /**
     * The filter to search for the skills to update in case it exists.
     */
    where: skillsWhereUniqueInput
    /**
     * In case the skills found by the `where` argument doesn't exist, create a new skills with this data.
     */
    create: XOR<skillsCreateInput, skillsUncheckedCreateInput>
    /**
     * In case the skills was found with the provided `where` argument, update it with this data.
     */
    update: XOR<skillsUpdateInput, skillsUncheckedUpdateInput>
  }

  /**
   * skills delete
   */
  export type skillsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skills
     */
    omit?: skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillsInclude<ExtArgs> | null
    /**
     * Filter which skills to delete.
     */
    where: skillsWhereUniqueInput
  }

  /**
   * skills deleteMany
   */
  export type skillsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which skills to delete
     */
    where?: skillsWhereInput
    /**
     * Limit how many skills to delete.
     */
    limit?: number
  }

  /**
   * skills without action
   */
  export type skillsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skills
     */
    omit?: skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillsInclude<ExtArgs> | null
  }


  /**
   * Model languages
   */

  export type AggregateLanguages = {
    _count: LanguagesCountAggregateOutputType | null
    _avg: LanguagesAvgAggregateOutputType | null
    _sum: LanguagesSumAggregateOutputType | null
    _min: LanguagesMinAggregateOutputType | null
    _max: LanguagesMaxAggregateOutputType | null
  }

  export type LanguagesAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type LanguagesSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type LanguagesMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    languages: string | null
    proficiency: $Enums.proficiencylanguages | null
    is_primary: boolean | null
  }

  export type LanguagesMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    languages: string | null
    proficiency: $Enums.proficiencylanguages | null
    is_primary: boolean | null
  }

  export type LanguagesCountAggregateOutputType = {
    id: number
    user_id: number
    languages: number
    proficiency: number
    is_primary: number
    _all: number
  }


  export type LanguagesAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type LanguagesSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type LanguagesMinAggregateInputType = {
    id?: true
    user_id?: true
    languages?: true
    proficiency?: true
    is_primary?: true
  }

  export type LanguagesMaxAggregateInputType = {
    id?: true
    user_id?: true
    languages?: true
    proficiency?: true
    is_primary?: true
  }

  export type LanguagesCountAggregateInputType = {
    id?: true
    user_id?: true
    languages?: true
    proficiency?: true
    is_primary?: true
    _all?: true
  }

  export type LanguagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which languages to aggregate.
     */
    where?: languagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of languages to fetch.
     */
    orderBy?: languagesOrderByWithRelationInput | languagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: languagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned languages
    **/
    _count?: true | LanguagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LanguagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LanguagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LanguagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LanguagesMaxAggregateInputType
  }

  export type GetLanguagesAggregateType<T extends LanguagesAggregateArgs> = {
        [P in keyof T & keyof AggregateLanguages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLanguages[P]>
      : GetScalarType<T[P], AggregateLanguages[P]>
  }




  export type languagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: languagesWhereInput
    orderBy?: languagesOrderByWithAggregationInput | languagesOrderByWithAggregationInput[]
    by: LanguagesScalarFieldEnum[] | LanguagesScalarFieldEnum
    having?: languagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LanguagesCountAggregateInputType | true
    _avg?: LanguagesAvgAggregateInputType
    _sum?: LanguagesSumAggregateInputType
    _min?: LanguagesMinAggregateInputType
    _max?: LanguagesMaxAggregateInputType
  }

  export type LanguagesGroupByOutputType = {
    id: number
    user_id: number
    languages: string
    proficiency: $Enums.proficiencylanguages
    is_primary: boolean
    _count: LanguagesCountAggregateOutputType | null
    _avg: LanguagesAvgAggregateOutputType | null
    _sum: LanguagesSumAggregateOutputType | null
    _min: LanguagesMinAggregateOutputType | null
    _max: LanguagesMaxAggregateOutputType | null
  }

  type GetLanguagesGroupByPayload<T extends languagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LanguagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LanguagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LanguagesGroupByOutputType[P]>
            : GetScalarType<T[P], LanguagesGroupByOutputType[P]>
        }
      >
    >


  export type languagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    languages?: boolean
    proficiency?: boolean
    is_primary?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["languages"]>

  export type languagesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    languages?: boolean
    proficiency?: boolean
    is_primary?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["languages"]>

  export type languagesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    languages?: boolean
    proficiency?: boolean
    is_primary?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["languages"]>

  export type languagesSelectScalar = {
    id?: boolean
    user_id?: boolean
    languages?: boolean
    proficiency?: boolean
    is_primary?: boolean
  }

  export type languagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "languages" | "proficiency" | "is_primary", ExtArgs["result"]["languages"]>
  export type languagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type languagesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type languagesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $languagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "languages"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      languages: string
      proficiency: $Enums.proficiencylanguages
      is_primary: boolean
    }, ExtArgs["result"]["languages"]>
    composites: {}
  }

  type languagesGetPayload<S extends boolean | null | undefined | languagesDefaultArgs> = $Result.GetResult<Prisma.$languagesPayload, S>

  type languagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<languagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LanguagesCountAggregateInputType | true
    }

  export interface languagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['languages'], meta: { name: 'languages' } }
    /**
     * Find zero or one Languages that matches the filter.
     * @param {languagesFindUniqueArgs} args - Arguments to find a Languages
     * @example
     * // Get one Languages
     * const languages = await prisma.languages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends languagesFindUniqueArgs>(args: SelectSubset<T, languagesFindUniqueArgs<ExtArgs>>): Prisma__languagesClient<$Result.GetResult<Prisma.$languagesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Languages that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {languagesFindUniqueOrThrowArgs} args - Arguments to find a Languages
     * @example
     * // Get one Languages
     * const languages = await prisma.languages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends languagesFindUniqueOrThrowArgs>(args: SelectSubset<T, languagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__languagesClient<$Result.GetResult<Prisma.$languagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Languages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {languagesFindFirstArgs} args - Arguments to find a Languages
     * @example
     * // Get one Languages
     * const languages = await prisma.languages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends languagesFindFirstArgs>(args?: SelectSubset<T, languagesFindFirstArgs<ExtArgs>>): Prisma__languagesClient<$Result.GetResult<Prisma.$languagesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Languages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {languagesFindFirstOrThrowArgs} args - Arguments to find a Languages
     * @example
     * // Get one Languages
     * const languages = await prisma.languages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends languagesFindFirstOrThrowArgs>(args?: SelectSubset<T, languagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__languagesClient<$Result.GetResult<Prisma.$languagesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Languages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {languagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Languages
     * const languages = await prisma.languages.findMany()
     * 
     * // Get first 10 Languages
     * const languages = await prisma.languages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const languagesWithIdOnly = await prisma.languages.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends languagesFindManyArgs>(args?: SelectSubset<T, languagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$languagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Languages.
     * @param {languagesCreateArgs} args - Arguments to create a Languages.
     * @example
     * // Create one Languages
     * const Languages = await prisma.languages.create({
     *   data: {
     *     // ... data to create a Languages
     *   }
     * })
     * 
     */
    create<T extends languagesCreateArgs>(args: SelectSubset<T, languagesCreateArgs<ExtArgs>>): Prisma__languagesClient<$Result.GetResult<Prisma.$languagesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Languages.
     * @param {languagesCreateManyArgs} args - Arguments to create many Languages.
     * @example
     * // Create many Languages
     * const languages = await prisma.languages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends languagesCreateManyArgs>(args?: SelectSubset<T, languagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Languages and returns the data saved in the database.
     * @param {languagesCreateManyAndReturnArgs} args - Arguments to create many Languages.
     * @example
     * // Create many Languages
     * const languages = await prisma.languages.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Languages and only return the `id`
     * const languagesWithIdOnly = await prisma.languages.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends languagesCreateManyAndReturnArgs>(args?: SelectSubset<T, languagesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$languagesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Languages.
     * @param {languagesDeleteArgs} args - Arguments to delete one Languages.
     * @example
     * // Delete one Languages
     * const Languages = await prisma.languages.delete({
     *   where: {
     *     // ... filter to delete one Languages
     *   }
     * })
     * 
     */
    delete<T extends languagesDeleteArgs>(args: SelectSubset<T, languagesDeleteArgs<ExtArgs>>): Prisma__languagesClient<$Result.GetResult<Prisma.$languagesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Languages.
     * @param {languagesUpdateArgs} args - Arguments to update one Languages.
     * @example
     * // Update one Languages
     * const languages = await prisma.languages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends languagesUpdateArgs>(args: SelectSubset<T, languagesUpdateArgs<ExtArgs>>): Prisma__languagesClient<$Result.GetResult<Prisma.$languagesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Languages.
     * @param {languagesDeleteManyArgs} args - Arguments to filter Languages to delete.
     * @example
     * // Delete a few Languages
     * const { count } = await prisma.languages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends languagesDeleteManyArgs>(args?: SelectSubset<T, languagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {languagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Languages
     * const languages = await prisma.languages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends languagesUpdateManyArgs>(args: SelectSubset<T, languagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Languages and returns the data updated in the database.
     * @param {languagesUpdateManyAndReturnArgs} args - Arguments to update many Languages.
     * @example
     * // Update many Languages
     * const languages = await prisma.languages.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Languages and only return the `id`
     * const languagesWithIdOnly = await prisma.languages.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends languagesUpdateManyAndReturnArgs>(args: SelectSubset<T, languagesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$languagesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Languages.
     * @param {languagesUpsertArgs} args - Arguments to update or create a Languages.
     * @example
     * // Update or create a Languages
     * const languages = await prisma.languages.upsert({
     *   create: {
     *     // ... data to create a Languages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Languages we want to update
     *   }
     * })
     */
    upsert<T extends languagesUpsertArgs>(args: SelectSubset<T, languagesUpsertArgs<ExtArgs>>): Prisma__languagesClient<$Result.GetResult<Prisma.$languagesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {languagesCountArgs} args - Arguments to filter Languages to count.
     * @example
     * // Count the number of Languages
     * const count = await prisma.languages.count({
     *   where: {
     *     // ... the filter for the Languages we want to count
     *   }
     * })
    **/
    count<T extends languagesCountArgs>(
      args?: Subset<T, languagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LanguagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LanguagesAggregateArgs>(args: Subset<T, LanguagesAggregateArgs>): Prisma.PrismaPromise<GetLanguagesAggregateType<T>>

    /**
     * Group by Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {languagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends languagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: languagesGroupByArgs['orderBy'] }
        : { orderBy?: languagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, languagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLanguagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the languages model
   */
  readonly fields: languagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for languages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__languagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the languages model
   */
  interface languagesFieldRefs {
    readonly id: FieldRef<"languages", 'Int'>
    readonly user_id: FieldRef<"languages", 'Int'>
    readonly languages: FieldRef<"languages", 'String'>
    readonly proficiency: FieldRef<"languages", 'proficiencylanguages'>
    readonly is_primary: FieldRef<"languages", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * languages findUnique
   */
  export type languagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the languages
     */
    select?: languagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the languages
     */
    omit?: languagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: languagesInclude<ExtArgs> | null
    /**
     * Filter, which languages to fetch.
     */
    where: languagesWhereUniqueInput
  }

  /**
   * languages findUniqueOrThrow
   */
  export type languagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the languages
     */
    select?: languagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the languages
     */
    omit?: languagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: languagesInclude<ExtArgs> | null
    /**
     * Filter, which languages to fetch.
     */
    where: languagesWhereUniqueInput
  }

  /**
   * languages findFirst
   */
  export type languagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the languages
     */
    select?: languagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the languages
     */
    omit?: languagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: languagesInclude<ExtArgs> | null
    /**
     * Filter, which languages to fetch.
     */
    where?: languagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of languages to fetch.
     */
    orderBy?: languagesOrderByWithRelationInput | languagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for languages.
     */
    cursor?: languagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of languages.
     */
    distinct?: LanguagesScalarFieldEnum | LanguagesScalarFieldEnum[]
  }

  /**
   * languages findFirstOrThrow
   */
  export type languagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the languages
     */
    select?: languagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the languages
     */
    omit?: languagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: languagesInclude<ExtArgs> | null
    /**
     * Filter, which languages to fetch.
     */
    where?: languagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of languages to fetch.
     */
    orderBy?: languagesOrderByWithRelationInput | languagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for languages.
     */
    cursor?: languagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of languages.
     */
    distinct?: LanguagesScalarFieldEnum | LanguagesScalarFieldEnum[]
  }

  /**
   * languages findMany
   */
  export type languagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the languages
     */
    select?: languagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the languages
     */
    omit?: languagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: languagesInclude<ExtArgs> | null
    /**
     * Filter, which languages to fetch.
     */
    where?: languagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of languages to fetch.
     */
    orderBy?: languagesOrderByWithRelationInput | languagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing languages.
     */
    cursor?: languagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` languages.
     */
    skip?: number
    distinct?: LanguagesScalarFieldEnum | LanguagesScalarFieldEnum[]
  }

  /**
   * languages create
   */
  export type languagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the languages
     */
    select?: languagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the languages
     */
    omit?: languagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: languagesInclude<ExtArgs> | null
    /**
     * The data needed to create a languages.
     */
    data: XOR<languagesCreateInput, languagesUncheckedCreateInput>
  }

  /**
   * languages createMany
   */
  export type languagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many languages.
     */
    data: languagesCreateManyInput | languagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * languages createManyAndReturn
   */
  export type languagesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the languages
     */
    select?: languagesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the languages
     */
    omit?: languagesOmit<ExtArgs> | null
    /**
     * The data used to create many languages.
     */
    data: languagesCreateManyInput | languagesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: languagesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * languages update
   */
  export type languagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the languages
     */
    select?: languagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the languages
     */
    omit?: languagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: languagesInclude<ExtArgs> | null
    /**
     * The data needed to update a languages.
     */
    data: XOR<languagesUpdateInput, languagesUncheckedUpdateInput>
    /**
     * Choose, which languages to update.
     */
    where: languagesWhereUniqueInput
  }

  /**
   * languages updateMany
   */
  export type languagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update languages.
     */
    data: XOR<languagesUpdateManyMutationInput, languagesUncheckedUpdateManyInput>
    /**
     * Filter which languages to update
     */
    where?: languagesWhereInput
    /**
     * Limit how many languages to update.
     */
    limit?: number
  }

  /**
   * languages updateManyAndReturn
   */
  export type languagesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the languages
     */
    select?: languagesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the languages
     */
    omit?: languagesOmit<ExtArgs> | null
    /**
     * The data used to update languages.
     */
    data: XOR<languagesUpdateManyMutationInput, languagesUncheckedUpdateManyInput>
    /**
     * Filter which languages to update
     */
    where?: languagesWhereInput
    /**
     * Limit how many languages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: languagesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * languages upsert
   */
  export type languagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the languages
     */
    select?: languagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the languages
     */
    omit?: languagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: languagesInclude<ExtArgs> | null
    /**
     * The filter to search for the languages to update in case it exists.
     */
    where: languagesWhereUniqueInput
    /**
     * In case the languages found by the `where` argument doesn't exist, create a new languages with this data.
     */
    create: XOR<languagesCreateInput, languagesUncheckedCreateInput>
    /**
     * In case the languages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<languagesUpdateInput, languagesUncheckedUpdateInput>
  }

  /**
   * languages delete
   */
  export type languagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the languages
     */
    select?: languagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the languages
     */
    omit?: languagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: languagesInclude<ExtArgs> | null
    /**
     * Filter which languages to delete.
     */
    where: languagesWhereUniqueInput
  }

  /**
   * languages deleteMany
   */
  export type languagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which languages to delete
     */
    where?: languagesWhereInput
    /**
     * Limit how many languages to delete.
     */
    limit?: number
  }

  /**
   * languages without action
   */
  export type languagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the languages
     */
    select?: languagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the languages
     */
    omit?: languagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: languagesInclude<ExtArgs> | null
  }


  /**
   * Model certifications
   */

  export type AggregateCertifications = {
    _count: CertificationsCountAggregateOutputType | null
    _avg: CertificationsAvgAggregateOutputType | null
    _sum: CertificationsSumAggregateOutputType | null
    _min: CertificationsMinAggregateOutputType | null
    _max: CertificationsMaxAggregateOutputType | null
  }

  export type CertificationsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type CertificationsSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type CertificationsMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    name: string | null
    issuing_organization: string | null
    issue_date: Date | null
    expiration_date: Date | null
    credential_id: string | null
    credential_url: string | null
    is_foreign_certification: boolean | null
  }

  export type CertificationsMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    name: string | null
    issuing_organization: string | null
    issue_date: Date | null
    expiration_date: Date | null
    credential_id: string | null
    credential_url: string | null
    is_foreign_certification: boolean | null
  }

  export type CertificationsCountAggregateOutputType = {
    id: number
    user_id: number
    name: number
    issuing_organization: number
    issue_date: number
    expiration_date: number
    credential_id: number
    credential_url: number
    is_foreign_certification: number
    _all: number
  }


  export type CertificationsAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type CertificationsSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type CertificationsMinAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    issuing_organization?: true
    issue_date?: true
    expiration_date?: true
    credential_id?: true
    credential_url?: true
    is_foreign_certification?: true
  }

  export type CertificationsMaxAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    issuing_organization?: true
    issue_date?: true
    expiration_date?: true
    credential_id?: true
    credential_url?: true
    is_foreign_certification?: true
  }

  export type CertificationsCountAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    issuing_organization?: true
    issue_date?: true
    expiration_date?: true
    credential_id?: true
    credential_url?: true
    is_foreign_certification?: true
    _all?: true
  }

  export type CertificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which certifications to aggregate.
     */
    where?: certificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of certifications to fetch.
     */
    orderBy?: certificationsOrderByWithRelationInput | certificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: certificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` certifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` certifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned certifications
    **/
    _count?: true | CertificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CertificationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CertificationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CertificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CertificationsMaxAggregateInputType
  }

  export type GetCertificationsAggregateType<T extends CertificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateCertifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCertifications[P]>
      : GetScalarType<T[P], AggregateCertifications[P]>
  }




  export type certificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: certificationsWhereInput
    orderBy?: certificationsOrderByWithAggregationInput | certificationsOrderByWithAggregationInput[]
    by: CertificationsScalarFieldEnum[] | CertificationsScalarFieldEnum
    having?: certificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CertificationsCountAggregateInputType | true
    _avg?: CertificationsAvgAggregateInputType
    _sum?: CertificationsSumAggregateInputType
    _min?: CertificationsMinAggregateInputType
    _max?: CertificationsMaxAggregateInputType
  }

  export type CertificationsGroupByOutputType = {
    id: number
    user_id: number
    name: string
    issuing_organization: string
    issue_date: Date
    expiration_date: Date
    credential_id: string
    credential_url: string
    is_foreign_certification: boolean
    _count: CertificationsCountAggregateOutputType | null
    _avg: CertificationsAvgAggregateOutputType | null
    _sum: CertificationsSumAggregateOutputType | null
    _min: CertificationsMinAggregateOutputType | null
    _max: CertificationsMaxAggregateOutputType | null
  }

  type GetCertificationsGroupByPayload<T extends certificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CertificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CertificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CertificationsGroupByOutputType[P]>
            : GetScalarType<T[P], CertificationsGroupByOutputType[P]>
        }
      >
    >


  export type certificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    name?: boolean
    issuing_organization?: boolean
    issue_date?: boolean
    expiration_date?: boolean
    credential_id?: boolean
    credential_url?: boolean
    is_foreign_certification?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certifications"]>

  export type certificationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    name?: boolean
    issuing_organization?: boolean
    issue_date?: boolean
    expiration_date?: boolean
    credential_id?: boolean
    credential_url?: boolean
    is_foreign_certification?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certifications"]>

  export type certificationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    name?: boolean
    issuing_organization?: boolean
    issue_date?: boolean
    expiration_date?: boolean
    credential_id?: boolean
    credential_url?: boolean
    is_foreign_certification?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certifications"]>

  export type certificationsSelectScalar = {
    id?: boolean
    user_id?: boolean
    name?: boolean
    issuing_organization?: boolean
    issue_date?: boolean
    expiration_date?: boolean
    credential_id?: boolean
    credential_url?: boolean
    is_foreign_certification?: boolean
  }

  export type certificationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "name" | "issuing_organization" | "issue_date" | "expiration_date" | "credential_id" | "credential_url" | "is_foreign_certification", ExtArgs["result"]["certifications"]>
  export type certificationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type certificationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type certificationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $certificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "certifications"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      name: string
      issuing_organization: string
      issue_date: Date
      expiration_date: Date
      credential_id: string
      credential_url: string
      is_foreign_certification: boolean
    }, ExtArgs["result"]["certifications"]>
    composites: {}
  }

  type certificationsGetPayload<S extends boolean | null | undefined | certificationsDefaultArgs> = $Result.GetResult<Prisma.$certificationsPayload, S>

  type certificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<certificationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CertificationsCountAggregateInputType | true
    }

  export interface certificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['certifications'], meta: { name: 'certifications' } }
    /**
     * Find zero or one Certifications that matches the filter.
     * @param {certificationsFindUniqueArgs} args - Arguments to find a Certifications
     * @example
     * // Get one Certifications
     * const certifications = await prisma.certifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends certificationsFindUniqueArgs>(args: SelectSubset<T, certificationsFindUniqueArgs<ExtArgs>>): Prisma__certificationsClient<$Result.GetResult<Prisma.$certificationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Certifications that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {certificationsFindUniqueOrThrowArgs} args - Arguments to find a Certifications
     * @example
     * // Get one Certifications
     * const certifications = await prisma.certifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends certificationsFindUniqueOrThrowArgs>(args: SelectSubset<T, certificationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__certificationsClient<$Result.GetResult<Prisma.$certificationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Certifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificationsFindFirstArgs} args - Arguments to find a Certifications
     * @example
     * // Get one Certifications
     * const certifications = await prisma.certifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends certificationsFindFirstArgs>(args?: SelectSubset<T, certificationsFindFirstArgs<ExtArgs>>): Prisma__certificationsClient<$Result.GetResult<Prisma.$certificationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Certifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificationsFindFirstOrThrowArgs} args - Arguments to find a Certifications
     * @example
     * // Get one Certifications
     * const certifications = await prisma.certifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends certificationsFindFirstOrThrowArgs>(args?: SelectSubset<T, certificationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__certificationsClient<$Result.GetResult<Prisma.$certificationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Certifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Certifications
     * const certifications = await prisma.certifications.findMany()
     * 
     * // Get first 10 Certifications
     * const certifications = await prisma.certifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const certificationsWithIdOnly = await prisma.certifications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends certificationsFindManyArgs>(args?: SelectSubset<T, certificationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$certificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Certifications.
     * @param {certificationsCreateArgs} args - Arguments to create a Certifications.
     * @example
     * // Create one Certifications
     * const Certifications = await prisma.certifications.create({
     *   data: {
     *     // ... data to create a Certifications
     *   }
     * })
     * 
     */
    create<T extends certificationsCreateArgs>(args: SelectSubset<T, certificationsCreateArgs<ExtArgs>>): Prisma__certificationsClient<$Result.GetResult<Prisma.$certificationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Certifications.
     * @param {certificationsCreateManyArgs} args - Arguments to create many Certifications.
     * @example
     * // Create many Certifications
     * const certifications = await prisma.certifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends certificationsCreateManyArgs>(args?: SelectSubset<T, certificationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Certifications and returns the data saved in the database.
     * @param {certificationsCreateManyAndReturnArgs} args - Arguments to create many Certifications.
     * @example
     * // Create many Certifications
     * const certifications = await prisma.certifications.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Certifications and only return the `id`
     * const certificationsWithIdOnly = await prisma.certifications.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends certificationsCreateManyAndReturnArgs>(args?: SelectSubset<T, certificationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$certificationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Certifications.
     * @param {certificationsDeleteArgs} args - Arguments to delete one Certifications.
     * @example
     * // Delete one Certifications
     * const Certifications = await prisma.certifications.delete({
     *   where: {
     *     // ... filter to delete one Certifications
     *   }
     * })
     * 
     */
    delete<T extends certificationsDeleteArgs>(args: SelectSubset<T, certificationsDeleteArgs<ExtArgs>>): Prisma__certificationsClient<$Result.GetResult<Prisma.$certificationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Certifications.
     * @param {certificationsUpdateArgs} args - Arguments to update one Certifications.
     * @example
     * // Update one Certifications
     * const certifications = await prisma.certifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends certificationsUpdateArgs>(args: SelectSubset<T, certificationsUpdateArgs<ExtArgs>>): Prisma__certificationsClient<$Result.GetResult<Prisma.$certificationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Certifications.
     * @param {certificationsDeleteManyArgs} args - Arguments to filter Certifications to delete.
     * @example
     * // Delete a few Certifications
     * const { count } = await prisma.certifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends certificationsDeleteManyArgs>(args?: SelectSubset<T, certificationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Certifications
     * const certifications = await prisma.certifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends certificationsUpdateManyArgs>(args: SelectSubset<T, certificationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certifications and returns the data updated in the database.
     * @param {certificationsUpdateManyAndReturnArgs} args - Arguments to update many Certifications.
     * @example
     * // Update many Certifications
     * const certifications = await prisma.certifications.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Certifications and only return the `id`
     * const certificationsWithIdOnly = await prisma.certifications.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends certificationsUpdateManyAndReturnArgs>(args: SelectSubset<T, certificationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$certificationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Certifications.
     * @param {certificationsUpsertArgs} args - Arguments to update or create a Certifications.
     * @example
     * // Update or create a Certifications
     * const certifications = await prisma.certifications.upsert({
     *   create: {
     *     // ... data to create a Certifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Certifications we want to update
     *   }
     * })
     */
    upsert<T extends certificationsUpsertArgs>(args: SelectSubset<T, certificationsUpsertArgs<ExtArgs>>): Prisma__certificationsClient<$Result.GetResult<Prisma.$certificationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Certifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificationsCountArgs} args - Arguments to filter Certifications to count.
     * @example
     * // Count the number of Certifications
     * const count = await prisma.certifications.count({
     *   where: {
     *     // ... the filter for the Certifications we want to count
     *   }
     * })
    **/
    count<T extends certificationsCountArgs>(
      args?: Subset<T, certificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CertificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Certifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CertificationsAggregateArgs>(args: Subset<T, CertificationsAggregateArgs>): Prisma.PrismaPromise<GetCertificationsAggregateType<T>>

    /**
     * Group by Certifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends certificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: certificationsGroupByArgs['orderBy'] }
        : { orderBy?: certificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, certificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCertificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the certifications model
   */
  readonly fields: certificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for certifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__certificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the certifications model
   */
  interface certificationsFieldRefs {
    readonly id: FieldRef<"certifications", 'Int'>
    readonly user_id: FieldRef<"certifications", 'Int'>
    readonly name: FieldRef<"certifications", 'String'>
    readonly issuing_organization: FieldRef<"certifications", 'String'>
    readonly issue_date: FieldRef<"certifications", 'DateTime'>
    readonly expiration_date: FieldRef<"certifications", 'DateTime'>
    readonly credential_id: FieldRef<"certifications", 'String'>
    readonly credential_url: FieldRef<"certifications", 'String'>
    readonly is_foreign_certification: FieldRef<"certifications", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * certifications findUnique
   */
  export type certificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certifications
     */
    select?: certificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certifications
     */
    omit?: certificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificationsInclude<ExtArgs> | null
    /**
     * Filter, which certifications to fetch.
     */
    where: certificationsWhereUniqueInput
  }

  /**
   * certifications findUniqueOrThrow
   */
  export type certificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certifications
     */
    select?: certificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certifications
     */
    omit?: certificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificationsInclude<ExtArgs> | null
    /**
     * Filter, which certifications to fetch.
     */
    where: certificationsWhereUniqueInput
  }

  /**
   * certifications findFirst
   */
  export type certificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certifications
     */
    select?: certificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certifications
     */
    omit?: certificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificationsInclude<ExtArgs> | null
    /**
     * Filter, which certifications to fetch.
     */
    where?: certificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of certifications to fetch.
     */
    orderBy?: certificationsOrderByWithRelationInput | certificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for certifications.
     */
    cursor?: certificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` certifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` certifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of certifications.
     */
    distinct?: CertificationsScalarFieldEnum | CertificationsScalarFieldEnum[]
  }

  /**
   * certifications findFirstOrThrow
   */
  export type certificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certifications
     */
    select?: certificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certifications
     */
    omit?: certificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificationsInclude<ExtArgs> | null
    /**
     * Filter, which certifications to fetch.
     */
    where?: certificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of certifications to fetch.
     */
    orderBy?: certificationsOrderByWithRelationInput | certificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for certifications.
     */
    cursor?: certificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` certifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` certifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of certifications.
     */
    distinct?: CertificationsScalarFieldEnum | CertificationsScalarFieldEnum[]
  }

  /**
   * certifications findMany
   */
  export type certificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certifications
     */
    select?: certificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certifications
     */
    omit?: certificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificationsInclude<ExtArgs> | null
    /**
     * Filter, which certifications to fetch.
     */
    where?: certificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of certifications to fetch.
     */
    orderBy?: certificationsOrderByWithRelationInput | certificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing certifications.
     */
    cursor?: certificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` certifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` certifications.
     */
    skip?: number
    distinct?: CertificationsScalarFieldEnum | CertificationsScalarFieldEnum[]
  }

  /**
   * certifications create
   */
  export type certificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certifications
     */
    select?: certificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certifications
     */
    omit?: certificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificationsInclude<ExtArgs> | null
    /**
     * The data needed to create a certifications.
     */
    data: XOR<certificationsCreateInput, certificationsUncheckedCreateInput>
  }

  /**
   * certifications createMany
   */
  export type certificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many certifications.
     */
    data: certificationsCreateManyInput | certificationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * certifications createManyAndReturn
   */
  export type certificationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certifications
     */
    select?: certificationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the certifications
     */
    omit?: certificationsOmit<ExtArgs> | null
    /**
     * The data used to create many certifications.
     */
    data: certificationsCreateManyInput | certificationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * certifications update
   */
  export type certificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certifications
     */
    select?: certificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certifications
     */
    omit?: certificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificationsInclude<ExtArgs> | null
    /**
     * The data needed to update a certifications.
     */
    data: XOR<certificationsUpdateInput, certificationsUncheckedUpdateInput>
    /**
     * Choose, which certifications to update.
     */
    where: certificationsWhereUniqueInput
  }

  /**
   * certifications updateMany
   */
  export type certificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update certifications.
     */
    data: XOR<certificationsUpdateManyMutationInput, certificationsUncheckedUpdateManyInput>
    /**
     * Filter which certifications to update
     */
    where?: certificationsWhereInput
    /**
     * Limit how many certifications to update.
     */
    limit?: number
  }

  /**
   * certifications updateManyAndReturn
   */
  export type certificationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certifications
     */
    select?: certificationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the certifications
     */
    omit?: certificationsOmit<ExtArgs> | null
    /**
     * The data used to update certifications.
     */
    data: XOR<certificationsUpdateManyMutationInput, certificationsUncheckedUpdateManyInput>
    /**
     * Filter which certifications to update
     */
    where?: certificationsWhereInput
    /**
     * Limit how many certifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificationsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * certifications upsert
   */
  export type certificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certifications
     */
    select?: certificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certifications
     */
    omit?: certificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificationsInclude<ExtArgs> | null
    /**
     * The filter to search for the certifications to update in case it exists.
     */
    where: certificationsWhereUniqueInput
    /**
     * In case the certifications found by the `where` argument doesn't exist, create a new certifications with this data.
     */
    create: XOR<certificationsCreateInput, certificationsUncheckedCreateInput>
    /**
     * In case the certifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<certificationsUpdateInput, certificationsUncheckedUpdateInput>
  }

  /**
   * certifications delete
   */
  export type certificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certifications
     */
    select?: certificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certifications
     */
    omit?: certificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificationsInclude<ExtArgs> | null
    /**
     * Filter which certifications to delete.
     */
    where: certificationsWhereUniqueInput
  }

  /**
   * certifications deleteMany
   */
  export type certificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which certifications to delete
     */
    where?: certificationsWhereInput
    /**
     * Limit how many certifications to delete.
     */
    limit?: number
  }

  /**
   * certifications without action
   */
  export type certificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certifications
     */
    select?: certificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certifications
     */
    omit?: certificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificationsInclude<ExtArgs> | null
  }


  /**
   * Model visa_information
   */

  export type AggregateVisa_information = {
    _count: Visa_informationCountAggregateOutputType | null
    _avg: Visa_informationAvgAggregateOutputType | null
    _sum: Visa_informationSumAggregateOutputType | null
    _min: Visa_informationMinAggregateOutputType | null
    _max: Visa_informationMaxAggregateOutputType | null
  }

  export type Visa_informationAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Visa_informationSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Visa_informationMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    visa_type: string | null
    country: string | null
    status: string | null
    expiry__date: Date | null
    is_multiple_entry: boolean | null
    notes: string | null
  }

  export type Visa_informationMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    visa_type: string | null
    country: string | null
    status: string | null
    expiry__date: Date | null
    is_multiple_entry: boolean | null
    notes: string | null
  }

  export type Visa_informationCountAggregateOutputType = {
    id: number
    user_id: number
    visa_type: number
    country: number
    status: number
    expiry__date: number
    is_multiple_entry: number
    notes: number
    _all: number
  }


  export type Visa_informationAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Visa_informationSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Visa_informationMinAggregateInputType = {
    id?: true
    user_id?: true
    visa_type?: true
    country?: true
    status?: true
    expiry__date?: true
    is_multiple_entry?: true
    notes?: true
  }

  export type Visa_informationMaxAggregateInputType = {
    id?: true
    user_id?: true
    visa_type?: true
    country?: true
    status?: true
    expiry__date?: true
    is_multiple_entry?: true
    notes?: true
  }

  export type Visa_informationCountAggregateInputType = {
    id?: true
    user_id?: true
    visa_type?: true
    country?: true
    status?: true
    expiry__date?: true
    is_multiple_entry?: true
    notes?: true
    _all?: true
  }

  export type Visa_informationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which visa_information to aggregate.
     */
    where?: visa_informationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of visa_informations to fetch.
     */
    orderBy?: visa_informationOrderByWithRelationInput | visa_informationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: visa_informationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` visa_informations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` visa_informations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned visa_informations
    **/
    _count?: true | Visa_informationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Visa_informationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Visa_informationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Visa_informationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Visa_informationMaxAggregateInputType
  }

  export type GetVisa_informationAggregateType<T extends Visa_informationAggregateArgs> = {
        [P in keyof T & keyof AggregateVisa_information]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVisa_information[P]>
      : GetScalarType<T[P], AggregateVisa_information[P]>
  }




  export type visa_informationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: visa_informationWhereInput
    orderBy?: visa_informationOrderByWithAggregationInput | visa_informationOrderByWithAggregationInput[]
    by: Visa_informationScalarFieldEnum[] | Visa_informationScalarFieldEnum
    having?: visa_informationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Visa_informationCountAggregateInputType | true
    _avg?: Visa_informationAvgAggregateInputType
    _sum?: Visa_informationSumAggregateInputType
    _min?: Visa_informationMinAggregateInputType
    _max?: Visa_informationMaxAggregateInputType
  }

  export type Visa_informationGroupByOutputType = {
    id: number
    user_id: number
    visa_type: string
    country: string
    status: string
    expiry__date: Date
    is_multiple_entry: boolean
    notes: string
    _count: Visa_informationCountAggregateOutputType | null
    _avg: Visa_informationAvgAggregateOutputType | null
    _sum: Visa_informationSumAggregateOutputType | null
    _min: Visa_informationMinAggregateOutputType | null
    _max: Visa_informationMaxAggregateOutputType | null
  }

  type GetVisa_informationGroupByPayload<T extends visa_informationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Visa_informationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Visa_informationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Visa_informationGroupByOutputType[P]>
            : GetScalarType<T[P], Visa_informationGroupByOutputType[P]>
        }
      >
    >


  export type visa_informationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    visa_type?: boolean
    country?: boolean
    status?: boolean
    expiry__date?: boolean
    is_multiple_entry?: boolean
    notes?: boolean
    visa?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visa_information"]>

  export type visa_informationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    visa_type?: boolean
    country?: boolean
    status?: boolean
    expiry__date?: boolean
    is_multiple_entry?: boolean
    notes?: boolean
    visa?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visa_information"]>

  export type visa_informationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    visa_type?: boolean
    country?: boolean
    status?: boolean
    expiry__date?: boolean
    is_multiple_entry?: boolean
    notes?: boolean
    visa?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visa_information"]>

  export type visa_informationSelectScalar = {
    id?: boolean
    user_id?: boolean
    visa_type?: boolean
    country?: boolean
    status?: boolean
    expiry__date?: boolean
    is_multiple_entry?: boolean
    notes?: boolean
  }

  export type visa_informationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "visa_type" | "country" | "status" | "expiry__date" | "is_multiple_entry" | "notes", ExtArgs["result"]["visa_information"]>
  export type visa_informationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visa?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type visa_informationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visa?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type visa_informationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visa?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $visa_informationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "visa_information"
    objects: {
      visa: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      visa_type: string
      country: string
      status: string
      expiry__date: Date
      is_multiple_entry: boolean
      notes: string
    }, ExtArgs["result"]["visa_information"]>
    composites: {}
  }

  type visa_informationGetPayload<S extends boolean | null | undefined | visa_informationDefaultArgs> = $Result.GetResult<Prisma.$visa_informationPayload, S>

  type visa_informationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<visa_informationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Visa_informationCountAggregateInputType | true
    }

  export interface visa_informationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['visa_information'], meta: { name: 'visa_information' } }
    /**
     * Find zero or one Visa_information that matches the filter.
     * @param {visa_informationFindUniqueArgs} args - Arguments to find a Visa_information
     * @example
     * // Get one Visa_information
     * const visa_information = await prisma.visa_information.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends visa_informationFindUniqueArgs>(args: SelectSubset<T, visa_informationFindUniqueArgs<ExtArgs>>): Prisma__visa_informationClient<$Result.GetResult<Prisma.$visa_informationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Visa_information that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {visa_informationFindUniqueOrThrowArgs} args - Arguments to find a Visa_information
     * @example
     * // Get one Visa_information
     * const visa_information = await prisma.visa_information.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends visa_informationFindUniqueOrThrowArgs>(args: SelectSubset<T, visa_informationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__visa_informationClient<$Result.GetResult<Prisma.$visa_informationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Visa_information that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {visa_informationFindFirstArgs} args - Arguments to find a Visa_information
     * @example
     * // Get one Visa_information
     * const visa_information = await prisma.visa_information.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends visa_informationFindFirstArgs>(args?: SelectSubset<T, visa_informationFindFirstArgs<ExtArgs>>): Prisma__visa_informationClient<$Result.GetResult<Prisma.$visa_informationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Visa_information that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {visa_informationFindFirstOrThrowArgs} args - Arguments to find a Visa_information
     * @example
     * // Get one Visa_information
     * const visa_information = await prisma.visa_information.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends visa_informationFindFirstOrThrowArgs>(args?: SelectSubset<T, visa_informationFindFirstOrThrowArgs<ExtArgs>>): Prisma__visa_informationClient<$Result.GetResult<Prisma.$visa_informationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Visa_informations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {visa_informationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Visa_informations
     * const visa_informations = await prisma.visa_information.findMany()
     * 
     * // Get first 10 Visa_informations
     * const visa_informations = await prisma.visa_information.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const visa_informationWithIdOnly = await prisma.visa_information.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends visa_informationFindManyArgs>(args?: SelectSubset<T, visa_informationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$visa_informationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Visa_information.
     * @param {visa_informationCreateArgs} args - Arguments to create a Visa_information.
     * @example
     * // Create one Visa_information
     * const Visa_information = await prisma.visa_information.create({
     *   data: {
     *     // ... data to create a Visa_information
     *   }
     * })
     * 
     */
    create<T extends visa_informationCreateArgs>(args: SelectSubset<T, visa_informationCreateArgs<ExtArgs>>): Prisma__visa_informationClient<$Result.GetResult<Prisma.$visa_informationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Visa_informations.
     * @param {visa_informationCreateManyArgs} args - Arguments to create many Visa_informations.
     * @example
     * // Create many Visa_informations
     * const visa_information = await prisma.visa_information.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends visa_informationCreateManyArgs>(args?: SelectSubset<T, visa_informationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Visa_informations and returns the data saved in the database.
     * @param {visa_informationCreateManyAndReturnArgs} args - Arguments to create many Visa_informations.
     * @example
     * // Create many Visa_informations
     * const visa_information = await prisma.visa_information.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Visa_informations and only return the `id`
     * const visa_informationWithIdOnly = await prisma.visa_information.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends visa_informationCreateManyAndReturnArgs>(args?: SelectSubset<T, visa_informationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$visa_informationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Visa_information.
     * @param {visa_informationDeleteArgs} args - Arguments to delete one Visa_information.
     * @example
     * // Delete one Visa_information
     * const Visa_information = await prisma.visa_information.delete({
     *   where: {
     *     // ... filter to delete one Visa_information
     *   }
     * })
     * 
     */
    delete<T extends visa_informationDeleteArgs>(args: SelectSubset<T, visa_informationDeleteArgs<ExtArgs>>): Prisma__visa_informationClient<$Result.GetResult<Prisma.$visa_informationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Visa_information.
     * @param {visa_informationUpdateArgs} args - Arguments to update one Visa_information.
     * @example
     * // Update one Visa_information
     * const visa_information = await prisma.visa_information.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends visa_informationUpdateArgs>(args: SelectSubset<T, visa_informationUpdateArgs<ExtArgs>>): Prisma__visa_informationClient<$Result.GetResult<Prisma.$visa_informationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Visa_informations.
     * @param {visa_informationDeleteManyArgs} args - Arguments to filter Visa_informations to delete.
     * @example
     * // Delete a few Visa_informations
     * const { count } = await prisma.visa_information.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends visa_informationDeleteManyArgs>(args?: SelectSubset<T, visa_informationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Visa_informations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {visa_informationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Visa_informations
     * const visa_information = await prisma.visa_information.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends visa_informationUpdateManyArgs>(args: SelectSubset<T, visa_informationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Visa_informations and returns the data updated in the database.
     * @param {visa_informationUpdateManyAndReturnArgs} args - Arguments to update many Visa_informations.
     * @example
     * // Update many Visa_informations
     * const visa_information = await prisma.visa_information.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Visa_informations and only return the `id`
     * const visa_informationWithIdOnly = await prisma.visa_information.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends visa_informationUpdateManyAndReturnArgs>(args: SelectSubset<T, visa_informationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$visa_informationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Visa_information.
     * @param {visa_informationUpsertArgs} args - Arguments to update or create a Visa_information.
     * @example
     * // Update or create a Visa_information
     * const visa_information = await prisma.visa_information.upsert({
     *   create: {
     *     // ... data to create a Visa_information
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Visa_information we want to update
     *   }
     * })
     */
    upsert<T extends visa_informationUpsertArgs>(args: SelectSubset<T, visa_informationUpsertArgs<ExtArgs>>): Prisma__visa_informationClient<$Result.GetResult<Prisma.$visa_informationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Visa_informations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {visa_informationCountArgs} args - Arguments to filter Visa_informations to count.
     * @example
     * // Count the number of Visa_informations
     * const count = await prisma.visa_information.count({
     *   where: {
     *     // ... the filter for the Visa_informations we want to count
     *   }
     * })
    **/
    count<T extends visa_informationCountArgs>(
      args?: Subset<T, visa_informationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Visa_informationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Visa_information.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Visa_informationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Visa_informationAggregateArgs>(args: Subset<T, Visa_informationAggregateArgs>): Prisma.PrismaPromise<GetVisa_informationAggregateType<T>>

    /**
     * Group by Visa_information.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {visa_informationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends visa_informationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: visa_informationGroupByArgs['orderBy'] }
        : { orderBy?: visa_informationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, visa_informationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVisa_informationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the visa_information model
   */
  readonly fields: visa_informationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for visa_information.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__visa_informationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    visa<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the visa_information model
   */
  interface visa_informationFieldRefs {
    readonly id: FieldRef<"visa_information", 'Int'>
    readonly user_id: FieldRef<"visa_information", 'Int'>
    readonly visa_type: FieldRef<"visa_information", 'String'>
    readonly country: FieldRef<"visa_information", 'String'>
    readonly status: FieldRef<"visa_information", 'String'>
    readonly expiry__date: FieldRef<"visa_information", 'DateTime'>
    readonly is_multiple_entry: FieldRef<"visa_information", 'Boolean'>
    readonly notes: FieldRef<"visa_information", 'String'>
  }
    

  // Custom InputTypes
  /**
   * visa_information findUnique
   */
  export type visa_informationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the visa_information
     */
    select?: visa_informationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the visa_information
     */
    omit?: visa_informationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: visa_informationInclude<ExtArgs> | null
    /**
     * Filter, which visa_information to fetch.
     */
    where: visa_informationWhereUniqueInput
  }

  /**
   * visa_information findUniqueOrThrow
   */
  export type visa_informationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the visa_information
     */
    select?: visa_informationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the visa_information
     */
    omit?: visa_informationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: visa_informationInclude<ExtArgs> | null
    /**
     * Filter, which visa_information to fetch.
     */
    where: visa_informationWhereUniqueInput
  }

  /**
   * visa_information findFirst
   */
  export type visa_informationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the visa_information
     */
    select?: visa_informationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the visa_information
     */
    omit?: visa_informationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: visa_informationInclude<ExtArgs> | null
    /**
     * Filter, which visa_information to fetch.
     */
    where?: visa_informationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of visa_informations to fetch.
     */
    orderBy?: visa_informationOrderByWithRelationInput | visa_informationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for visa_informations.
     */
    cursor?: visa_informationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` visa_informations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` visa_informations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of visa_informations.
     */
    distinct?: Visa_informationScalarFieldEnum | Visa_informationScalarFieldEnum[]
  }

  /**
   * visa_information findFirstOrThrow
   */
  export type visa_informationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the visa_information
     */
    select?: visa_informationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the visa_information
     */
    omit?: visa_informationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: visa_informationInclude<ExtArgs> | null
    /**
     * Filter, which visa_information to fetch.
     */
    where?: visa_informationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of visa_informations to fetch.
     */
    orderBy?: visa_informationOrderByWithRelationInput | visa_informationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for visa_informations.
     */
    cursor?: visa_informationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` visa_informations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` visa_informations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of visa_informations.
     */
    distinct?: Visa_informationScalarFieldEnum | Visa_informationScalarFieldEnum[]
  }

  /**
   * visa_information findMany
   */
  export type visa_informationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the visa_information
     */
    select?: visa_informationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the visa_information
     */
    omit?: visa_informationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: visa_informationInclude<ExtArgs> | null
    /**
     * Filter, which visa_informations to fetch.
     */
    where?: visa_informationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of visa_informations to fetch.
     */
    orderBy?: visa_informationOrderByWithRelationInput | visa_informationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing visa_informations.
     */
    cursor?: visa_informationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` visa_informations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` visa_informations.
     */
    skip?: number
    distinct?: Visa_informationScalarFieldEnum | Visa_informationScalarFieldEnum[]
  }

  /**
   * visa_information create
   */
  export type visa_informationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the visa_information
     */
    select?: visa_informationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the visa_information
     */
    omit?: visa_informationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: visa_informationInclude<ExtArgs> | null
    /**
     * The data needed to create a visa_information.
     */
    data: XOR<visa_informationCreateInput, visa_informationUncheckedCreateInput>
  }

  /**
   * visa_information createMany
   */
  export type visa_informationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many visa_informations.
     */
    data: visa_informationCreateManyInput | visa_informationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * visa_information createManyAndReturn
   */
  export type visa_informationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the visa_information
     */
    select?: visa_informationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the visa_information
     */
    omit?: visa_informationOmit<ExtArgs> | null
    /**
     * The data used to create many visa_informations.
     */
    data: visa_informationCreateManyInput | visa_informationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: visa_informationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * visa_information update
   */
  export type visa_informationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the visa_information
     */
    select?: visa_informationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the visa_information
     */
    omit?: visa_informationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: visa_informationInclude<ExtArgs> | null
    /**
     * The data needed to update a visa_information.
     */
    data: XOR<visa_informationUpdateInput, visa_informationUncheckedUpdateInput>
    /**
     * Choose, which visa_information to update.
     */
    where: visa_informationWhereUniqueInput
  }

  /**
   * visa_information updateMany
   */
  export type visa_informationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update visa_informations.
     */
    data: XOR<visa_informationUpdateManyMutationInput, visa_informationUncheckedUpdateManyInput>
    /**
     * Filter which visa_informations to update
     */
    where?: visa_informationWhereInput
    /**
     * Limit how many visa_informations to update.
     */
    limit?: number
  }

  /**
   * visa_information updateManyAndReturn
   */
  export type visa_informationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the visa_information
     */
    select?: visa_informationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the visa_information
     */
    omit?: visa_informationOmit<ExtArgs> | null
    /**
     * The data used to update visa_informations.
     */
    data: XOR<visa_informationUpdateManyMutationInput, visa_informationUncheckedUpdateManyInput>
    /**
     * Filter which visa_informations to update
     */
    where?: visa_informationWhereInput
    /**
     * Limit how many visa_informations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: visa_informationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * visa_information upsert
   */
  export type visa_informationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the visa_information
     */
    select?: visa_informationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the visa_information
     */
    omit?: visa_informationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: visa_informationInclude<ExtArgs> | null
    /**
     * The filter to search for the visa_information to update in case it exists.
     */
    where: visa_informationWhereUniqueInput
    /**
     * In case the visa_information found by the `where` argument doesn't exist, create a new visa_information with this data.
     */
    create: XOR<visa_informationCreateInput, visa_informationUncheckedCreateInput>
    /**
     * In case the visa_information was found with the provided `where` argument, update it with this data.
     */
    update: XOR<visa_informationUpdateInput, visa_informationUncheckedUpdateInput>
  }

  /**
   * visa_information delete
   */
  export type visa_informationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the visa_information
     */
    select?: visa_informationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the visa_information
     */
    omit?: visa_informationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: visa_informationInclude<ExtArgs> | null
    /**
     * Filter which visa_information to delete.
     */
    where: visa_informationWhereUniqueInput
  }

  /**
   * visa_information deleteMany
   */
  export type visa_informationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which visa_informations to delete
     */
    where?: visa_informationWhereInput
    /**
     * Limit how many visa_informations to delete.
     */
    limit?: number
  }

  /**
   * visa_information without action
   */
  export type visa_informationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the visa_information
     */
    select?: visa_informationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the visa_information
     */
    omit?: visa_informationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: visa_informationInclude<ExtArgs> | null
  }


  /**
   * Model companies
   */

  export type AggregateCompanies = {
    _count: CompaniesCountAggregateOutputType | null
    _avg: CompaniesAvgAggregateOutputType | null
    _sum: CompaniesSumAggregateOutputType | null
    _min: CompaniesMinAggregateOutputType | null
    _max: CompaniesMaxAggregateOutputType | null
  }

  export type CompaniesAvgAggregateOutputType = {
    id: number | null
    founded_year: number | null
  }

  export type CompaniesSumAggregateOutputType = {
    id: number | null
    founded_year: number | null
  }

  export type CompaniesMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    industry: string | null
    founded_year: number | null
    website_url: string | null
    logo_url: string | null
    headquarters_country: string | null
    company_siz: $Enums.companySize | null
    is_verified: boolean | null
    created_at: Date | null
  }

  export type CompaniesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    industry: string | null
    founded_year: number | null
    website_url: string | null
    logo_url: string | null
    headquarters_country: string | null
    company_siz: $Enums.companySize | null
    is_verified: boolean | null
    created_at: Date | null
  }

  export type CompaniesCountAggregateOutputType = {
    id: number
    name: number
    description: number
    industry: number
    founded_year: number
    website_url: number
    logo_url: number
    headquarters_country: number
    company_siz: number
    is_verified: number
    created_at: number
    _all: number
  }


  export type CompaniesAvgAggregateInputType = {
    id?: true
    founded_year?: true
  }

  export type CompaniesSumAggregateInputType = {
    id?: true
    founded_year?: true
  }

  export type CompaniesMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    industry?: true
    founded_year?: true
    website_url?: true
    logo_url?: true
    headquarters_country?: true
    company_siz?: true
    is_verified?: true
    created_at?: true
  }

  export type CompaniesMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    industry?: true
    founded_year?: true
    website_url?: true
    logo_url?: true
    headquarters_country?: true
    company_siz?: true
    is_verified?: true
    created_at?: true
  }

  export type CompaniesCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    industry?: true
    founded_year?: true
    website_url?: true
    logo_url?: true
    headquarters_country?: true
    company_siz?: true
    is_verified?: true
    created_at?: true
    _all?: true
  }

  export type CompaniesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which companies to aggregate.
     */
    where?: companiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companiesOrderByWithRelationInput | companiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned companies
    **/
    _count?: true | CompaniesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompaniesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompaniesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompaniesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompaniesMaxAggregateInputType
  }

  export type GetCompaniesAggregateType<T extends CompaniesAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanies[P]>
      : GetScalarType<T[P], AggregateCompanies[P]>
  }




  export type companiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: companiesWhereInput
    orderBy?: companiesOrderByWithAggregationInput | companiesOrderByWithAggregationInput[]
    by: CompaniesScalarFieldEnum[] | CompaniesScalarFieldEnum
    having?: companiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompaniesCountAggregateInputType | true
    _avg?: CompaniesAvgAggregateInputType
    _sum?: CompaniesSumAggregateInputType
    _min?: CompaniesMinAggregateInputType
    _max?: CompaniesMaxAggregateInputType
  }

  export type CompaniesGroupByOutputType = {
    id: number
    name: string
    description: string
    industry: string
    founded_year: number
    website_url: string
    logo_url: string
    headquarters_country: string
    company_siz: $Enums.companySize
    is_verified: boolean
    created_at: Date
    _count: CompaniesCountAggregateOutputType | null
    _avg: CompaniesAvgAggregateOutputType | null
    _sum: CompaniesSumAggregateOutputType | null
    _min: CompaniesMinAggregateOutputType | null
    _max: CompaniesMaxAggregateOutputType | null
  }

  type GetCompaniesGroupByPayload<T extends companiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompaniesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompaniesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompaniesGroupByOutputType[P]>
            : GetScalarType<T[P], CompaniesGroupByOutputType[P]>
        }
      >
    >


  export type companiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    industry?: boolean
    founded_year?: boolean
    website_url?: boolean
    logo_url?: boolean
    headquarters_country?: boolean
    company_siz?: boolean
    is_verified?: boolean
    created_at?: boolean
    companies?: boolean | companies$companiesArgs<ExtArgs>
    job?: boolean | companies$jobArgs<ExtArgs>
    contacts?: boolean | companies$contactsArgs<ExtArgs>
    _count?: boolean | CompaniesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companies"]>

  export type companiesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    industry?: boolean
    founded_year?: boolean
    website_url?: boolean
    logo_url?: boolean
    headquarters_country?: boolean
    company_siz?: boolean
    is_verified?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["companies"]>

  export type companiesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    industry?: boolean
    founded_year?: boolean
    website_url?: boolean
    logo_url?: boolean
    headquarters_country?: boolean
    company_siz?: boolean
    is_verified?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["companies"]>

  export type companiesSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    industry?: boolean
    founded_year?: boolean
    website_url?: boolean
    logo_url?: boolean
    headquarters_country?: boolean
    company_siz?: boolean
    is_verified?: boolean
    created_at?: boolean
  }

  export type companiesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "industry" | "founded_year" | "website_url" | "logo_url" | "headquarters_country" | "company_siz" | "is_verified" | "created_at", ExtArgs["result"]["companies"]>
  export type companiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | companies$companiesArgs<ExtArgs>
    job?: boolean | companies$jobArgs<ExtArgs>
    contacts?: boolean | companies$contactsArgs<ExtArgs>
    _count?: boolean | CompaniesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type companiesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type companiesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $companiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "companies"
    objects: {
      companies: Prisma.$company_locationsPayload<ExtArgs>[]
      job: Prisma.$jobsPayload<ExtArgs>[]
      contacts: Prisma.$contactsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string
      industry: string
      founded_year: number
      website_url: string
      logo_url: string
      headquarters_country: string
      company_siz: $Enums.companySize
      is_verified: boolean
      created_at: Date
    }, ExtArgs["result"]["companies"]>
    composites: {}
  }

  type companiesGetPayload<S extends boolean | null | undefined | companiesDefaultArgs> = $Result.GetResult<Prisma.$companiesPayload, S>

  type companiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<companiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompaniesCountAggregateInputType | true
    }

  export interface companiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['companies'], meta: { name: 'companies' } }
    /**
     * Find zero or one Companies that matches the filter.
     * @param {companiesFindUniqueArgs} args - Arguments to find a Companies
     * @example
     * // Get one Companies
     * const companies = await prisma.companies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends companiesFindUniqueArgs>(args: SelectSubset<T, companiesFindUniqueArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Companies that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {companiesFindUniqueOrThrowArgs} args - Arguments to find a Companies
     * @example
     * // Get one Companies
     * const companies = await prisma.companies.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends companiesFindUniqueOrThrowArgs>(args: SelectSubset<T, companiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesFindFirstArgs} args - Arguments to find a Companies
     * @example
     * // Get one Companies
     * const companies = await prisma.companies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends companiesFindFirstArgs>(args?: SelectSubset<T, companiesFindFirstArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Companies that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesFindFirstOrThrowArgs} args - Arguments to find a Companies
     * @example
     * // Get one Companies
     * const companies = await prisma.companies.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends companiesFindFirstOrThrowArgs>(args?: SelectSubset<T, companiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.companies.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.companies.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companiesWithIdOnly = await prisma.companies.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends companiesFindManyArgs>(args?: SelectSubset<T, companiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Companies.
     * @param {companiesCreateArgs} args - Arguments to create a Companies.
     * @example
     * // Create one Companies
     * const Companies = await prisma.companies.create({
     *   data: {
     *     // ... data to create a Companies
     *   }
     * })
     * 
     */
    create<T extends companiesCreateArgs>(args: SelectSubset<T, companiesCreateArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Companies.
     * @param {companiesCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const companies = await prisma.companies.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends companiesCreateManyArgs>(args?: SelectSubset<T, companiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {companiesCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const companies = await prisma.companies.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `id`
     * const companiesWithIdOnly = await prisma.companies.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends companiesCreateManyAndReturnArgs>(args?: SelectSubset<T, companiesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Companies.
     * @param {companiesDeleteArgs} args - Arguments to delete one Companies.
     * @example
     * // Delete one Companies
     * const Companies = await prisma.companies.delete({
     *   where: {
     *     // ... filter to delete one Companies
     *   }
     * })
     * 
     */
    delete<T extends companiesDeleteArgs>(args: SelectSubset<T, companiesDeleteArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Companies.
     * @param {companiesUpdateArgs} args - Arguments to update one Companies.
     * @example
     * // Update one Companies
     * const companies = await prisma.companies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends companiesUpdateArgs>(args: SelectSubset<T, companiesUpdateArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Companies.
     * @param {companiesDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.companies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends companiesDeleteManyArgs>(args?: SelectSubset<T, companiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const companies = await prisma.companies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends companiesUpdateManyArgs>(args: SelectSubset<T, companiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies and returns the data updated in the database.
     * @param {companiesUpdateManyAndReturnArgs} args - Arguments to update many Companies.
     * @example
     * // Update many Companies
     * const companies = await prisma.companies.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Companies and only return the `id`
     * const companiesWithIdOnly = await prisma.companies.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends companiesUpdateManyAndReturnArgs>(args: SelectSubset<T, companiesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Companies.
     * @param {companiesUpsertArgs} args - Arguments to update or create a Companies.
     * @example
     * // Update or create a Companies
     * const companies = await prisma.companies.upsert({
     *   create: {
     *     // ... data to create a Companies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Companies we want to update
     *   }
     * })
     */
    upsert<T extends companiesUpsertArgs>(args: SelectSubset<T, companiesUpsertArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.companies.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends companiesCountArgs>(
      args?: Subset<T, companiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompaniesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompaniesAggregateArgs>(args: Subset<T, CompaniesAggregateArgs>): Prisma.PrismaPromise<GetCompaniesAggregateType<T>>

    /**
     * Group by Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends companiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: companiesGroupByArgs['orderBy'] }
        : { orderBy?: companiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, companiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompaniesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the companies model
   */
  readonly fields: companiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for companies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__companiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    companies<T extends companies$companiesArgs<ExtArgs> = {}>(args?: Subset<T, companies$companiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_locationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    job<T extends companies$jobArgs<ExtArgs> = {}>(args?: Subset<T, companies$jobArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contacts<T extends companies$contactsArgs<ExtArgs> = {}>(args?: Subset<T, companies$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the companies model
   */
  interface companiesFieldRefs {
    readonly id: FieldRef<"companies", 'Int'>
    readonly name: FieldRef<"companies", 'String'>
    readonly description: FieldRef<"companies", 'String'>
    readonly industry: FieldRef<"companies", 'String'>
    readonly founded_year: FieldRef<"companies", 'Int'>
    readonly website_url: FieldRef<"companies", 'String'>
    readonly logo_url: FieldRef<"companies", 'String'>
    readonly headquarters_country: FieldRef<"companies", 'String'>
    readonly company_siz: FieldRef<"companies", 'companySize'>
    readonly is_verified: FieldRef<"companies", 'Boolean'>
    readonly created_at: FieldRef<"companies", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * companies findUnique
   */
  export type companiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where: companiesWhereUniqueInput
  }

  /**
   * companies findUniqueOrThrow
   */
  export type companiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where: companiesWhereUniqueInput
  }

  /**
   * companies findFirst
   */
  export type companiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where?: companiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companiesOrderByWithRelationInput | companiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companies.
     */
    cursor?: companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companies.
     */
    distinct?: CompaniesScalarFieldEnum | CompaniesScalarFieldEnum[]
  }

  /**
   * companies findFirstOrThrow
   */
  export type companiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where?: companiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companiesOrderByWithRelationInput | companiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companies.
     */
    cursor?: companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companies.
     */
    distinct?: CompaniesScalarFieldEnum | CompaniesScalarFieldEnum[]
  }

  /**
   * companies findMany
   */
  export type companiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where?: companiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companiesOrderByWithRelationInput | companiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing companies.
     */
    cursor?: companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    distinct?: CompaniesScalarFieldEnum | CompaniesScalarFieldEnum[]
  }

  /**
   * companies create
   */
  export type companiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * The data needed to create a companies.
     */
    data: XOR<companiesCreateInput, companiesUncheckedCreateInput>
  }

  /**
   * companies createMany
   */
  export type companiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many companies.
     */
    data: companiesCreateManyInput | companiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * companies createManyAndReturn
   */
  export type companiesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * The data used to create many companies.
     */
    data: companiesCreateManyInput | companiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * companies update
   */
  export type companiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * The data needed to update a companies.
     */
    data: XOR<companiesUpdateInput, companiesUncheckedUpdateInput>
    /**
     * Choose, which companies to update.
     */
    where: companiesWhereUniqueInput
  }

  /**
   * companies updateMany
   */
  export type companiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update companies.
     */
    data: XOR<companiesUpdateManyMutationInput, companiesUncheckedUpdateManyInput>
    /**
     * Filter which companies to update
     */
    where?: companiesWhereInput
    /**
     * Limit how many companies to update.
     */
    limit?: number
  }

  /**
   * companies updateManyAndReturn
   */
  export type companiesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * The data used to update companies.
     */
    data: XOR<companiesUpdateManyMutationInput, companiesUncheckedUpdateManyInput>
    /**
     * Filter which companies to update
     */
    where?: companiesWhereInput
    /**
     * Limit how many companies to update.
     */
    limit?: number
  }

  /**
   * companies upsert
   */
  export type companiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * The filter to search for the companies to update in case it exists.
     */
    where: companiesWhereUniqueInput
    /**
     * In case the companies found by the `where` argument doesn't exist, create a new companies with this data.
     */
    create: XOR<companiesCreateInput, companiesUncheckedCreateInput>
    /**
     * In case the companies was found with the provided `where` argument, update it with this data.
     */
    update: XOR<companiesUpdateInput, companiesUncheckedUpdateInput>
  }

  /**
   * companies delete
   */
  export type companiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter which companies to delete.
     */
    where: companiesWhereUniqueInput
  }

  /**
   * companies deleteMany
   */
  export type companiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which companies to delete
     */
    where?: companiesWhereInput
    /**
     * Limit how many companies to delete.
     */
    limit?: number
  }

  /**
   * companies.companies
   */
  export type companies$companiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_locations
     */
    select?: company_locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_locations
     */
    omit?: company_locationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_locationsInclude<ExtArgs> | null
    where?: company_locationsWhereInput
    orderBy?: company_locationsOrderByWithRelationInput | company_locationsOrderByWithRelationInput[]
    cursor?: company_locationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Company_locationsScalarFieldEnum | Company_locationsScalarFieldEnum[]
  }

  /**
   * companies.job
   */
  export type companies$jobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobsInclude<ExtArgs> | null
    where?: jobsWhereInput
    orderBy?: jobsOrderByWithRelationInput | jobsOrderByWithRelationInput[]
    cursor?: jobsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * companies.contacts
   */
  export type companies$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contacts
     */
    omit?: contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactsInclude<ExtArgs> | null
    where?: contactsWhereInput
    orderBy?: contactsOrderByWithRelationInput | contactsOrderByWithRelationInput[]
    cursor?: contactsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactsScalarFieldEnum | ContactsScalarFieldEnum[]
  }

  /**
   * companies without action
   */
  export type companiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
  }


  /**
   * Model company_locations
   */

  export type AggregateCompany_locations = {
    _count: Company_locationsCountAggregateOutputType | null
    _avg: Company_locationsAvgAggregateOutputType | null
    _sum: Company_locationsSumAggregateOutputType | null
    _min: Company_locationsMinAggregateOutputType | null
    _max: Company_locationsMaxAggregateOutputType | null
  }

  export type Company_locationsAvgAggregateOutputType = {
    id: number | null
    company_id: number | null
  }

  export type Company_locationsSumAggregateOutputType = {
    id: number | null
    company_id: number | null
  }

  export type Company_locationsMinAggregateOutputType = {
    id: number | null
    company_id: number | null
    country: string | null
    city: string | null
    address: string | null
    is_headquarters: boolean | null
    phone_number: string | null
  }

  export type Company_locationsMaxAggregateOutputType = {
    id: number | null
    company_id: number | null
    country: string | null
    city: string | null
    address: string | null
    is_headquarters: boolean | null
    phone_number: string | null
  }

  export type Company_locationsCountAggregateOutputType = {
    id: number
    company_id: number
    country: number
    city: number
    address: number
    is_headquarters: number
    phone_number: number
    _all: number
  }


  export type Company_locationsAvgAggregateInputType = {
    id?: true
    company_id?: true
  }

  export type Company_locationsSumAggregateInputType = {
    id?: true
    company_id?: true
  }

  export type Company_locationsMinAggregateInputType = {
    id?: true
    company_id?: true
    country?: true
    city?: true
    address?: true
    is_headquarters?: true
    phone_number?: true
  }

  export type Company_locationsMaxAggregateInputType = {
    id?: true
    company_id?: true
    country?: true
    city?: true
    address?: true
    is_headquarters?: true
    phone_number?: true
  }

  export type Company_locationsCountAggregateInputType = {
    id?: true
    company_id?: true
    country?: true
    city?: true
    address?: true
    is_headquarters?: true
    phone_number?: true
    _all?: true
  }

  export type Company_locationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which company_locations to aggregate.
     */
    where?: company_locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_locations to fetch.
     */
    orderBy?: company_locationsOrderByWithRelationInput | company_locationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: company_locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned company_locations
    **/
    _count?: true | Company_locationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Company_locationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Company_locationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Company_locationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Company_locationsMaxAggregateInputType
  }

  export type GetCompany_locationsAggregateType<T extends Company_locationsAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany_locations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany_locations[P]>
      : GetScalarType<T[P], AggregateCompany_locations[P]>
  }




  export type company_locationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: company_locationsWhereInput
    orderBy?: company_locationsOrderByWithAggregationInput | company_locationsOrderByWithAggregationInput[]
    by: Company_locationsScalarFieldEnum[] | Company_locationsScalarFieldEnum
    having?: company_locationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Company_locationsCountAggregateInputType | true
    _avg?: Company_locationsAvgAggregateInputType
    _sum?: Company_locationsSumAggregateInputType
    _min?: Company_locationsMinAggregateInputType
    _max?: Company_locationsMaxAggregateInputType
  }

  export type Company_locationsGroupByOutputType = {
    id: number
    company_id: number
    country: string
    city: string
    address: string
    is_headquarters: boolean
    phone_number: string
    _count: Company_locationsCountAggregateOutputType | null
    _avg: Company_locationsAvgAggregateOutputType | null
    _sum: Company_locationsSumAggregateOutputType | null
    _min: Company_locationsMinAggregateOutputType | null
    _max: Company_locationsMaxAggregateOutputType | null
  }

  type GetCompany_locationsGroupByPayload<T extends company_locationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Company_locationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Company_locationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Company_locationsGroupByOutputType[P]>
            : GetScalarType<T[P], Company_locationsGroupByOutputType[P]>
        }
      >
    >


  export type company_locationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_id?: boolean
    country?: boolean
    city?: boolean
    address?: boolean
    is_headquarters?: boolean
    phone_number?: boolean
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company_locations"]>

  export type company_locationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_id?: boolean
    country?: boolean
    city?: boolean
    address?: boolean
    is_headquarters?: boolean
    phone_number?: boolean
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company_locations"]>

  export type company_locationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_id?: boolean
    country?: boolean
    city?: boolean
    address?: boolean
    is_headquarters?: boolean
    phone_number?: boolean
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company_locations"]>

  export type company_locationsSelectScalar = {
    id?: boolean
    company_id?: boolean
    country?: boolean
    city?: boolean
    address?: boolean
    is_headquarters?: boolean
    phone_number?: boolean
  }

  export type company_locationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "company_id" | "country" | "city" | "address" | "is_headquarters" | "phone_number", ExtArgs["result"]["company_locations"]>
  export type company_locationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }
  export type company_locationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }
  export type company_locationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }

  export type $company_locationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "company_locations"
    objects: {
      companies: Prisma.$companiesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      company_id: number
      country: string
      city: string
      address: string
      is_headquarters: boolean
      phone_number: string
    }, ExtArgs["result"]["company_locations"]>
    composites: {}
  }

  type company_locationsGetPayload<S extends boolean | null | undefined | company_locationsDefaultArgs> = $Result.GetResult<Prisma.$company_locationsPayload, S>

  type company_locationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<company_locationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Company_locationsCountAggregateInputType | true
    }

  export interface company_locationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['company_locations'], meta: { name: 'company_locations' } }
    /**
     * Find zero or one Company_locations that matches the filter.
     * @param {company_locationsFindUniqueArgs} args - Arguments to find a Company_locations
     * @example
     * // Get one Company_locations
     * const company_locations = await prisma.company_locations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends company_locationsFindUniqueArgs>(args: SelectSubset<T, company_locationsFindUniqueArgs<ExtArgs>>): Prisma__company_locationsClient<$Result.GetResult<Prisma.$company_locationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Company_locations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {company_locationsFindUniqueOrThrowArgs} args - Arguments to find a Company_locations
     * @example
     * // Get one Company_locations
     * const company_locations = await prisma.company_locations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends company_locationsFindUniqueOrThrowArgs>(args: SelectSubset<T, company_locationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__company_locationsClient<$Result.GetResult<Prisma.$company_locationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company_locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_locationsFindFirstArgs} args - Arguments to find a Company_locations
     * @example
     * // Get one Company_locations
     * const company_locations = await prisma.company_locations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends company_locationsFindFirstArgs>(args?: SelectSubset<T, company_locationsFindFirstArgs<ExtArgs>>): Prisma__company_locationsClient<$Result.GetResult<Prisma.$company_locationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company_locations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_locationsFindFirstOrThrowArgs} args - Arguments to find a Company_locations
     * @example
     * // Get one Company_locations
     * const company_locations = await prisma.company_locations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends company_locationsFindFirstOrThrowArgs>(args?: SelectSubset<T, company_locationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__company_locationsClient<$Result.GetResult<Prisma.$company_locationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Company_locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_locationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Company_locations
     * const company_locations = await prisma.company_locations.findMany()
     * 
     * // Get first 10 Company_locations
     * const company_locations = await prisma.company_locations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const company_locationsWithIdOnly = await prisma.company_locations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends company_locationsFindManyArgs>(args?: SelectSubset<T, company_locationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_locationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Company_locations.
     * @param {company_locationsCreateArgs} args - Arguments to create a Company_locations.
     * @example
     * // Create one Company_locations
     * const Company_locations = await prisma.company_locations.create({
     *   data: {
     *     // ... data to create a Company_locations
     *   }
     * })
     * 
     */
    create<T extends company_locationsCreateArgs>(args: SelectSubset<T, company_locationsCreateArgs<ExtArgs>>): Prisma__company_locationsClient<$Result.GetResult<Prisma.$company_locationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Company_locations.
     * @param {company_locationsCreateManyArgs} args - Arguments to create many Company_locations.
     * @example
     * // Create many Company_locations
     * const company_locations = await prisma.company_locations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends company_locationsCreateManyArgs>(args?: SelectSubset<T, company_locationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Company_locations and returns the data saved in the database.
     * @param {company_locationsCreateManyAndReturnArgs} args - Arguments to create many Company_locations.
     * @example
     * // Create many Company_locations
     * const company_locations = await prisma.company_locations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Company_locations and only return the `id`
     * const company_locationsWithIdOnly = await prisma.company_locations.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends company_locationsCreateManyAndReturnArgs>(args?: SelectSubset<T, company_locationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_locationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Company_locations.
     * @param {company_locationsDeleteArgs} args - Arguments to delete one Company_locations.
     * @example
     * // Delete one Company_locations
     * const Company_locations = await prisma.company_locations.delete({
     *   where: {
     *     // ... filter to delete one Company_locations
     *   }
     * })
     * 
     */
    delete<T extends company_locationsDeleteArgs>(args: SelectSubset<T, company_locationsDeleteArgs<ExtArgs>>): Prisma__company_locationsClient<$Result.GetResult<Prisma.$company_locationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Company_locations.
     * @param {company_locationsUpdateArgs} args - Arguments to update one Company_locations.
     * @example
     * // Update one Company_locations
     * const company_locations = await prisma.company_locations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends company_locationsUpdateArgs>(args: SelectSubset<T, company_locationsUpdateArgs<ExtArgs>>): Prisma__company_locationsClient<$Result.GetResult<Prisma.$company_locationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Company_locations.
     * @param {company_locationsDeleteManyArgs} args - Arguments to filter Company_locations to delete.
     * @example
     * // Delete a few Company_locations
     * const { count } = await prisma.company_locations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends company_locationsDeleteManyArgs>(args?: SelectSubset<T, company_locationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Company_locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_locationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Company_locations
     * const company_locations = await prisma.company_locations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends company_locationsUpdateManyArgs>(args: SelectSubset<T, company_locationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Company_locations and returns the data updated in the database.
     * @param {company_locationsUpdateManyAndReturnArgs} args - Arguments to update many Company_locations.
     * @example
     * // Update many Company_locations
     * const company_locations = await prisma.company_locations.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Company_locations and only return the `id`
     * const company_locationsWithIdOnly = await prisma.company_locations.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends company_locationsUpdateManyAndReturnArgs>(args: SelectSubset<T, company_locationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_locationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Company_locations.
     * @param {company_locationsUpsertArgs} args - Arguments to update or create a Company_locations.
     * @example
     * // Update or create a Company_locations
     * const company_locations = await prisma.company_locations.upsert({
     *   create: {
     *     // ... data to create a Company_locations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company_locations we want to update
     *   }
     * })
     */
    upsert<T extends company_locationsUpsertArgs>(args: SelectSubset<T, company_locationsUpsertArgs<ExtArgs>>): Prisma__company_locationsClient<$Result.GetResult<Prisma.$company_locationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Company_locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_locationsCountArgs} args - Arguments to filter Company_locations to count.
     * @example
     * // Count the number of Company_locations
     * const count = await prisma.company_locations.count({
     *   where: {
     *     // ... the filter for the Company_locations we want to count
     *   }
     * })
    **/
    count<T extends company_locationsCountArgs>(
      args?: Subset<T, company_locationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Company_locationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company_locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Company_locationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Company_locationsAggregateArgs>(args: Subset<T, Company_locationsAggregateArgs>): Prisma.PrismaPromise<GetCompany_locationsAggregateType<T>>

    /**
     * Group by Company_locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_locationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends company_locationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: company_locationsGroupByArgs['orderBy'] }
        : { orderBy?: company_locationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, company_locationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompany_locationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the company_locations model
   */
  readonly fields: company_locationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for company_locations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__company_locationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    companies<T extends companiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, companiesDefaultArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the company_locations model
   */
  interface company_locationsFieldRefs {
    readonly id: FieldRef<"company_locations", 'Int'>
    readonly company_id: FieldRef<"company_locations", 'Int'>
    readonly country: FieldRef<"company_locations", 'String'>
    readonly city: FieldRef<"company_locations", 'String'>
    readonly address: FieldRef<"company_locations", 'String'>
    readonly is_headquarters: FieldRef<"company_locations", 'Boolean'>
    readonly phone_number: FieldRef<"company_locations", 'String'>
  }
    

  // Custom InputTypes
  /**
   * company_locations findUnique
   */
  export type company_locationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_locations
     */
    select?: company_locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_locations
     */
    omit?: company_locationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_locationsInclude<ExtArgs> | null
    /**
     * Filter, which company_locations to fetch.
     */
    where: company_locationsWhereUniqueInput
  }

  /**
   * company_locations findUniqueOrThrow
   */
  export type company_locationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_locations
     */
    select?: company_locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_locations
     */
    omit?: company_locationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_locationsInclude<ExtArgs> | null
    /**
     * Filter, which company_locations to fetch.
     */
    where: company_locationsWhereUniqueInput
  }

  /**
   * company_locations findFirst
   */
  export type company_locationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_locations
     */
    select?: company_locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_locations
     */
    omit?: company_locationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_locationsInclude<ExtArgs> | null
    /**
     * Filter, which company_locations to fetch.
     */
    where?: company_locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_locations to fetch.
     */
    orderBy?: company_locationsOrderByWithRelationInput | company_locationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for company_locations.
     */
    cursor?: company_locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of company_locations.
     */
    distinct?: Company_locationsScalarFieldEnum | Company_locationsScalarFieldEnum[]
  }

  /**
   * company_locations findFirstOrThrow
   */
  export type company_locationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_locations
     */
    select?: company_locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_locations
     */
    omit?: company_locationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_locationsInclude<ExtArgs> | null
    /**
     * Filter, which company_locations to fetch.
     */
    where?: company_locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_locations to fetch.
     */
    orderBy?: company_locationsOrderByWithRelationInput | company_locationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for company_locations.
     */
    cursor?: company_locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of company_locations.
     */
    distinct?: Company_locationsScalarFieldEnum | Company_locationsScalarFieldEnum[]
  }

  /**
   * company_locations findMany
   */
  export type company_locationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_locations
     */
    select?: company_locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_locations
     */
    omit?: company_locationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_locationsInclude<ExtArgs> | null
    /**
     * Filter, which company_locations to fetch.
     */
    where?: company_locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_locations to fetch.
     */
    orderBy?: company_locationsOrderByWithRelationInput | company_locationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing company_locations.
     */
    cursor?: company_locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_locations.
     */
    skip?: number
    distinct?: Company_locationsScalarFieldEnum | Company_locationsScalarFieldEnum[]
  }

  /**
   * company_locations create
   */
  export type company_locationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_locations
     */
    select?: company_locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_locations
     */
    omit?: company_locationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_locationsInclude<ExtArgs> | null
    /**
     * The data needed to create a company_locations.
     */
    data: XOR<company_locationsCreateInput, company_locationsUncheckedCreateInput>
  }

  /**
   * company_locations createMany
   */
  export type company_locationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many company_locations.
     */
    data: company_locationsCreateManyInput | company_locationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * company_locations createManyAndReturn
   */
  export type company_locationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_locations
     */
    select?: company_locationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the company_locations
     */
    omit?: company_locationsOmit<ExtArgs> | null
    /**
     * The data used to create many company_locations.
     */
    data: company_locationsCreateManyInput | company_locationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_locationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * company_locations update
   */
  export type company_locationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_locations
     */
    select?: company_locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_locations
     */
    omit?: company_locationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_locationsInclude<ExtArgs> | null
    /**
     * The data needed to update a company_locations.
     */
    data: XOR<company_locationsUpdateInput, company_locationsUncheckedUpdateInput>
    /**
     * Choose, which company_locations to update.
     */
    where: company_locationsWhereUniqueInput
  }

  /**
   * company_locations updateMany
   */
  export type company_locationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update company_locations.
     */
    data: XOR<company_locationsUpdateManyMutationInput, company_locationsUncheckedUpdateManyInput>
    /**
     * Filter which company_locations to update
     */
    where?: company_locationsWhereInput
    /**
     * Limit how many company_locations to update.
     */
    limit?: number
  }

  /**
   * company_locations updateManyAndReturn
   */
  export type company_locationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_locations
     */
    select?: company_locationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the company_locations
     */
    omit?: company_locationsOmit<ExtArgs> | null
    /**
     * The data used to update company_locations.
     */
    data: XOR<company_locationsUpdateManyMutationInput, company_locationsUncheckedUpdateManyInput>
    /**
     * Filter which company_locations to update
     */
    where?: company_locationsWhereInput
    /**
     * Limit how many company_locations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_locationsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * company_locations upsert
   */
  export type company_locationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_locations
     */
    select?: company_locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_locations
     */
    omit?: company_locationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_locationsInclude<ExtArgs> | null
    /**
     * The filter to search for the company_locations to update in case it exists.
     */
    where: company_locationsWhereUniqueInput
    /**
     * In case the company_locations found by the `where` argument doesn't exist, create a new company_locations with this data.
     */
    create: XOR<company_locationsCreateInput, company_locationsUncheckedCreateInput>
    /**
     * In case the company_locations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<company_locationsUpdateInput, company_locationsUncheckedUpdateInput>
  }

  /**
   * company_locations delete
   */
  export type company_locationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_locations
     */
    select?: company_locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_locations
     */
    omit?: company_locationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_locationsInclude<ExtArgs> | null
    /**
     * Filter which company_locations to delete.
     */
    where: company_locationsWhereUniqueInput
  }

  /**
   * company_locations deleteMany
   */
  export type company_locationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which company_locations to delete
     */
    where?: company_locationsWhereInput
    /**
     * Limit how many company_locations to delete.
     */
    limit?: number
  }

  /**
   * company_locations without action
   */
  export type company_locationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_locations
     */
    select?: company_locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_locations
     */
    omit?: company_locationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_locationsInclude<ExtArgs> | null
  }


  /**
   * Model jobs
   */

  export type AggregateJobs = {
    _count: JobsCountAggregateOutputType | null
    _avg: JobsAvgAggregateOutputType | null
    _sum: JobsSumAggregateOutputType | null
    _min: JobsMinAggregateOutputType | null
    _max: JobsMaxAggregateOutputType | null
  }

  export type JobsAvgAggregateOutputType = {
    id: number | null
    company_id: number | null
    salary_min: number | null
    salary_max: number | null
    posted_by: number | null
    views_count: number | null
  }

  export type JobsSumAggregateOutputType = {
    id: number | null
    company_id: number | null
    salary_min: number | null
    salary_max: number | null
    posted_by: number | null
    views_count: number | null
  }

  export type JobsMinAggregateOutputType = {
    id: number | null
    company_id: number | null
    title: string | null
    description: string | null
    job_category: string | null
    job_type: $Enums.jobType | null
    location_country: string | null
    location_city: string | null
    is_relocation_assistance: boolean | null
    is_remote_possible: boolean | null
    salary_currency: string | null
    salary_min: number | null
    salary_max: number | null
    salary_period: $Enums.salaryPeriod | null
    visa_sponsorship: $Enums.visaSponsorship | null
    experience_level: $Enums.expLevel | null
    education_requirement: string | null
    posted_by: number | null
    status: $Enums.jobStatus | null
    posted_at: Date | null
    deadline: Date | null
    views_count: number | null
  }

  export type JobsMaxAggregateOutputType = {
    id: number | null
    company_id: number | null
    title: string | null
    description: string | null
    job_category: string | null
    job_type: $Enums.jobType | null
    location_country: string | null
    location_city: string | null
    is_relocation_assistance: boolean | null
    is_remote_possible: boolean | null
    salary_currency: string | null
    salary_min: number | null
    salary_max: number | null
    salary_period: $Enums.salaryPeriod | null
    visa_sponsorship: $Enums.visaSponsorship | null
    experience_level: $Enums.expLevel | null
    education_requirement: string | null
    posted_by: number | null
    status: $Enums.jobStatus | null
    posted_at: Date | null
    deadline: Date | null
    views_count: number | null
  }

  export type JobsCountAggregateOutputType = {
    id: number
    company_id: number
    title: number
    description: number
    job_category: number
    job_type: number
    location_country: number
    location_city: number
    is_relocation_assistance: number
    is_remote_possible: number
    salary_currency: number
    salary_min: number
    salary_max: number
    salary_period: number
    visa_sponsorship: number
    experience_level: number
    education_requirement: number
    posted_by: number
    status: number
    posted_at: number
    deadline: number
    views_count: number
    _all: number
  }


  export type JobsAvgAggregateInputType = {
    id?: true
    company_id?: true
    salary_min?: true
    salary_max?: true
    posted_by?: true
    views_count?: true
  }

  export type JobsSumAggregateInputType = {
    id?: true
    company_id?: true
    salary_min?: true
    salary_max?: true
    posted_by?: true
    views_count?: true
  }

  export type JobsMinAggregateInputType = {
    id?: true
    company_id?: true
    title?: true
    description?: true
    job_category?: true
    job_type?: true
    location_country?: true
    location_city?: true
    is_relocation_assistance?: true
    is_remote_possible?: true
    salary_currency?: true
    salary_min?: true
    salary_max?: true
    salary_period?: true
    visa_sponsorship?: true
    experience_level?: true
    education_requirement?: true
    posted_by?: true
    status?: true
    posted_at?: true
    deadline?: true
    views_count?: true
  }

  export type JobsMaxAggregateInputType = {
    id?: true
    company_id?: true
    title?: true
    description?: true
    job_category?: true
    job_type?: true
    location_country?: true
    location_city?: true
    is_relocation_assistance?: true
    is_remote_possible?: true
    salary_currency?: true
    salary_min?: true
    salary_max?: true
    salary_period?: true
    visa_sponsorship?: true
    experience_level?: true
    education_requirement?: true
    posted_by?: true
    status?: true
    posted_at?: true
    deadline?: true
    views_count?: true
  }

  export type JobsCountAggregateInputType = {
    id?: true
    company_id?: true
    title?: true
    description?: true
    job_category?: true
    job_type?: true
    location_country?: true
    location_city?: true
    is_relocation_assistance?: true
    is_remote_possible?: true
    salary_currency?: true
    salary_min?: true
    salary_max?: true
    salary_period?: true
    visa_sponsorship?: true
    experience_level?: true
    education_requirement?: true
    posted_by?: true
    status?: true
    posted_at?: true
    deadline?: true
    views_count?: true
    _all?: true
  }

  export type JobsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which jobs to aggregate.
     */
    where?: jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobs to fetch.
     */
    orderBy?: jobsOrderByWithRelationInput | jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned jobs
    **/
    _count?: true | JobsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobsMaxAggregateInputType
  }

  export type GetJobsAggregateType<T extends JobsAggregateArgs> = {
        [P in keyof T & keyof AggregateJobs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobs[P]>
      : GetScalarType<T[P], AggregateJobs[P]>
  }




  export type jobsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: jobsWhereInput
    orderBy?: jobsOrderByWithAggregationInput | jobsOrderByWithAggregationInput[]
    by: JobsScalarFieldEnum[] | JobsScalarFieldEnum
    having?: jobsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobsCountAggregateInputType | true
    _avg?: JobsAvgAggregateInputType
    _sum?: JobsSumAggregateInputType
    _min?: JobsMinAggregateInputType
    _max?: JobsMaxAggregateInputType
  }

  export type JobsGroupByOutputType = {
    id: number
    company_id: number
    title: string
    description: string
    job_category: string
    job_type: $Enums.jobType
    location_country: string
    location_city: string
    is_relocation_assistance: boolean
    is_remote_possible: boolean
    salary_currency: string
    salary_min: number
    salary_max: number
    salary_period: $Enums.salaryPeriod
    visa_sponsorship: $Enums.visaSponsorship
    experience_level: $Enums.expLevel
    education_requirement: string
    posted_by: number
    status: $Enums.jobStatus
    posted_at: Date
    deadline: Date
    views_count: number
    _count: JobsCountAggregateOutputType | null
    _avg: JobsAvgAggregateOutputType | null
    _sum: JobsSumAggregateOutputType | null
    _min: JobsMinAggregateOutputType | null
    _max: JobsMaxAggregateOutputType | null
  }

  type GetJobsGroupByPayload<T extends jobsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobsGroupByOutputType[P]>
            : GetScalarType<T[P], JobsGroupByOutputType[P]>
        }
      >
    >


  export type jobsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_id?: boolean
    title?: boolean
    description?: boolean
    job_category?: boolean
    job_type?: boolean
    location_country?: boolean
    location_city?: boolean
    is_relocation_assistance?: boolean
    is_remote_possible?: boolean
    salary_currency?: boolean
    salary_min?: boolean
    salary_max?: boolean
    salary_period?: boolean
    visa_sponsorship?: boolean
    experience_level?: boolean
    education_requirement?: boolean
    posted_by?: boolean
    status?: boolean
    posted_at?: boolean
    deadline?: boolean
    views_count?: boolean
    job?: boolean | companiesDefaultArgs<ExtArgs>
    requirements?: boolean | jobs$requirementsArgs<ExtArgs>
    responsibilites?: boolean | jobs$responsibilitesArgs<ExtArgs>
    benefits?: boolean | jobs$benefitsArgs<ExtArgs>
    application?: boolean | jobs$applicationArgs<ExtArgs>
    contact?: boolean | jobs$contactArgs<ExtArgs>
    savedjob?: boolean | jobs$savedjobArgs<ExtArgs>
    _count?: boolean | JobsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobs"]>

  export type jobsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_id?: boolean
    title?: boolean
    description?: boolean
    job_category?: boolean
    job_type?: boolean
    location_country?: boolean
    location_city?: boolean
    is_relocation_assistance?: boolean
    is_remote_possible?: boolean
    salary_currency?: boolean
    salary_min?: boolean
    salary_max?: boolean
    salary_period?: boolean
    visa_sponsorship?: boolean
    experience_level?: boolean
    education_requirement?: boolean
    posted_by?: boolean
    status?: boolean
    posted_at?: boolean
    deadline?: boolean
    views_count?: boolean
    job?: boolean | companiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobs"]>

  export type jobsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_id?: boolean
    title?: boolean
    description?: boolean
    job_category?: boolean
    job_type?: boolean
    location_country?: boolean
    location_city?: boolean
    is_relocation_assistance?: boolean
    is_remote_possible?: boolean
    salary_currency?: boolean
    salary_min?: boolean
    salary_max?: boolean
    salary_period?: boolean
    visa_sponsorship?: boolean
    experience_level?: boolean
    education_requirement?: boolean
    posted_by?: boolean
    status?: boolean
    posted_at?: boolean
    deadline?: boolean
    views_count?: boolean
    job?: boolean | companiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobs"]>

  export type jobsSelectScalar = {
    id?: boolean
    company_id?: boolean
    title?: boolean
    description?: boolean
    job_category?: boolean
    job_type?: boolean
    location_country?: boolean
    location_city?: boolean
    is_relocation_assistance?: boolean
    is_remote_possible?: boolean
    salary_currency?: boolean
    salary_min?: boolean
    salary_max?: boolean
    salary_period?: boolean
    visa_sponsorship?: boolean
    experience_level?: boolean
    education_requirement?: boolean
    posted_by?: boolean
    status?: boolean
    posted_at?: boolean
    deadline?: boolean
    views_count?: boolean
  }

  export type jobsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "company_id" | "title" | "description" | "job_category" | "job_type" | "location_country" | "location_city" | "is_relocation_assistance" | "is_remote_possible" | "salary_currency" | "salary_min" | "salary_max" | "salary_period" | "visa_sponsorship" | "experience_level" | "education_requirement" | "posted_by" | "status" | "posted_at" | "deadline" | "views_count", ExtArgs["result"]["jobs"]>
  export type jobsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | companiesDefaultArgs<ExtArgs>
    requirements?: boolean | jobs$requirementsArgs<ExtArgs>
    responsibilites?: boolean | jobs$responsibilitesArgs<ExtArgs>
    benefits?: boolean | jobs$benefitsArgs<ExtArgs>
    application?: boolean | jobs$applicationArgs<ExtArgs>
    contact?: boolean | jobs$contactArgs<ExtArgs>
    savedjob?: boolean | jobs$savedjobArgs<ExtArgs>
    _count?: boolean | JobsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type jobsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | companiesDefaultArgs<ExtArgs>
  }
  export type jobsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | companiesDefaultArgs<ExtArgs>
  }

  export type $jobsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "jobs"
    objects: {
      job: Prisma.$companiesPayload<ExtArgs>
      requirements: Prisma.$job_requirementsPayload<ExtArgs>[]
      responsibilites: Prisma.$job_responsibilitesPayload<ExtArgs>[]
      benefits: Prisma.$job_benefitsPayload<ExtArgs>[]
      application: Prisma.$applicationsPayload<ExtArgs>[]
      contact: Prisma.$contactsPayload<ExtArgs>[]
      savedjob: Prisma.$saved_jobsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      company_id: number
      title: string
      description: string
      job_category: string
      job_type: $Enums.jobType
      location_country: string
      location_city: string
      is_relocation_assistance: boolean
      is_remote_possible: boolean
      salary_currency: string
      salary_min: number
      salary_max: number
      salary_period: $Enums.salaryPeriod
      visa_sponsorship: $Enums.visaSponsorship
      experience_level: $Enums.expLevel
      education_requirement: string
      posted_by: number
      status: $Enums.jobStatus
      posted_at: Date
      deadline: Date
      views_count: number
    }, ExtArgs["result"]["jobs"]>
    composites: {}
  }

  type jobsGetPayload<S extends boolean | null | undefined | jobsDefaultArgs> = $Result.GetResult<Prisma.$jobsPayload, S>

  type jobsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<jobsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobsCountAggregateInputType | true
    }

  export interface jobsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['jobs'], meta: { name: 'jobs' } }
    /**
     * Find zero or one Jobs that matches the filter.
     * @param {jobsFindUniqueArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends jobsFindUniqueArgs>(args: SelectSubset<T, jobsFindUniqueArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Jobs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {jobsFindUniqueOrThrowArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends jobsFindUniqueOrThrowArgs>(args: SelectSubset<T, jobsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobsFindFirstArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends jobsFindFirstArgs>(args?: SelectSubset<T, jobsFindFirstArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Jobs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobsFindFirstOrThrowArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends jobsFindFirstOrThrowArgs>(args?: SelectSubset<T, jobsFindFirstOrThrowArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Jobs
     * const jobs = await prisma.jobs.findMany()
     * 
     * // Get first 10 Jobs
     * const jobs = await prisma.jobs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobsWithIdOnly = await prisma.jobs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends jobsFindManyArgs>(args?: SelectSubset<T, jobsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Jobs.
     * @param {jobsCreateArgs} args - Arguments to create a Jobs.
     * @example
     * // Create one Jobs
     * const Jobs = await prisma.jobs.create({
     *   data: {
     *     // ... data to create a Jobs
     *   }
     * })
     * 
     */
    create<T extends jobsCreateArgs>(args: SelectSubset<T, jobsCreateArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Jobs.
     * @param {jobsCreateManyArgs} args - Arguments to create many Jobs.
     * @example
     * // Create many Jobs
     * const jobs = await prisma.jobs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends jobsCreateManyArgs>(args?: SelectSubset<T, jobsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Jobs and returns the data saved in the database.
     * @param {jobsCreateManyAndReturnArgs} args - Arguments to create many Jobs.
     * @example
     * // Create many Jobs
     * const jobs = await prisma.jobs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Jobs and only return the `id`
     * const jobsWithIdOnly = await prisma.jobs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends jobsCreateManyAndReturnArgs>(args?: SelectSubset<T, jobsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Jobs.
     * @param {jobsDeleteArgs} args - Arguments to delete one Jobs.
     * @example
     * // Delete one Jobs
     * const Jobs = await prisma.jobs.delete({
     *   where: {
     *     // ... filter to delete one Jobs
     *   }
     * })
     * 
     */
    delete<T extends jobsDeleteArgs>(args: SelectSubset<T, jobsDeleteArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Jobs.
     * @param {jobsUpdateArgs} args - Arguments to update one Jobs.
     * @example
     * // Update one Jobs
     * const jobs = await prisma.jobs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends jobsUpdateArgs>(args: SelectSubset<T, jobsUpdateArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Jobs.
     * @param {jobsDeleteManyArgs} args - Arguments to filter Jobs to delete.
     * @example
     * // Delete a few Jobs
     * const { count } = await prisma.jobs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends jobsDeleteManyArgs>(args?: SelectSubset<T, jobsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Jobs
     * const jobs = await prisma.jobs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends jobsUpdateManyArgs>(args: SelectSubset<T, jobsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobs and returns the data updated in the database.
     * @param {jobsUpdateManyAndReturnArgs} args - Arguments to update many Jobs.
     * @example
     * // Update many Jobs
     * const jobs = await prisma.jobs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Jobs and only return the `id`
     * const jobsWithIdOnly = await prisma.jobs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends jobsUpdateManyAndReturnArgs>(args: SelectSubset<T, jobsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Jobs.
     * @param {jobsUpsertArgs} args - Arguments to update or create a Jobs.
     * @example
     * // Update or create a Jobs
     * const jobs = await prisma.jobs.upsert({
     *   create: {
     *     // ... data to create a Jobs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Jobs we want to update
     *   }
     * })
     */
    upsert<T extends jobsUpsertArgs>(args: SelectSubset<T, jobsUpsertArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobsCountArgs} args - Arguments to filter Jobs to count.
     * @example
     * // Count the number of Jobs
     * const count = await prisma.jobs.count({
     *   where: {
     *     // ... the filter for the Jobs we want to count
     *   }
     * })
    **/
    count<T extends jobsCountArgs>(
      args?: Subset<T, jobsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobsAggregateArgs>(args: Subset<T, JobsAggregateArgs>): Prisma.PrismaPromise<GetJobsAggregateType<T>>

    /**
     * Group by Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends jobsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: jobsGroupByArgs['orderBy'] }
        : { orderBy?: jobsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, jobsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the jobs model
   */
  readonly fields: jobsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for jobs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__jobsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    job<T extends companiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, companiesDefaultArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    requirements<T extends jobs$requirementsArgs<ExtArgs> = {}>(args?: Subset<T, jobs$requirementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_requirementsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    responsibilites<T extends jobs$responsibilitesArgs<ExtArgs> = {}>(args?: Subset<T, jobs$responsibilitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_responsibilitesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    benefits<T extends jobs$benefitsArgs<ExtArgs> = {}>(args?: Subset<T, jobs$benefitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_benefitsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    application<T extends jobs$applicationArgs<ExtArgs> = {}>(args?: Subset<T, jobs$applicationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$applicationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contact<T extends jobs$contactArgs<ExtArgs> = {}>(args?: Subset<T, jobs$contactArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    savedjob<T extends jobs$savedjobArgs<ExtArgs> = {}>(args?: Subset<T, jobs$savedjobArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$saved_jobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the jobs model
   */
  interface jobsFieldRefs {
    readonly id: FieldRef<"jobs", 'Int'>
    readonly company_id: FieldRef<"jobs", 'Int'>
    readonly title: FieldRef<"jobs", 'String'>
    readonly description: FieldRef<"jobs", 'String'>
    readonly job_category: FieldRef<"jobs", 'String'>
    readonly job_type: FieldRef<"jobs", 'jobType'>
    readonly location_country: FieldRef<"jobs", 'String'>
    readonly location_city: FieldRef<"jobs", 'String'>
    readonly is_relocation_assistance: FieldRef<"jobs", 'Boolean'>
    readonly is_remote_possible: FieldRef<"jobs", 'Boolean'>
    readonly salary_currency: FieldRef<"jobs", 'String'>
    readonly salary_min: FieldRef<"jobs", 'Int'>
    readonly salary_max: FieldRef<"jobs", 'Int'>
    readonly salary_period: FieldRef<"jobs", 'salaryPeriod'>
    readonly visa_sponsorship: FieldRef<"jobs", 'visaSponsorship'>
    readonly experience_level: FieldRef<"jobs", 'expLevel'>
    readonly education_requirement: FieldRef<"jobs", 'String'>
    readonly posted_by: FieldRef<"jobs", 'Int'>
    readonly status: FieldRef<"jobs", 'jobStatus'>
    readonly posted_at: FieldRef<"jobs", 'DateTime'>
    readonly deadline: FieldRef<"jobs", 'DateTime'>
    readonly views_count: FieldRef<"jobs", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * jobs findUnique
   */
  export type jobsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobsInclude<ExtArgs> | null
    /**
     * Filter, which jobs to fetch.
     */
    where: jobsWhereUniqueInput
  }

  /**
   * jobs findUniqueOrThrow
   */
  export type jobsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobsInclude<ExtArgs> | null
    /**
     * Filter, which jobs to fetch.
     */
    where: jobsWhereUniqueInput
  }

  /**
   * jobs findFirst
   */
  export type jobsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobsInclude<ExtArgs> | null
    /**
     * Filter, which jobs to fetch.
     */
    where?: jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobs to fetch.
     */
    orderBy?: jobsOrderByWithRelationInput | jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for jobs.
     */
    cursor?: jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of jobs.
     */
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * jobs findFirstOrThrow
   */
  export type jobsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobsInclude<ExtArgs> | null
    /**
     * Filter, which jobs to fetch.
     */
    where?: jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobs to fetch.
     */
    orderBy?: jobsOrderByWithRelationInput | jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for jobs.
     */
    cursor?: jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of jobs.
     */
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * jobs findMany
   */
  export type jobsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobsInclude<ExtArgs> | null
    /**
     * Filter, which jobs to fetch.
     */
    where?: jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobs to fetch.
     */
    orderBy?: jobsOrderByWithRelationInput | jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing jobs.
     */
    cursor?: jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobs.
     */
    skip?: number
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * jobs create
   */
  export type jobsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobsInclude<ExtArgs> | null
    /**
     * The data needed to create a jobs.
     */
    data: XOR<jobsCreateInput, jobsUncheckedCreateInput>
  }

  /**
   * jobs createMany
   */
  export type jobsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many jobs.
     */
    data: jobsCreateManyInput | jobsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * jobs createManyAndReturn
   */
  export type jobsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * The data used to create many jobs.
     */
    data: jobsCreateManyInput | jobsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * jobs update
   */
  export type jobsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobsInclude<ExtArgs> | null
    /**
     * The data needed to update a jobs.
     */
    data: XOR<jobsUpdateInput, jobsUncheckedUpdateInput>
    /**
     * Choose, which jobs to update.
     */
    where: jobsWhereUniqueInput
  }

  /**
   * jobs updateMany
   */
  export type jobsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update jobs.
     */
    data: XOR<jobsUpdateManyMutationInput, jobsUncheckedUpdateManyInput>
    /**
     * Filter which jobs to update
     */
    where?: jobsWhereInput
    /**
     * Limit how many jobs to update.
     */
    limit?: number
  }

  /**
   * jobs updateManyAndReturn
   */
  export type jobsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * The data used to update jobs.
     */
    data: XOR<jobsUpdateManyMutationInput, jobsUncheckedUpdateManyInput>
    /**
     * Filter which jobs to update
     */
    where?: jobsWhereInput
    /**
     * Limit how many jobs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * jobs upsert
   */
  export type jobsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobsInclude<ExtArgs> | null
    /**
     * The filter to search for the jobs to update in case it exists.
     */
    where: jobsWhereUniqueInput
    /**
     * In case the jobs found by the `where` argument doesn't exist, create a new jobs with this data.
     */
    create: XOR<jobsCreateInput, jobsUncheckedCreateInput>
    /**
     * In case the jobs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<jobsUpdateInput, jobsUncheckedUpdateInput>
  }

  /**
   * jobs delete
   */
  export type jobsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobsInclude<ExtArgs> | null
    /**
     * Filter which jobs to delete.
     */
    where: jobsWhereUniqueInput
  }

  /**
   * jobs deleteMany
   */
  export type jobsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which jobs to delete
     */
    where?: jobsWhereInput
    /**
     * Limit how many jobs to delete.
     */
    limit?: number
  }

  /**
   * jobs.requirements
   */
  export type jobs$requirementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_requirements
     */
    select?: job_requirementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_requirements
     */
    omit?: job_requirementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_requirementsInclude<ExtArgs> | null
    where?: job_requirementsWhereInput
    orderBy?: job_requirementsOrderByWithRelationInput | job_requirementsOrderByWithRelationInput[]
    cursor?: job_requirementsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Job_requirementsScalarFieldEnum | Job_requirementsScalarFieldEnum[]
  }

  /**
   * jobs.responsibilites
   */
  export type jobs$responsibilitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_responsibilites
     */
    select?: job_responsibilitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_responsibilites
     */
    omit?: job_responsibilitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_responsibilitesInclude<ExtArgs> | null
    where?: job_responsibilitesWhereInput
    orderBy?: job_responsibilitesOrderByWithRelationInput | job_responsibilitesOrderByWithRelationInput[]
    cursor?: job_responsibilitesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Job_responsibilitesScalarFieldEnum | Job_responsibilitesScalarFieldEnum[]
  }

  /**
   * jobs.benefits
   */
  export type jobs$benefitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_benefits
     */
    select?: job_benefitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_benefits
     */
    omit?: job_benefitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_benefitsInclude<ExtArgs> | null
    where?: job_benefitsWhereInput
    orderBy?: job_benefitsOrderByWithRelationInput | job_benefitsOrderByWithRelationInput[]
    cursor?: job_benefitsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Job_benefitsScalarFieldEnum | Job_benefitsScalarFieldEnum[]
  }

  /**
   * jobs.application
   */
  export type jobs$applicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applications
     */
    select?: applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applications
     */
    omit?: applicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationsInclude<ExtArgs> | null
    where?: applicationsWhereInput
    orderBy?: applicationsOrderByWithRelationInput | applicationsOrderByWithRelationInput[]
    cursor?: applicationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApplicationsScalarFieldEnum | ApplicationsScalarFieldEnum[]
  }

  /**
   * jobs.contact
   */
  export type jobs$contactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contacts
     */
    omit?: contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactsInclude<ExtArgs> | null
    where?: contactsWhereInput
    orderBy?: contactsOrderByWithRelationInput | contactsOrderByWithRelationInput[]
    cursor?: contactsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactsScalarFieldEnum | ContactsScalarFieldEnum[]
  }

  /**
   * jobs.savedjob
   */
  export type jobs$savedjobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saved_jobs
     */
    select?: saved_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saved_jobs
     */
    omit?: saved_jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saved_jobsInclude<ExtArgs> | null
    where?: saved_jobsWhereInput
    orderBy?: saved_jobsOrderByWithRelationInput | saved_jobsOrderByWithRelationInput[]
    cursor?: saved_jobsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Saved_jobsScalarFieldEnum | Saved_jobsScalarFieldEnum[]
  }

  /**
   * jobs without action
   */
  export type jobsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobsInclude<ExtArgs> | null
  }


  /**
   * Model job_requirements
   */

  export type AggregateJob_requirements = {
    _count: Job_requirementsCountAggregateOutputType | null
    _avg: Job_requirementsAvgAggregateOutputType | null
    _sum: Job_requirementsSumAggregateOutputType | null
    _min: Job_requirementsMinAggregateOutputType | null
    _max: Job_requirementsMaxAggregateOutputType | null
  }

  export type Job_requirementsAvgAggregateOutputType = {
    id: number | null
    job_id: number | null
    priority: number | null
  }

  export type Job_requirementsSumAggregateOutputType = {
    id: number | null
    job_id: number | null
    priority: number | null
  }

  export type Job_requirementsMinAggregateOutputType = {
    id: number | null
    job_id: number | null
    requirement_type: $Enums.jobRequirements | null
    requirement_text: string | null
    is_mandatory: boolean | null
    priority: number | null
  }

  export type Job_requirementsMaxAggregateOutputType = {
    id: number | null
    job_id: number | null
    requirement_type: $Enums.jobRequirements | null
    requirement_text: string | null
    is_mandatory: boolean | null
    priority: number | null
  }

  export type Job_requirementsCountAggregateOutputType = {
    id: number
    job_id: number
    requirement_type: number
    requirement_text: number
    is_mandatory: number
    priority: number
    _all: number
  }


  export type Job_requirementsAvgAggregateInputType = {
    id?: true
    job_id?: true
    priority?: true
  }

  export type Job_requirementsSumAggregateInputType = {
    id?: true
    job_id?: true
    priority?: true
  }

  export type Job_requirementsMinAggregateInputType = {
    id?: true
    job_id?: true
    requirement_type?: true
    requirement_text?: true
    is_mandatory?: true
    priority?: true
  }

  export type Job_requirementsMaxAggregateInputType = {
    id?: true
    job_id?: true
    requirement_type?: true
    requirement_text?: true
    is_mandatory?: true
    priority?: true
  }

  export type Job_requirementsCountAggregateInputType = {
    id?: true
    job_id?: true
    requirement_type?: true
    requirement_text?: true
    is_mandatory?: true
    priority?: true
    _all?: true
  }

  export type Job_requirementsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job_requirements to aggregate.
     */
    where?: job_requirementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_requirements to fetch.
     */
    orderBy?: job_requirementsOrderByWithRelationInput | job_requirementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: job_requirementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_requirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_requirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned job_requirements
    **/
    _count?: true | Job_requirementsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Job_requirementsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Job_requirementsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Job_requirementsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Job_requirementsMaxAggregateInputType
  }

  export type GetJob_requirementsAggregateType<T extends Job_requirementsAggregateArgs> = {
        [P in keyof T & keyof AggregateJob_requirements]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJob_requirements[P]>
      : GetScalarType<T[P], AggregateJob_requirements[P]>
  }




  export type job_requirementsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: job_requirementsWhereInput
    orderBy?: job_requirementsOrderByWithAggregationInput | job_requirementsOrderByWithAggregationInput[]
    by: Job_requirementsScalarFieldEnum[] | Job_requirementsScalarFieldEnum
    having?: job_requirementsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Job_requirementsCountAggregateInputType | true
    _avg?: Job_requirementsAvgAggregateInputType
    _sum?: Job_requirementsSumAggregateInputType
    _min?: Job_requirementsMinAggregateInputType
    _max?: Job_requirementsMaxAggregateInputType
  }

  export type Job_requirementsGroupByOutputType = {
    id: number
    job_id: number
    requirement_type: $Enums.jobRequirements
    requirement_text: string
    is_mandatory: boolean
    priority: number
    _count: Job_requirementsCountAggregateOutputType | null
    _avg: Job_requirementsAvgAggregateOutputType | null
    _sum: Job_requirementsSumAggregateOutputType | null
    _min: Job_requirementsMinAggregateOutputType | null
    _max: Job_requirementsMaxAggregateOutputType | null
  }

  type GetJob_requirementsGroupByPayload<T extends job_requirementsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Job_requirementsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Job_requirementsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Job_requirementsGroupByOutputType[P]>
            : GetScalarType<T[P], Job_requirementsGroupByOutputType[P]>
        }
      >
    >


  export type job_requirementsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    job_id?: boolean
    requirement_type?: boolean
    requirement_text?: boolean
    is_mandatory?: boolean
    priority?: boolean
    requirements?: boolean | jobsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job_requirements"]>

  export type job_requirementsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    job_id?: boolean
    requirement_type?: boolean
    requirement_text?: boolean
    is_mandatory?: boolean
    priority?: boolean
    requirements?: boolean | jobsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job_requirements"]>

  export type job_requirementsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    job_id?: boolean
    requirement_type?: boolean
    requirement_text?: boolean
    is_mandatory?: boolean
    priority?: boolean
    requirements?: boolean | jobsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job_requirements"]>

  export type job_requirementsSelectScalar = {
    id?: boolean
    job_id?: boolean
    requirement_type?: boolean
    requirement_text?: boolean
    is_mandatory?: boolean
    priority?: boolean
  }

  export type job_requirementsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "job_id" | "requirement_type" | "requirement_text" | "is_mandatory" | "priority", ExtArgs["result"]["job_requirements"]>
  export type job_requirementsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requirements?: boolean | jobsDefaultArgs<ExtArgs>
  }
  export type job_requirementsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requirements?: boolean | jobsDefaultArgs<ExtArgs>
  }
  export type job_requirementsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requirements?: boolean | jobsDefaultArgs<ExtArgs>
  }

  export type $job_requirementsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "job_requirements"
    objects: {
      requirements: Prisma.$jobsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      job_id: number
      requirement_type: $Enums.jobRequirements
      requirement_text: string
      is_mandatory: boolean
      priority: number
    }, ExtArgs["result"]["job_requirements"]>
    composites: {}
  }

  type job_requirementsGetPayload<S extends boolean | null | undefined | job_requirementsDefaultArgs> = $Result.GetResult<Prisma.$job_requirementsPayload, S>

  type job_requirementsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<job_requirementsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Job_requirementsCountAggregateInputType | true
    }

  export interface job_requirementsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['job_requirements'], meta: { name: 'job_requirements' } }
    /**
     * Find zero or one Job_requirements that matches the filter.
     * @param {job_requirementsFindUniqueArgs} args - Arguments to find a Job_requirements
     * @example
     * // Get one Job_requirements
     * const job_requirements = await prisma.job_requirements.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends job_requirementsFindUniqueArgs>(args: SelectSubset<T, job_requirementsFindUniqueArgs<ExtArgs>>): Prisma__job_requirementsClient<$Result.GetResult<Prisma.$job_requirementsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Job_requirements that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {job_requirementsFindUniqueOrThrowArgs} args - Arguments to find a Job_requirements
     * @example
     * // Get one Job_requirements
     * const job_requirements = await prisma.job_requirements.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends job_requirementsFindUniqueOrThrowArgs>(args: SelectSubset<T, job_requirementsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__job_requirementsClient<$Result.GetResult<Prisma.$job_requirementsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job_requirements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_requirementsFindFirstArgs} args - Arguments to find a Job_requirements
     * @example
     * // Get one Job_requirements
     * const job_requirements = await prisma.job_requirements.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends job_requirementsFindFirstArgs>(args?: SelectSubset<T, job_requirementsFindFirstArgs<ExtArgs>>): Prisma__job_requirementsClient<$Result.GetResult<Prisma.$job_requirementsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job_requirements that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_requirementsFindFirstOrThrowArgs} args - Arguments to find a Job_requirements
     * @example
     * // Get one Job_requirements
     * const job_requirements = await prisma.job_requirements.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends job_requirementsFindFirstOrThrowArgs>(args?: SelectSubset<T, job_requirementsFindFirstOrThrowArgs<ExtArgs>>): Prisma__job_requirementsClient<$Result.GetResult<Prisma.$job_requirementsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Job_requirements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_requirementsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Job_requirements
     * const job_requirements = await prisma.job_requirements.findMany()
     * 
     * // Get first 10 Job_requirements
     * const job_requirements = await prisma.job_requirements.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const job_requirementsWithIdOnly = await prisma.job_requirements.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends job_requirementsFindManyArgs>(args?: SelectSubset<T, job_requirementsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_requirementsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Job_requirements.
     * @param {job_requirementsCreateArgs} args - Arguments to create a Job_requirements.
     * @example
     * // Create one Job_requirements
     * const Job_requirements = await prisma.job_requirements.create({
     *   data: {
     *     // ... data to create a Job_requirements
     *   }
     * })
     * 
     */
    create<T extends job_requirementsCreateArgs>(args: SelectSubset<T, job_requirementsCreateArgs<ExtArgs>>): Prisma__job_requirementsClient<$Result.GetResult<Prisma.$job_requirementsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Job_requirements.
     * @param {job_requirementsCreateManyArgs} args - Arguments to create many Job_requirements.
     * @example
     * // Create many Job_requirements
     * const job_requirements = await prisma.job_requirements.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends job_requirementsCreateManyArgs>(args?: SelectSubset<T, job_requirementsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Job_requirements and returns the data saved in the database.
     * @param {job_requirementsCreateManyAndReturnArgs} args - Arguments to create many Job_requirements.
     * @example
     * // Create many Job_requirements
     * const job_requirements = await prisma.job_requirements.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Job_requirements and only return the `id`
     * const job_requirementsWithIdOnly = await prisma.job_requirements.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends job_requirementsCreateManyAndReturnArgs>(args?: SelectSubset<T, job_requirementsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_requirementsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Job_requirements.
     * @param {job_requirementsDeleteArgs} args - Arguments to delete one Job_requirements.
     * @example
     * // Delete one Job_requirements
     * const Job_requirements = await prisma.job_requirements.delete({
     *   where: {
     *     // ... filter to delete one Job_requirements
     *   }
     * })
     * 
     */
    delete<T extends job_requirementsDeleteArgs>(args: SelectSubset<T, job_requirementsDeleteArgs<ExtArgs>>): Prisma__job_requirementsClient<$Result.GetResult<Prisma.$job_requirementsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Job_requirements.
     * @param {job_requirementsUpdateArgs} args - Arguments to update one Job_requirements.
     * @example
     * // Update one Job_requirements
     * const job_requirements = await prisma.job_requirements.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends job_requirementsUpdateArgs>(args: SelectSubset<T, job_requirementsUpdateArgs<ExtArgs>>): Prisma__job_requirementsClient<$Result.GetResult<Prisma.$job_requirementsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Job_requirements.
     * @param {job_requirementsDeleteManyArgs} args - Arguments to filter Job_requirements to delete.
     * @example
     * // Delete a few Job_requirements
     * const { count } = await prisma.job_requirements.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends job_requirementsDeleteManyArgs>(args?: SelectSubset<T, job_requirementsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Job_requirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_requirementsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Job_requirements
     * const job_requirements = await prisma.job_requirements.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends job_requirementsUpdateManyArgs>(args: SelectSubset<T, job_requirementsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Job_requirements and returns the data updated in the database.
     * @param {job_requirementsUpdateManyAndReturnArgs} args - Arguments to update many Job_requirements.
     * @example
     * // Update many Job_requirements
     * const job_requirements = await prisma.job_requirements.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Job_requirements and only return the `id`
     * const job_requirementsWithIdOnly = await prisma.job_requirements.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends job_requirementsUpdateManyAndReturnArgs>(args: SelectSubset<T, job_requirementsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_requirementsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Job_requirements.
     * @param {job_requirementsUpsertArgs} args - Arguments to update or create a Job_requirements.
     * @example
     * // Update or create a Job_requirements
     * const job_requirements = await prisma.job_requirements.upsert({
     *   create: {
     *     // ... data to create a Job_requirements
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Job_requirements we want to update
     *   }
     * })
     */
    upsert<T extends job_requirementsUpsertArgs>(args: SelectSubset<T, job_requirementsUpsertArgs<ExtArgs>>): Prisma__job_requirementsClient<$Result.GetResult<Prisma.$job_requirementsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Job_requirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_requirementsCountArgs} args - Arguments to filter Job_requirements to count.
     * @example
     * // Count the number of Job_requirements
     * const count = await prisma.job_requirements.count({
     *   where: {
     *     // ... the filter for the Job_requirements we want to count
     *   }
     * })
    **/
    count<T extends job_requirementsCountArgs>(
      args?: Subset<T, job_requirementsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Job_requirementsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Job_requirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Job_requirementsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Job_requirementsAggregateArgs>(args: Subset<T, Job_requirementsAggregateArgs>): Prisma.PrismaPromise<GetJob_requirementsAggregateType<T>>

    /**
     * Group by Job_requirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_requirementsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends job_requirementsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: job_requirementsGroupByArgs['orderBy'] }
        : { orderBy?: job_requirementsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, job_requirementsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJob_requirementsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the job_requirements model
   */
  readonly fields: job_requirementsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for job_requirements.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__job_requirementsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    requirements<T extends jobsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, jobsDefaultArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the job_requirements model
   */
  interface job_requirementsFieldRefs {
    readonly id: FieldRef<"job_requirements", 'Int'>
    readonly job_id: FieldRef<"job_requirements", 'Int'>
    readonly requirement_type: FieldRef<"job_requirements", 'jobRequirements'>
    readonly requirement_text: FieldRef<"job_requirements", 'String'>
    readonly is_mandatory: FieldRef<"job_requirements", 'Boolean'>
    readonly priority: FieldRef<"job_requirements", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * job_requirements findUnique
   */
  export type job_requirementsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_requirements
     */
    select?: job_requirementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_requirements
     */
    omit?: job_requirementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_requirementsInclude<ExtArgs> | null
    /**
     * Filter, which job_requirements to fetch.
     */
    where: job_requirementsWhereUniqueInput
  }

  /**
   * job_requirements findUniqueOrThrow
   */
  export type job_requirementsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_requirements
     */
    select?: job_requirementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_requirements
     */
    omit?: job_requirementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_requirementsInclude<ExtArgs> | null
    /**
     * Filter, which job_requirements to fetch.
     */
    where: job_requirementsWhereUniqueInput
  }

  /**
   * job_requirements findFirst
   */
  export type job_requirementsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_requirements
     */
    select?: job_requirementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_requirements
     */
    omit?: job_requirementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_requirementsInclude<ExtArgs> | null
    /**
     * Filter, which job_requirements to fetch.
     */
    where?: job_requirementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_requirements to fetch.
     */
    orderBy?: job_requirementsOrderByWithRelationInput | job_requirementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for job_requirements.
     */
    cursor?: job_requirementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_requirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_requirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of job_requirements.
     */
    distinct?: Job_requirementsScalarFieldEnum | Job_requirementsScalarFieldEnum[]
  }

  /**
   * job_requirements findFirstOrThrow
   */
  export type job_requirementsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_requirements
     */
    select?: job_requirementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_requirements
     */
    omit?: job_requirementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_requirementsInclude<ExtArgs> | null
    /**
     * Filter, which job_requirements to fetch.
     */
    where?: job_requirementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_requirements to fetch.
     */
    orderBy?: job_requirementsOrderByWithRelationInput | job_requirementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for job_requirements.
     */
    cursor?: job_requirementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_requirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_requirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of job_requirements.
     */
    distinct?: Job_requirementsScalarFieldEnum | Job_requirementsScalarFieldEnum[]
  }

  /**
   * job_requirements findMany
   */
  export type job_requirementsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_requirements
     */
    select?: job_requirementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_requirements
     */
    omit?: job_requirementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_requirementsInclude<ExtArgs> | null
    /**
     * Filter, which job_requirements to fetch.
     */
    where?: job_requirementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_requirements to fetch.
     */
    orderBy?: job_requirementsOrderByWithRelationInput | job_requirementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing job_requirements.
     */
    cursor?: job_requirementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_requirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_requirements.
     */
    skip?: number
    distinct?: Job_requirementsScalarFieldEnum | Job_requirementsScalarFieldEnum[]
  }

  /**
   * job_requirements create
   */
  export type job_requirementsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_requirements
     */
    select?: job_requirementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_requirements
     */
    omit?: job_requirementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_requirementsInclude<ExtArgs> | null
    /**
     * The data needed to create a job_requirements.
     */
    data: XOR<job_requirementsCreateInput, job_requirementsUncheckedCreateInput>
  }

  /**
   * job_requirements createMany
   */
  export type job_requirementsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many job_requirements.
     */
    data: job_requirementsCreateManyInput | job_requirementsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * job_requirements createManyAndReturn
   */
  export type job_requirementsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_requirements
     */
    select?: job_requirementsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the job_requirements
     */
    omit?: job_requirementsOmit<ExtArgs> | null
    /**
     * The data used to create many job_requirements.
     */
    data: job_requirementsCreateManyInput | job_requirementsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_requirementsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * job_requirements update
   */
  export type job_requirementsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_requirements
     */
    select?: job_requirementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_requirements
     */
    omit?: job_requirementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_requirementsInclude<ExtArgs> | null
    /**
     * The data needed to update a job_requirements.
     */
    data: XOR<job_requirementsUpdateInput, job_requirementsUncheckedUpdateInput>
    /**
     * Choose, which job_requirements to update.
     */
    where: job_requirementsWhereUniqueInput
  }

  /**
   * job_requirements updateMany
   */
  export type job_requirementsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update job_requirements.
     */
    data: XOR<job_requirementsUpdateManyMutationInput, job_requirementsUncheckedUpdateManyInput>
    /**
     * Filter which job_requirements to update
     */
    where?: job_requirementsWhereInput
    /**
     * Limit how many job_requirements to update.
     */
    limit?: number
  }

  /**
   * job_requirements updateManyAndReturn
   */
  export type job_requirementsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_requirements
     */
    select?: job_requirementsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the job_requirements
     */
    omit?: job_requirementsOmit<ExtArgs> | null
    /**
     * The data used to update job_requirements.
     */
    data: XOR<job_requirementsUpdateManyMutationInput, job_requirementsUncheckedUpdateManyInput>
    /**
     * Filter which job_requirements to update
     */
    where?: job_requirementsWhereInput
    /**
     * Limit how many job_requirements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_requirementsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * job_requirements upsert
   */
  export type job_requirementsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_requirements
     */
    select?: job_requirementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_requirements
     */
    omit?: job_requirementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_requirementsInclude<ExtArgs> | null
    /**
     * The filter to search for the job_requirements to update in case it exists.
     */
    where: job_requirementsWhereUniqueInput
    /**
     * In case the job_requirements found by the `where` argument doesn't exist, create a new job_requirements with this data.
     */
    create: XOR<job_requirementsCreateInput, job_requirementsUncheckedCreateInput>
    /**
     * In case the job_requirements was found with the provided `where` argument, update it with this data.
     */
    update: XOR<job_requirementsUpdateInput, job_requirementsUncheckedUpdateInput>
  }

  /**
   * job_requirements delete
   */
  export type job_requirementsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_requirements
     */
    select?: job_requirementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_requirements
     */
    omit?: job_requirementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_requirementsInclude<ExtArgs> | null
    /**
     * Filter which job_requirements to delete.
     */
    where: job_requirementsWhereUniqueInput
  }

  /**
   * job_requirements deleteMany
   */
  export type job_requirementsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job_requirements to delete
     */
    where?: job_requirementsWhereInput
    /**
     * Limit how many job_requirements to delete.
     */
    limit?: number
  }

  /**
   * job_requirements without action
   */
  export type job_requirementsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_requirements
     */
    select?: job_requirementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_requirements
     */
    omit?: job_requirementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_requirementsInclude<ExtArgs> | null
  }


  /**
   * Model job_responsibilites
   */

  export type AggregateJob_responsibilites = {
    _count: Job_responsibilitesCountAggregateOutputType | null
    _avg: Job_responsibilitesAvgAggregateOutputType | null
    _sum: Job_responsibilitesSumAggregateOutputType | null
    _min: Job_responsibilitesMinAggregateOutputType | null
    _max: Job_responsibilitesMaxAggregateOutputType | null
  }

  export type Job_responsibilitesAvgAggregateOutputType = {
    id: number | null
    job_id: number | null
    priority: number | null
  }

  export type Job_responsibilitesSumAggregateOutputType = {
    id: number | null
    job_id: number | null
    priority: number | null
  }

  export type Job_responsibilitesMinAggregateOutputType = {
    id: number | null
    job_id: number | null
    responsibility_text: string | null
    priority: number | null
  }

  export type Job_responsibilitesMaxAggregateOutputType = {
    id: number | null
    job_id: number | null
    responsibility_text: string | null
    priority: number | null
  }

  export type Job_responsibilitesCountAggregateOutputType = {
    id: number
    job_id: number
    responsibility_text: number
    priority: number
    _all: number
  }


  export type Job_responsibilitesAvgAggregateInputType = {
    id?: true
    job_id?: true
    priority?: true
  }

  export type Job_responsibilitesSumAggregateInputType = {
    id?: true
    job_id?: true
    priority?: true
  }

  export type Job_responsibilitesMinAggregateInputType = {
    id?: true
    job_id?: true
    responsibility_text?: true
    priority?: true
  }

  export type Job_responsibilitesMaxAggregateInputType = {
    id?: true
    job_id?: true
    responsibility_text?: true
    priority?: true
  }

  export type Job_responsibilitesCountAggregateInputType = {
    id?: true
    job_id?: true
    responsibility_text?: true
    priority?: true
    _all?: true
  }

  export type Job_responsibilitesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job_responsibilites to aggregate.
     */
    where?: job_responsibilitesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_responsibilites to fetch.
     */
    orderBy?: job_responsibilitesOrderByWithRelationInput | job_responsibilitesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: job_responsibilitesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_responsibilites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_responsibilites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned job_responsibilites
    **/
    _count?: true | Job_responsibilitesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Job_responsibilitesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Job_responsibilitesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Job_responsibilitesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Job_responsibilitesMaxAggregateInputType
  }

  export type GetJob_responsibilitesAggregateType<T extends Job_responsibilitesAggregateArgs> = {
        [P in keyof T & keyof AggregateJob_responsibilites]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJob_responsibilites[P]>
      : GetScalarType<T[P], AggregateJob_responsibilites[P]>
  }




  export type job_responsibilitesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: job_responsibilitesWhereInput
    orderBy?: job_responsibilitesOrderByWithAggregationInput | job_responsibilitesOrderByWithAggregationInput[]
    by: Job_responsibilitesScalarFieldEnum[] | Job_responsibilitesScalarFieldEnum
    having?: job_responsibilitesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Job_responsibilitesCountAggregateInputType | true
    _avg?: Job_responsibilitesAvgAggregateInputType
    _sum?: Job_responsibilitesSumAggregateInputType
    _min?: Job_responsibilitesMinAggregateInputType
    _max?: Job_responsibilitesMaxAggregateInputType
  }

  export type Job_responsibilitesGroupByOutputType = {
    id: number
    job_id: number
    responsibility_text: string
    priority: number
    _count: Job_responsibilitesCountAggregateOutputType | null
    _avg: Job_responsibilitesAvgAggregateOutputType | null
    _sum: Job_responsibilitesSumAggregateOutputType | null
    _min: Job_responsibilitesMinAggregateOutputType | null
    _max: Job_responsibilitesMaxAggregateOutputType | null
  }

  type GetJob_responsibilitesGroupByPayload<T extends job_responsibilitesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Job_responsibilitesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Job_responsibilitesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Job_responsibilitesGroupByOutputType[P]>
            : GetScalarType<T[P], Job_responsibilitesGroupByOutputType[P]>
        }
      >
    >


  export type job_responsibilitesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    job_id?: boolean
    responsibility_text?: boolean
    priority?: boolean
    responsibilites?: boolean | jobsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job_responsibilites"]>

  export type job_responsibilitesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    job_id?: boolean
    responsibility_text?: boolean
    priority?: boolean
    responsibilites?: boolean | jobsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job_responsibilites"]>

  export type job_responsibilitesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    job_id?: boolean
    responsibility_text?: boolean
    priority?: boolean
    responsibilites?: boolean | jobsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job_responsibilites"]>

  export type job_responsibilitesSelectScalar = {
    id?: boolean
    job_id?: boolean
    responsibility_text?: boolean
    priority?: boolean
  }

  export type job_responsibilitesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "job_id" | "responsibility_text" | "priority", ExtArgs["result"]["job_responsibilites"]>
  export type job_responsibilitesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responsibilites?: boolean | jobsDefaultArgs<ExtArgs>
  }
  export type job_responsibilitesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responsibilites?: boolean | jobsDefaultArgs<ExtArgs>
  }
  export type job_responsibilitesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responsibilites?: boolean | jobsDefaultArgs<ExtArgs>
  }

  export type $job_responsibilitesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "job_responsibilites"
    objects: {
      responsibilites: Prisma.$jobsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      job_id: number
      responsibility_text: string
      priority: number
    }, ExtArgs["result"]["job_responsibilites"]>
    composites: {}
  }

  type job_responsibilitesGetPayload<S extends boolean | null | undefined | job_responsibilitesDefaultArgs> = $Result.GetResult<Prisma.$job_responsibilitesPayload, S>

  type job_responsibilitesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<job_responsibilitesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Job_responsibilitesCountAggregateInputType | true
    }

  export interface job_responsibilitesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['job_responsibilites'], meta: { name: 'job_responsibilites' } }
    /**
     * Find zero or one Job_responsibilites that matches the filter.
     * @param {job_responsibilitesFindUniqueArgs} args - Arguments to find a Job_responsibilites
     * @example
     * // Get one Job_responsibilites
     * const job_responsibilites = await prisma.job_responsibilites.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends job_responsibilitesFindUniqueArgs>(args: SelectSubset<T, job_responsibilitesFindUniqueArgs<ExtArgs>>): Prisma__job_responsibilitesClient<$Result.GetResult<Prisma.$job_responsibilitesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Job_responsibilites that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {job_responsibilitesFindUniqueOrThrowArgs} args - Arguments to find a Job_responsibilites
     * @example
     * // Get one Job_responsibilites
     * const job_responsibilites = await prisma.job_responsibilites.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends job_responsibilitesFindUniqueOrThrowArgs>(args: SelectSubset<T, job_responsibilitesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__job_responsibilitesClient<$Result.GetResult<Prisma.$job_responsibilitesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job_responsibilites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_responsibilitesFindFirstArgs} args - Arguments to find a Job_responsibilites
     * @example
     * // Get one Job_responsibilites
     * const job_responsibilites = await prisma.job_responsibilites.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends job_responsibilitesFindFirstArgs>(args?: SelectSubset<T, job_responsibilitesFindFirstArgs<ExtArgs>>): Prisma__job_responsibilitesClient<$Result.GetResult<Prisma.$job_responsibilitesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job_responsibilites that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_responsibilitesFindFirstOrThrowArgs} args - Arguments to find a Job_responsibilites
     * @example
     * // Get one Job_responsibilites
     * const job_responsibilites = await prisma.job_responsibilites.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends job_responsibilitesFindFirstOrThrowArgs>(args?: SelectSubset<T, job_responsibilitesFindFirstOrThrowArgs<ExtArgs>>): Prisma__job_responsibilitesClient<$Result.GetResult<Prisma.$job_responsibilitesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Job_responsibilites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_responsibilitesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Job_responsibilites
     * const job_responsibilites = await prisma.job_responsibilites.findMany()
     * 
     * // Get first 10 Job_responsibilites
     * const job_responsibilites = await prisma.job_responsibilites.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const job_responsibilitesWithIdOnly = await prisma.job_responsibilites.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends job_responsibilitesFindManyArgs>(args?: SelectSubset<T, job_responsibilitesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_responsibilitesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Job_responsibilites.
     * @param {job_responsibilitesCreateArgs} args - Arguments to create a Job_responsibilites.
     * @example
     * // Create one Job_responsibilites
     * const Job_responsibilites = await prisma.job_responsibilites.create({
     *   data: {
     *     // ... data to create a Job_responsibilites
     *   }
     * })
     * 
     */
    create<T extends job_responsibilitesCreateArgs>(args: SelectSubset<T, job_responsibilitesCreateArgs<ExtArgs>>): Prisma__job_responsibilitesClient<$Result.GetResult<Prisma.$job_responsibilitesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Job_responsibilites.
     * @param {job_responsibilitesCreateManyArgs} args - Arguments to create many Job_responsibilites.
     * @example
     * // Create many Job_responsibilites
     * const job_responsibilites = await prisma.job_responsibilites.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends job_responsibilitesCreateManyArgs>(args?: SelectSubset<T, job_responsibilitesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Job_responsibilites and returns the data saved in the database.
     * @param {job_responsibilitesCreateManyAndReturnArgs} args - Arguments to create many Job_responsibilites.
     * @example
     * // Create many Job_responsibilites
     * const job_responsibilites = await prisma.job_responsibilites.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Job_responsibilites and only return the `id`
     * const job_responsibilitesWithIdOnly = await prisma.job_responsibilites.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends job_responsibilitesCreateManyAndReturnArgs>(args?: SelectSubset<T, job_responsibilitesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_responsibilitesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Job_responsibilites.
     * @param {job_responsibilitesDeleteArgs} args - Arguments to delete one Job_responsibilites.
     * @example
     * // Delete one Job_responsibilites
     * const Job_responsibilites = await prisma.job_responsibilites.delete({
     *   where: {
     *     // ... filter to delete one Job_responsibilites
     *   }
     * })
     * 
     */
    delete<T extends job_responsibilitesDeleteArgs>(args: SelectSubset<T, job_responsibilitesDeleteArgs<ExtArgs>>): Prisma__job_responsibilitesClient<$Result.GetResult<Prisma.$job_responsibilitesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Job_responsibilites.
     * @param {job_responsibilitesUpdateArgs} args - Arguments to update one Job_responsibilites.
     * @example
     * // Update one Job_responsibilites
     * const job_responsibilites = await prisma.job_responsibilites.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends job_responsibilitesUpdateArgs>(args: SelectSubset<T, job_responsibilitesUpdateArgs<ExtArgs>>): Prisma__job_responsibilitesClient<$Result.GetResult<Prisma.$job_responsibilitesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Job_responsibilites.
     * @param {job_responsibilitesDeleteManyArgs} args - Arguments to filter Job_responsibilites to delete.
     * @example
     * // Delete a few Job_responsibilites
     * const { count } = await prisma.job_responsibilites.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends job_responsibilitesDeleteManyArgs>(args?: SelectSubset<T, job_responsibilitesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Job_responsibilites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_responsibilitesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Job_responsibilites
     * const job_responsibilites = await prisma.job_responsibilites.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends job_responsibilitesUpdateManyArgs>(args: SelectSubset<T, job_responsibilitesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Job_responsibilites and returns the data updated in the database.
     * @param {job_responsibilitesUpdateManyAndReturnArgs} args - Arguments to update many Job_responsibilites.
     * @example
     * // Update many Job_responsibilites
     * const job_responsibilites = await prisma.job_responsibilites.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Job_responsibilites and only return the `id`
     * const job_responsibilitesWithIdOnly = await prisma.job_responsibilites.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends job_responsibilitesUpdateManyAndReturnArgs>(args: SelectSubset<T, job_responsibilitesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_responsibilitesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Job_responsibilites.
     * @param {job_responsibilitesUpsertArgs} args - Arguments to update or create a Job_responsibilites.
     * @example
     * // Update or create a Job_responsibilites
     * const job_responsibilites = await prisma.job_responsibilites.upsert({
     *   create: {
     *     // ... data to create a Job_responsibilites
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Job_responsibilites we want to update
     *   }
     * })
     */
    upsert<T extends job_responsibilitesUpsertArgs>(args: SelectSubset<T, job_responsibilitesUpsertArgs<ExtArgs>>): Prisma__job_responsibilitesClient<$Result.GetResult<Prisma.$job_responsibilitesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Job_responsibilites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_responsibilitesCountArgs} args - Arguments to filter Job_responsibilites to count.
     * @example
     * // Count the number of Job_responsibilites
     * const count = await prisma.job_responsibilites.count({
     *   where: {
     *     // ... the filter for the Job_responsibilites we want to count
     *   }
     * })
    **/
    count<T extends job_responsibilitesCountArgs>(
      args?: Subset<T, job_responsibilitesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Job_responsibilitesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Job_responsibilites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Job_responsibilitesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Job_responsibilitesAggregateArgs>(args: Subset<T, Job_responsibilitesAggregateArgs>): Prisma.PrismaPromise<GetJob_responsibilitesAggregateType<T>>

    /**
     * Group by Job_responsibilites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_responsibilitesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends job_responsibilitesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: job_responsibilitesGroupByArgs['orderBy'] }
        : { orderBy?: job_responsibilitesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, job_responsibilitesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJob_responsibilitesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the job_responsibilites model
   */
  readonly fields: job_responsibilitesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for job_responsibilites.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__job_responsibilitesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    responsibilites<T extends jobsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, jobsDefaultArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the job_responsibilites model
   */
  interface job_responsibilitesFieldRefs {
    readonly id: FieldRef<"job_responsibilites", 'Int'>
    readonly job_id: FieldRef<"job_responsibilites", 'Int'>
    readonly responsibility_text: FieldRef<"job_responsibilites", 'String'>
    readonly priority: FieldRef<"job_responsibilites", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * job_responsibilites findUnique
   */
  export type job_responsibilitesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_responsibilites
     */
    select?: job_responsibilitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_responsibilites
     */
    omit?: job_responsibilitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_responsibilitesInclude<ExtArgs> | null
    /**
     * Filter, which job_responsibilites to fetch.
     */
    where: job_responsibilitesWhereUniqueInput
  }

  /**
   * job_responsibilites findUniqueOrThrow
   */
  export type job_responsibilitesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_responsibilites
     */
    select?: job_responsibilitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_responsibilites
     */
    omit?: job_responsibilitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_responsibilitesInclude<ExtArgs> | null
    /**
     * Filter, which job_responsibilites to fetch.
     */
    where: job_responsibilitesWhereUniqueInput
  }

  /**
   * job_responsibilites findFirst
   */
  export type job_responsibilitesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_responsibilites
     */
    select?: job_responsibilitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_responsibilites
     */
    omit?: job_responsibilitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_responsibilitesInclude<ExtArgs> | null
    /**
     * Filter, which job_responsibilites to fetch.
     */
    where?: job_responsibilitesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_responsibilites to fetch.
     */
    orderBy?: job_responsibilitesOrderByWithRelationInput | job_responsibilitesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for job_responsibilites.
     */
    cursor?: job_responsibilitesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_responsibilites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_responsibilites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of job_responsibilites.
     */
    distinct?: Job_responsibilitesScalarFieldEnum | Job_responsibilitesScalarFieldEnum[]
  }

  /**
   * job_responsibilites findFirstOrThrow
   */
  export type job_responsibilitesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_responsibilites
     */
    select?: job_responsibilitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_responsibilites
     */
    omit?: job_responsibilitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_responsibilitesInclude<ExtArgs> | null
    /**
     * Filter, which job_responsibilites to fetch.
     */
    where?: job_responsibilitesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_responsibilites to fetch.
     */
    orderBy?: job_responsibilitesOrderByWithRelationInput | job_responsibilitesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for job_responsibilites.
     */
    cursor?: job_responsibilitesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_responsibilites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_responsibilites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of job_responsibilites.
     */
    distinct?: Job_responsibilitesScalarFieldEnum | Job_responsibilitesScalarFieldEnum[]
  }

  /**
   * job_responsibilites findMany
   */
  export type job_responsibilitesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_responsibilites
     */
    select?: job_responsibilitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_responsibilites
     */
    omit?: job_responsibilitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_responsibilitesInclude<ExtArgs> | null
    /**
     * Filter, which job_responsibilites to fetch.
     */
    where?: job_responsibilitesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_responsibilites to fetch.
     */
    orderBy?: job_responsibilitesOrderByWithRelationInput | job_responsibilitesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing job_responsibilites.
     */
    cursor?: job_responsibilitesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_responsibilites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_responsibilites.
     */
    skip?: number
    distinct?: Job_responsibilitesScalarFieldEnum | Job_responsibilitesScalarFieldEnum[]
  }

  /**
   * job_responsibilites create
   */
  export type job_responsibilitesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_responsibilites
     */
    select?: job_responsibilitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_responsibilites
     */
    omit?: job_responsibilitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_responsibilitesInclude<ExtArgs> | null
    /**
     * The data needed to create a job_responsibilites.
     */
    data: XOR<job_responsibilitesCreateInput, job_responsibilitesUncheckedCreateInput>
  }

  /**
   * job_responsibilites createMany
   */
  export type job_responsibilitesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many job_responsibilites.
     */
    data: job_responsibilitesCreateManyInput | job_responsibilitesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * job_responsibilites createManyAndReturn
   */
  export type job_responsibilitesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_responsibilites
     */
    select?: job_responsibilitesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the job_responsibilites
     */
    omit?: job_responsibilitesOmit<ExtArgs> | null
    /**
     * The data used to create many job_responsibilites.
     */
    data: job_responsibilitesCreateManyInput | job_responsibilitesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_responsibilitesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * job_responsibilites update
   */
  export type job_responsibilitesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_responsibilites
     */
    select?: job_responsibilitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_responsibilites
     */
    omit?: job_responsibilitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_responsibilitesInclude<ExtArgs> | null
    /**
     * The data needed to update a job_responsibilites.
     */
    data: XOR<job_responsibilitesUpdateInput, job_responsibilitesUncheckedUpdateInput>
    /**
     * Choose, which job_responsibilites to update.
     */
    where: job_responsibilitesWhereUniqueInput
  }

  /**
   * job_responsibilites updateMany
   */
  export type job_responsibilitesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update job_responsibilites.
     */
    data: XOR<job_responsibilitesUpdateManyMutationInput, job_responsibilitesUncheckedUpdateManyInput>
    /**
     * Filter which job_responsibilites to update
     */
    where?: job_responsibilitesWhereInput
    /**
     * Limit how many job_responsibilites to update.
     */
    limit?: number
  }

  /**
   * job_responsibilites updateManyAndReturn
   */
  export type job_responsibilitesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_responsibilites
     */
    select?: job_responsibilitesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the job_responsibilites
     */
    omit?: job_responsibilitesOmit<ExtArgs> | null
    /**
     * The data used to update job_responsibilites.
     */
    data: XOR<job_responsibilitesUpdateManyMutationInput, job_responsibilitesUncheckedUpdateManyInput>
    /**
     * Filter which job_responsibilites to update
     */
    where?: job_responsibilitesWhereInput
    /**
     * Limit how many job_responsibilites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_responsibilitesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * job_responsibilites upsert
   */
  export type job_responsibilitesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_responsibilites
     */
    select?: job_responsibilitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_responsibilites
     */
    omit?: job_responsibilitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_responsibilitesInclude<ExtArgs> | null
    /**
     * The filter to search for the job_responsibilites to update in case it exists.
     */
    where: job_responsibilitesWhereUniqueInput
    /**
     * In case the job_responsibilites found by the `where` argument doesn't exist, create a new job_responsibilites with this data.
     */
    create: XOR<job_responsibilitesCreateInput, job_responsibilitesUncheckedCreateInput>
    /**
     * In case the job_responsibilites was found with the provided `where` argument, update it with this data.
     */
    update: XOR<job_responsibilitesUpdateInput, job_responsibilitesUncheckedUpdateInput>
  }

  /**
   * job_responsibilites delete
   */
  export type job_responsibilitesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_responsibilites
     */
    select?: job_responsibilitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_responsibilites
     */
    omit?: job_responsibilitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_responsibilitesInclude<ExtArgs> | null
    /**
     * Filter which job_responsibilites to delete.
     */
    where: job_responsibilitesWhereUniqueInput
  }

  /**
   * job_responsibilites deleteMany
   */
  export type job_responsibilitesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job_responsibilites to delete
     */
    where?: job_responsibilitesWhereInput
    /**
     * Limit how many job_responsibilites to delete.
     */
    limit?: number
  }

  /**
   * job_responsibilites without action
   */
  export type job_responsibilitesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_responsibilites
     */
    select?: job_responsibilitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_responsibilites
     */
    omit?: job_responsibilitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_responsibilitesInclude<ExtArgs> | null
  }


  /**
   * Model job_benefits
   */

  export type AggregateJob_benefits = {
    _count: Job_benefitsCountAggregateOutputType | null
    _avg: Job_benefitsAvgAggregateOutputType | null
    _sum: Job_benefitsSumAggregateOutputType | null
    _min: Job_benefitsMinAggregateOutputType | null
    _max: Job_benefitsMaxAggregateOutputType | null
  }

  export type Job_benefitsAvgAggregateOutputType = {
    id: number | null
    job_id: number | null
  }

  export type Job_benefitsSumAggregateOutputType = {
    id: number | null
    job_id: number | null
  }

  export type Job_benefitsMinAggregateOutputType = {
    id: number | null
    job_id: number | null
    benefit_type: $Enums.jobBenefit | null
    description: string | null
  }

  export type Job_benefitsMaxAggregateOutputType = {
    id: number | null
    job_id: number | null
    benefit_type: $Enums.jobBenefit | null
    description: string | null
  }

  export type Job_benefitsCountAggregateOutputType = {
    id: number
    job_id: number
    benefit_type: number
    description: number
    _all: number
  }


  export type Job_benefitsAvgAggregateInputType = {
    id?: true
    job_id?: true
  }

  export type Job_benefitsSumAggregateInputType = {
    id?: true
    job_id?: true
  }

  export type Job_benefitsMinAggregateInputType = {
    id?: true
    job_id?: true
    benefit_type?: true
    description?: true
  }

  export type Job_benefitsMaxAggregateInputType = {
    id?: true
    job_id?: true
    benefit_type?: true
    description?: true
  }

  export type Job_benefitsCountAggregateInputType = {
    id?: true
    job_id?: true
    benefit_type?: true
    description?: true
    _all?: true
  }

  export type Job_benefitsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job_benefits to aggregate.
     */
    where?: job_benefitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_benefits to fetch.
     */
    orderBy?: job_benefitsOrderByWithRelationInput | job_benefitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: job_benefitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_benefits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_benefits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned job_benefits
    **/
    _count?: true | Job_benefitsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Job_benefitsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Job_benefitsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Job_benefitsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Job_benefitsMaxAggregateInputType
  }

  export type GetJob_benefitsAggregateType<T extends Job_benefitsAggregateArgs> = {
        [P in keyof T & keyof AggregateJob_benefits]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJob_benefits[P]>
      : GetScalarType<T[P], AggregateJob_benefits[P]>
  }




  export type job_benefitsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: job_benefitsWhereInput
    orderBy?: job_benefitsOrderByWithAggregationInput | job_benefitsOrderByWithAggregationInput[]
    by: Job_benefitsScalarFieldEnum[] | Job_benefitsScalarFieldEnum
    having?: job_benefitsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Job_benefitsCountAggregateInputType | true
    _avg?: Job_benefitsAvgAggregateInputType
    _sum?: Job_benefitsSumAggregateInputType
    _min?: Job_benefitsMinAggregateInputType
    _max?: Job_benefitsMaxAggregateInputType
  }

  export type Job_benefitsGroupByOutputType = {
    id: number
    job_id: number
    benefit_type: $Enums.jobBenefit
    description: string
    _count: Job_benefitsCountAggregateOutputType | null
    _avg: Job_benefitsAvgAggregateOutputType | null
    _sum: Job_benefitsSumAggregateOutputType | null
    _min: Job_benefitsMinAggregateOutputType | null
    _max: Job_benefitsMaxAggregateOutputType | null
  }

  type GetJob_benefitsGroupByPayload<T extends job_benefitsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Job_benefitsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Job_benefitsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Job_benefitsGroupByOutputType[P]>
            : GetScalarType<T[P], Job_benefitsGroupByOutputType[P]>
        }
      >
    >


  export type job_benefitsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    job_id?: boolean
    benefit_type?: boolean
    description?: boolean
    benefits?: boolean | jobsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job_benefits"]>

  export type job_benefitsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    job_id?: boolean
    benefit_type?: boolean
    description?: boolean
    benefits?: boolean | jobsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job_benefits"]>

  export type job_benefitsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    job_id?: boolean
    benefit_type?: boolean
    description?: boolean
    benefits?: boolean | jobsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job_benefits"]>

  export type job_benefitsSelectScalar = {
    id?: boolean
    job_id?: boolean
    benefit_type?: boolean
    description?: boolean
  }

  export type job_benefitsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "job_id" | "benefit_type" | "description", ExtArgs["result"]["job_benefits"]>
  export type job_benefitsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    benefits?: boolean | jobsDefaultArgs<ExtArgs>
  }
  export type job_benefitsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    benefits?: boolean | jobsDefaultArgs<ExtArgs>
  }
  export type job_benefitsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    benefits?: boolean | jobsDefaultArgs<ExtArgs>
  }

  export type $job_benefitsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "job_benefits"
    objects: {
      benefits: Prisma.$jobsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      job_id: number
      benefit_type: $Enums.jobBenefit
      description: string
    }, ExtArgs["result"]["job_benefits"]>
    composites: {}
  }

  type job_benefitsGetPayload<S extends boolean | null | undefined | job_benefitsDefaultArgs> = $Result.GetResult<Prisma.$job_benefitsPayload, S>

  type job_benefitsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<job_benefitsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Job_benefitsCountAggregateInputType | true
    }

  export interface job_benefitsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['job_benefits'], meta: { name: 'job_benefits' } }
    /**
     * Find zero or one Job_benefits that matches the filter.
     * @param {job_benefitsFindUniqueArgs} args - Arguments to find a Job_benefits
     * @example
     * // Get one Job_benefits
     * const job_benefits = await prisma.job_benefits.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends job_benefitsFindUniqueArgs>(args: SelectSubset<T, job_benefitsFindUniqueArgs<ExtArgs>>): Prisma__job_benefitsClient<$Result.GetResult<Prisma.$job_benefitsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Job_benefits that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {job_benefitsFindUniqueOrThrowArgs} args - Arguments to find a Job_benefits
     * @example
     * // Get one Job_benefits
     * const job_benefits = await prisma.job_benefits.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends job_benefitsFindUniqueOrThrowArgs>(args: SelectSubset<T, job_benefitsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__job_benefitsClient<$Result.GetResult<Prisma.$job_benefitsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job_benefits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_benefitsFindFirstArgs} args - Arguments to find a Job_benefits
     * @example
     * // Get one Job_benefits
     * const job_benefits = await prisma.job_benefits.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends job_benefitsFindFirstArgs>(args?: SelectSubset<T, job_benefitsFindFirstArgs<ExtArgs>>): Prisma__job_benefitsClient<$Result.GetResult<Prisma.$job_benefitsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job_benefits that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_benefitsFindFirstOrThrowArgs} args - Arguments to find a Job_benefits
     * @example
     * // Get one Job_benefits
     * const job_benefits = await prisma.job_benefits.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends job_benefitsFindFirstOrThrowArgs>(args?: SelectSubset<T, job_benefitsFindFirstOrThrowArgs<ExtArgs>>): Prisma__job_benefitsClient<$Result.GetResult<Prisma.$job_benefitsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Job_benefits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_benefitsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Job_benefits
     * const job_benefits = await prisma.job_benefits.findMany()
     * 
     * // Get first 10 Job_benefits
     * const job_benefits = await prisma.job_benefits.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const job_benefitsWithIdOnly = await prisma.job_benefits.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends job_benefitsFindManyArgs>(args?: SelectSubset<T, job_benefitsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_benefitsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Job_benefits.
     * @param {job_benefitsCreateArgs} args - Arguments to create a Job_benefits.
     * @example
     * // Create one Job_benefits
     * const Job_benefits = await prisma.job_benefits.create({
     *   data: {
     *     // ... data to create a Job_benefits
     *   }
     * })
     * 
     */
    create<T extends job_benefitsCreateArgs>(args: SelectSubset<T, job_benefitsCreateArgs<ExtArgs>>): Prisma__job_benefitsClient<$Result.GetResult<Prisma.$job_benefitsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Job_benefits.
     * @param {job_benefitsCreateManyArgs} args - Arguments to create many Job_benefits.
     * @example
     * // Create many Job_benefits
     * const job_benefits = await prisma.job_benefits.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends job_benefitsCreateManyArgs>(args?: SelectSubset<T, job_benefitsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Job_benefits and returns the data saved in the database.
     * @param {job_benefitsCreateManyAndReturnArgs} args - Arguments to create many Job_benefits.
     * @example
     * // Create many Job_benefits
     * const job_benefits = await prisma.job_benefits.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Job_benefits and only return the `id`
     * const job_benefitsWithIdOnly = await prisma.job_benefits.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends job_benefitsCreateManyAndReturnArgs>(args?: SelectSubset<T, job_benefitsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_benefitsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Job_benefits.
     * @param {job_benefitsDeleteArgs} args - Arguments to delete one Job_benefits.
     * @example
     * // Delete one Job_benefits
     * const Job_benefits = await prisma.job_benefits.delete({
     *   where: {
     *     // ... filter to delete one Job_benefits
     *   }
     * })
     * 
     */
    delete<T extends job_benefitsDeleteArgs>(args: SelectSubset<T, job_benefitsDeleteArgs<ExtArgs>>): Prisma__job_benefitsClient<$Result.GetResult<Prisma.$job_benefitsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Job_benefits.
     * @param {job_benefitsUpdateArgs} args - Arguments to update one Job_benefits.
     * @example
     * // Update one Job_benefits
     * const job_benefits = await prisma.job_benefits.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends job_benefitsUpdateArgs>(args: SelectSubset<T, job_benefitsUpdateArgs<ExtArgs>>): Prisma__job_benefitsClient<$Result.GetResult<Prisma.$job_benefitsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Job_benefits.
     * @param {job_benefitsDeleteManyArgs} args - Arguments to filter Job_benefits to delete.
     * @example
     * // Delete a few Job_benefits
     * const { count } = await prisma.job_benefits.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends job_benefitsDeleteManyArgs>(args?: SelectSubset<T, job_benefitsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Job_benefits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_benefitsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Job_benefits
     * const job_benefits = await prisma.job_benefits.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends job_benefitsUpdateManyArgs>(args: SelectSubset<T, job_benefitsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Job_benefits and returns the data updated in the database.
     * @param {job_benefitsUpdateManyAndReturnArgs} args - Arguments to update many Job_benefits.
     * @example
     * // Update many Job_benefits
     * const job_benefits = await prisma.job_benefits.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Job_benefits and only return the `id`
     * const job_benefitsWithIdOnly = await prisma.job_benefits.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends job_benefitsUpdateManyAndReturnArgs>(args: SelectSubset<T, job_benefitsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_benefitsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Job_benefits.
     * @param {job_benefitsUpsertArgs} args - Arguments to update or create a Job_benefits.
     * @example
     * // Update or create a Job_benefits
     * const job_benefits = await prisma.job_benefits.upsert({
     *   create: {
     *     // ... data to create a Job_benefits
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Job_benefits we want to update
     *   }
     * })
     */
    upsert<T extends job_benefitsUpsertArgs>(args: SelectSubset<T, job_benefitsUpsertArgs<ExtArgs>>): Prisma__job_benefitsClient<$Result.GetResult<Prisma.$job_benefitsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Job_benefits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_benefitsCountArgs} args - Arguments to filter Job_benefits to count.
     * @example
     * // Count the number of Job_benefits
     * const count = await prisma.job_benefits.count({
     *   where: {
     *     // ... the filter for the Job_benefits we want to count
     *   }
     * })
    **/
    count<T extends job_benefitsCountArgs>(
      args?: Subset<T, job_benefitsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Job_benefitsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Job_benefits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Job_benefitsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Job_benefitsAggregateArgs>(args: Subset<T, Job_benefitsAggregateArgs>): Prisma.PrismaPromise<GetJob_benefitsAggregateType<T>>

    /**
     * Group by Job_benefits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_benefitsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends job_benefitsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: job_benefitsGroupByArgs['orderBy'] }
        : { orderBy?: job_benefitsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, job_benefitsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJob_benefitsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the job_benefits model
   */
  readonly fields: job_benefitsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for job_benefits.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__job_benefitsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    benefits<T extends jobsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, jobsDefaultArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the job_benefits model
   */
  interface job_benefitsFieldRefs {
    readonly id: FieldRef<"job_benefits", 'Int'>
    readonly job_id: FieldRef<"job_benefits", 'Int'>
    readonly benefit_type: FieldRef<"job_benefits", 'jobBenefit'>
    readonly description: FieldRef<"job_benefits", 'String'>
  }
    

  // Custom InputTypes
  /**
   * job_benefits findUnique
   */
  export type job_benefitsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_benefits
     */
    select?: job_benefitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_benefits
     */
    omit?: job_benefitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_benefitsInclude<ExtArgs> | null
    /**
     * Filter, which job_benefits to fetch.
     */
    where: job_benefitsWhereUniqueInput
  }

  /**
   * job_benefits findUniqueOrThrow
   */
  export type job_benefitsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_benefits
     */
    select?: job_benefitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_benefits
     */
    omit?: job_benefitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_benefitsInclude<ExtArgs> | null
    /**
     * Filter, which job_benefits to fetch.
     */
    where: job_benefitsWhereUniqueInput
  }

  /**
   * job_benefits findFirst
   */
  export type job_benefitsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_benefits
     */
    select?: job_benefitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_benefits
     */
    omit?: job_benefitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_benefitsInclude<ExtArgs> | null
    /**
     * Filter, which job_benefits to fetch.
     */
    where?: job_benefitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_benefits to fetch.
     */
    orderBy?: job_benefitsOrderByWithRelationInput | job_benefitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for job_benefits.
     */
    cursor?: job_benefitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_benefits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_benefits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of job_benefits.
     */
    distinct?: Job_benefitsScalarFieldEnum | Job_benefitsScalarFieldEnum[]
  }

  /**
   * job_benefits findFirstOrThrow
   */
  export type job_benefitsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_benefits
     */
    select?: job_benefitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_benefits
     */
    omit?: job_benefitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_benefitsInclude<ExtArgs> | null
    /**
     * Filter, which job_benefits to fetch.
     */
    where?: job_benefitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_benefits to fetch.
     */
    orderBy?: job_benefitsOrderByWithRelationInput | job_benefitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for job_benefits.
     */
    cursor?: job_benefitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_benefits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_benefits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of job_benefits.
     */
    distinct?: Job_benefitsScalarFieldEnum | Job_benefitsScalarFieldEnum[]
  }

  /**
   * job_benefits findMany
   */
  export type job_benefitsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_benefits
     */
    select?: job_benefitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_benefits
     */
    omit?: job_benefitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_benefitsInclude<ExtArgs> | null
    /**
     * Filter, which job_benefits to fetch.
     */
    where?: job_benefitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_benefits to fetch.
     */
    orderBy?: job_benefitsOrderByWithRelationInput | job_benefitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing job_benefits.
     */
    cursor?: job_benefitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_benefits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_benefits.
     */
    skip?: number
    distinct?: Job_benefitsScalarFieldEnum | Job_benefitsScalarFieldEnum[]
  }

  /**
   * job_benefits create
   */
  export type job_benefitsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_benefits
     */
    select?: job_benefitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_benefits
     */
    omit?: job_benefitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_benefitsInclude<ExtArgs> | null
    /**
     * The data needed to create a job_benefits.
     */
    data: XOR<job_benefitsCreateInput, job_benefitsUncheckedCreateInput>
  }

  /**
   * job_benefits createMany
   */
  export type job_benefitsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many job_benefits.
     */
    data: job_benefitsCreateManyInput | job_benefitsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * job_benefits createManyAndReturn
   */
  export type job_benefitsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_benefits
     */
    select?: job_benefitsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the job_benefits
     */
    omit?: job_benefitsOmit<ExtArgs> | null
    /**
     * The data used to create many job_benefits.
     */
    data: job_benefitsCreateManyInput | job_benefitsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_benefitsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * job_benefits update
   */
  export type job_benefitsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_benefits
     */
    select?: job_benefitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_benefits
     */
    omit?: job_benefitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_benefitsInclude<ExtArgs> | null
    /**
     * The data needed to update a job_benefits.
     */
    data: XOR<job_benefitsUpdateInput, job_benefitsUncheckedUpdateInput>
    /**
     * Choose, which job_benefits to update.
     */
    where: job_benefitsWhereUniqueInput
  }

  /**
   * job_benefits updateMany
   */
  export type job_benefitsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update job_benefits.
     */
    data: XOR<job_benefitsUpdateManyMutationInput, job_benefitsUncheckedUpdateManyInput>
    /**
     * Filter which job_benefits to update
     */
    where?: job_benefitsWhereInput
    /**
     * Limit how many job_benefits to update.
     */
    limit?: number
  }

  /**
   * job_benefits updateManyAndReturn
   */
  export type job_benefitsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_benefits
     */
    select?: job_benefitsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the job_benefits
     */
    omit?: job_benefitsOmit<ExtArgs> | null
    /**
     * The data used to update job_benefits.
     */
    data: XOR<job_benefitsUpdateManyMutationInput, job_benefitsUncheckedUpdateManyInput>
    /**
     * Filter which job_benefits to update
     */
    where?: job_benefitsWhereInput
    /**
     * Limit how many job_benefits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_benefitsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * job_benefits upsert
   */
  export type job_benefitsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_benefits
     */
    select?: job_benefitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_benefits
     */
    omit?: job_benefitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_benefitsInclude<ExtArgs> | null
    /**
     * The filter to search for the job_benefits to update in case it exists.
     */
    where: job_benefitsWhereUniqueInput
    /**
     * In case the job_benefits found by the `where` argument doesn't exist, create a new job_benefits with this data.
     */
    create: XOR<job_benefitsCreateInput, job_benefitsUncheckedCreateInput>
    /**
     * In case the job_benefits was found with the provided `where` argument, update it with this data.
     */
    update: XOR<job_benefitsUpdateInput, job_benefitsUncheckedUpdateInput>
  }

  /**
   * job_benefits delete
   */
  export type job_benefitsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_benefits
     */
    select?: job_benefitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_benefits
     */
    omit?: job_benefitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_benefitsInclude<ExtArgs> | null
    /**
     * Filter which job_benefits to delete.
     */
    where: job_benefitsWhereUniqueInput
  }

  /**
   * job_benefits deleteMany
   */
  export type job_benefitsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job_benefits to delete
     */
    where?: job_benefitsWhereInput
    /**
     * Limit how many job_benefits to delete.
     */
    limit?: number
  }

  /**
   * job_benefits without action
   */
  export type job_benefitsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_benefits
     */
    select?: job_benefitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_benefits
     */
    omit?: job_benefitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_benefitsInclude<ExtArgs> | null
  }


  /**
   * Model applications
   */

  export type AggregateApplications = {
    _count: ApplicationsCountAggregateOutputType | null
    _avg: ApplicationsAvgAggregateOutputType | null
    _sum: ApplicationsSumAggregateOutputType | null
    _min: ApplicationsMinAggregateOutputType | null
    _max: ApplicationsMaxAggregateOutputType | null
  }

  export type ApplicationsAvgAggregateOutputType = {
    id: number | null
    job_id: number | null
    user_id: number | null
    resume_id: number | null
  }

  export type ApplicationsSumAggregateOutputType = {
    id: number | null
    job_id: number | null
    user_id: number | null
    resume_id: number | null
  }

  export type ApplicationsMinAggregateOutputType = {
    id: number | null
    job_id: number | null
    user_id: number | null
    resume_id: number | null
    cover_letter: string | null
    status: $Enums.applicationStatus | null
    applited_at: Date | null
    updated_at: Date | null
    notes: string | null
  }

  export type ApplicationsMaxAggregateOutputType = {
    id: number | null
    job_id: number | null
    user_id: number | null
    resume_id: number | null
    cover_letter: string | null
    status: $Enums.applicationStatus | null
    applited_at: Date | null
    updated_at: Date | null
    notes: string | null
  }

  export type ApplicationsCountAggregateOutputType = {
    id: number
    job_id: number
    user_id: number
    resume_id: number
    cover_letter: number
    status: number
    applited_at: number
    updated_at: number
    notes: number
    _all: number
  }


  export type ApplicationsAvgAggregateInputType = {
    id?: true
    job_id?: true
    user_id?: true
    resume_id?: true
  }

  export type ApplicationsSumAggregateInputType = {
    id?: true
    job_id?: true
    user_id?: true
    resume_id?: true
  }

  export type ApplicationsMinAggregateInputType = {
    id?: true
    job_id?: true
    user_id?: true
    resume_id?: true
    cover_letter?: true
    status?: true
    applited_at?: true
    updated_at?: true
    notes?: true
  }

  export type ApplicationsMaxAggregateInputType = {
    id?: true
    job_id?: true
    user_id?: true
    resume_id?: true
    cover_letter?: true
    status?: true
    applited_at?: true
    updated_at?: true
    notes?: true
  }

  export type ApplicationsCountAggregateInputType = {
    id?: true
    job_id?: true
    user_id?: true
    resume_id?: true
    cover_letter?: true
    status?: true
    applited_at?: true
    updated_at?: true
    notes?: true
    _all?: true
  }

  export type ApplicationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which applications to aggregate.
     */
    where?: applicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of applications to fetch.
     */
    orderBy?: applicationsOrderByWithRelationInput | applicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: applicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned applications
    **/
    _count?: true | ApplicationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApplicationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApplicationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApplicationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApplicationsMaxAggregateInputType
  }

  export type GetApplicationsAggregateType<T extends ApplicationsAggregateArgs> = {
        [P in keyof T & keyof AggregateApplications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApplications[P]>
      : GetScalarType<T[P], AggregateApplications[P]>
  }




  export type applicationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: applicationsWhereInput
    orderBy?: applicationsOrderByWithAggregationInput | applicationsOrderByWithAggregationInput[]
    by: ApplicationsScalarFieldEnum[] | ApplicationsScalarFieldEnum
    having?: applicationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApplicationsCountAggregateInputType | true
    _avg?: ApplicationsAvgAggregateInputType
    _sum?: ApplicationsSumAggregateInputType
    _min?: ApplicationsMinAggregateInputType
    _max?: ApplicationsMaxAggregateInputType
  }

  export type ApplicationsGroupByOutputType = {
    id: number
    job_id: number
    user_id: number
    resume_id: number
    cover_letter: string
    status: $Enums.applicationStatus
    applited_at: Date
    updated_at: Date
    notes: string
    _count: ApplicationsCountAggregateOutputType | null
    _avg: ApplicationsAvgAggregateOutputType | null
    _sum: ApplicationsSumAggregateOutputType | null
    _min: ApplicationsMinAggregateOutputType | null
    _max: ApplicationsMaxAggregateOutputType | null
  }

  type GetApplicationsGroupByPayload<T extends applicationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApplicationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApplicationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApplicationsGroupByOutputType[P]>
            : GetScalarType<T[P], ApplicationsGroupByOutputType[P]>
        }
      >
    >


  export type applicationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    job_id?: boolean
    user_id?: boolean
    resume_id?: boolean
    cover_letter?: boolean
    status?: boolean
    applited_at?: boolean
    updated_at?: boolean
    notes?: boolean
    application?: boolean | jobsDefaultArgs<ExtArgs>
    aplication?: boolean | usersDefaultArgs<ExtArgs>
    applications?: boolean | resumesDefaultArgs<ExtArgs>
    document?: boolean | applications$documentArgs<ExtArgs>
    interview?: boolean | applications$interviewArgs<ExtArgs>
    _count?: boolean | ApplicationsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["applications"]>

  export type applicationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    job_id?: boolean
    user_id?: boolean
    resume_id?: boolean
    cover_letter?: boolean
    status?: boolean
    applited_at?: boolean
    updated_at?: boolean
    notes?: boolean
    application?: boolean | jobsDefaultArgs<ExtArgs>
    aplication?: boolean | usersDefaultArgs<ExtArgs>
    applications?: boolean | resumesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["applications"]>

  export type applicationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    job_id?: boolean
    user_id?: boolean
    resume_id?: boolean
    cover_letter?: boolean
    status?: boolean
    applited_at?: boolean
    updated_at?: boolean
    notes?: boolean
    application?: boolean | jobsDefaultArgs<ExtArgs>
    aplication?: boolean | usersDefaultArgs<ExtArgs>
    applications?: boolean | resumesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["applications"]>

  export type applicationsSelectScalar = {
    id?: boolean
    job_id?: boolean
    user_id?: boolean
    resume_id?: boolean
    cover_letter?: boolean
    status?: boolean
    applited_at?: boolean
    updated_at?: boolean
    notes?: boolean
  }

  export type applicationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "job_id" | "user_id" | "resume_id" | "cover_letter" | "status" | "applited_at" | "updated_at" | "notes", ExtArgs["result"]["applications"]>
  export type applicationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | jobsDefaultArgs<ExtArgs>
    aplication?: boolean | usersDefaultArgs<ExtArgs>
    applications?: boolean | resumesDefaultArgs<ExtArgs>
    document?: boolean | applications$documentArgs<ExtArgs>
    interview?: boolean | applications$interviewArgs<ExtArgs>
    _count?: boolean | ApplicationsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type applicationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | jobsDefaultArgs<ExtArgs>
    aplication?: boolean | usersDefaultArgs<ExtArgs>
    applications?: boolean | resumesDefaultArgs<ExtArgs>
  }
  export type applicationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | jobsDefaultArgs<ExtArgs>
    aplication?: boolean | usersDefaultArgs<ExtArgs>
    applications?: boolean | resumesDefaultArgs<ExtArgs>
  }

  export type $applicationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "applications"
    objects: {
      application: Prisma.$jobsPayload<ExtArgs>
      aplication: Prisma.$usersPayload<ExtArgs>
      applications: Prisma.$resumesPayload<ExtArgs>
      document: Prisma.$application_documentsPayload<ExtArgs>[]
      interview: Prisma.$interviewsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      job_id: number
      user_id: number
      resume_id: number
      cover_letter: string
      status: $Enums.applicationStatus
      applited_at: Date
      updated_at: Date
      notes: string
    }, ExtArgs["result"]["applications"]>
    composites: {}
  }

  type applicationsGetPayload<S extends boolean | null | undefined | applicationsDefaultArgs> = $Result.GetResult<Prisma.$applicationsPayload, S>

  type applicationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<applicationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApplicationsCountAggregateInputType | true
    }

  export interface applicationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['applications'], meta: { name: 'applications' } }
    /**
     * Find zero or one Applications that matches the filter.
     * @param {applicationsFindUniqueArgs} args - Arguments to find a Applications
     * @example
     * // Get one Applications
     * const applications = await prisma.applications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends applicationsFindUniqueArgs>(args: SelectSubset<T, applicationsFindUniqueArgs<ExtArgs>>): Prisma__applicationsClient<$Result.GetResult<Prisma.$applicationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Applications that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {applicationsFindUniqueOrThrowArgs} args - Arguments to find a Applications
     * @example
     * // Get one Applications
     * const applications = await prisma.applications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends applicationsFindUniqueOrThrowArgs>(args: SelectSubset<T, applicationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__applicationsClient<$Result.GetResult<Prisma.$applicationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Applications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationsFindFirstArgs} args - Arguments to find a Applications
     * @example
     * // Get one Applications
     * const applications = await prisma.applications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends applicationsFindFirstArgs>(args?: SelectSubset<T, applicationsFindFirstArgs<ExtArgs>>): Prisma__applicationsClient<$Result.GetResult<Prisma.$applicationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Applications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationsFindFirstOrThrowArgs} args - Arguments to find a Applications
     * @example
     * // Get one Applications
     * const applications = await prisma.applications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends applicationsFindFirstOrThrowArgs>(args?: SelectSubset<T, applicationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__applicationsClient<$Result.GetResult<Prisma.$applicationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Applications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Applications
     * const applications = await prisma.applications.findMany()
     * 
     * // Get first 10 Applications
     * const applications = await prisma.applications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const applicationsWithIdOnly = await prisma.applications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends applicationsFindManyArgs>(args?: SelectSubset<T, applicationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$applicationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Applications.
     * @param {applicationsCreateArgs} args - Arguments to create a Applications.
     * @example
     * // Create one Applications
     * const Applications = await prisma.applications.create({
     *   data: {
     *     // ... data to create a Applications
     *   }
     * })
     * 
     */
    create<T extends applicationsCreateArgs>(args: SelectSubset<T, applicationsCreateArgs<ExtArgs>>): Prisma__applicationsClient<$Result.GetResult<Prisma.$applicationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Applications.
     * @param {applicationsCreateManyArgs} args - Arguments to create many Applications.
     * @example
     * // Create many Applications
     * const applications = await prisma.applications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends applicationsCreateManyArgs>(args?: SelectSubset<T, applicationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Applications and returns the data saved in the database.
     * @param {applicationsCreateManyAndReturnArgs} args - Arguments to create many Applications.
     * @example
     * // Create many Applications
     * const applications = await prisma.applications.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Applications and only return the `id`
     * const applicationsWithIdOnly = await prisma.applications.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends applicationsCreateManyAndReturnArgs>(args?: SelectSubset<T, applicationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$applicationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Applications.
     * @param {applicationsDeleteArgs} args - Arguments to delete one Applications.
     * @example
     * // Delete one Applications
     * const Applications = await prisma.applications.delete({
     *   where: {
     *     // ... filter to delete one Applications
     *   }
     * })
     * 
     */
    delete<T extends applicationsDeleteArgs>(args: SelectSubset<T, applicationsDeleteArgs<ExtArgs>>): Prisma__applicationsClient<$Result.GetResult<Prisma.$applicationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Applications.
     * @param {applicationsUpdateArgs} args - Arguments to update one Applications.
     * @example
     * // Update one Applications
     * const applications = await prisma.applications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends applicationsUpdateArgs>(args: SelectSubset<T, applicationsUpdateArgs<ExtArgs>>): Prisma__applicationsClient<$Result.GetResult<Prisma.$applicationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Applications.
     * @param {applicationsDeleteManyArgs} args - Arguments to filter Applications to delete.
     * @example
     * // Delete a few Applications
     * const { count } = await prisma.applications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends applicationsDeleteManyArgs>(args?: SelectSubset<T, applicationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Applications
     * const applications = await prisma.applications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends applicationsUpdateManyArgs>(args: SelectSubset<T, applicationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Applications and returns the data updated in the database.
     * @param {applicationsUpdateManyAndReturnArgs} args - Arguments to update many Applications.
     * @example
     * // Update many Applications
     * const applications = await prisma.applications.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Applications and only return the `id`
     * const applicationsWithIdOnly = await prisma.applications.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends applicationsUpdateManyAndReturnArgs>(args: SelectSubset<T, applicationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$applicationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Applications.
     * @param {applicationsUpsertArgs} args - Arguments to update or create a Applications.
     * @example
     * // Update or create a Applications
     * const applications = await prisma.applications.upsert({
     *   create: {
     *     // ... data to create a Applications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Applications we want to update
     *   }
     * })
     */
    upsert<T extends applicationsUpsertArgs>(args: SelectSubset<T, applicationsUpsertArgs<ExtArgs>>): Prisma__applicationsClient<$Result.GetResult<Prisma.$applicationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationsCountArgs} args - Arguments to filter Applications to count.
     * @example
     * // Count the number of Applications
     * const count = await prisma.applications.count({
     *   where: {
     *     // ... the filter for the Applications we want to count
     *   }
     * })
    **/
    count<T extends applicationsCountArgs>(
      args?: Subset<T, applicationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApplicationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApplicationsAggregateArgs>(args: Subset<T, ApplicationsAggregateArgs>): Prisma.PrismaPromise<GetApplicationsAggregateType<T>>

    /**
     * Group by Applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends applicationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: applicationsGroupByArgs['orderBy'] }
        : { orderBy?: applicationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, applicationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApplicationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the applications model
   */
  readonly fields: applicationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for applications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__applicationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    application<T extends jobsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, jobsDefaultArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    aplication<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    applications<T extends resumesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, resumesDefaultArgs<ExtArgs>>): Prisma__resumesClient<$Result.GetResult<Prisma.$resumesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    document<T extends applications$documentArgs<ExtArgs> = {}>(args?: Subset<T, applications$documentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$application_documentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    interview<T extends applications$interviewArgs<ExtArgs> = {}>(args?: Subset<T, applications$interviewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$interviewsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the applications model
   */
  interface applicationsFieldRefs {
    readonly id: FieldRef<"applications", 'Int'>
    readonly job_id: FieldRef<"applications", 'Int'>
    readonly user_id: FieldRef<"applications", 'Int'>
    readonly resume_id: FieldRef<"applications", 'Int'>
    readonly cover_letter: FieldRef<"applications", 'String'>
    readonly status: FieldRef<"applications", 'applicationStatus'>
    readonly applited_at: FieldRef<"applications", 'DateTime'>
    readonly updated_at: FieldRef<"applications", 'DateTime'>
    readonly notes: FieldRef<"applications", 'String'>
  }
    

  // Custom InputTypes
  /**
   * applications findUnique
   */
  export type applicationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applications
     */
    select?: applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applications
     */
    omit?: applicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationsInclude<ExtArgs> | null
    /**
     * Filter, which applications to fetch.
     */
    where: applicationsWhereUniqueInput
  }

  /**
   * applications findUniqueOrThrow
   */
  export type applicationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applications
     */
    select?: applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applications
     */
    omit?: applicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationsInclude<ExtArgs> | null
    /**
     * Filter, which applications to fetch.
     */
    where: applicationsWhereUniqueInput
  }

  /**
   * applications findFirst
   */
  export type applicationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applications
     */
    select?: applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applications
     */
    omit?: applicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationsInclude<ExtArgs> | null
    /**
     * Filter, which applications to fetch.
     */
    where?: applicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of applications to fetch.
     */
    orderBy?: applicationsOrderByWithRelationInput | applicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for applications.
     */
    cursor?: applicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of applications.
     */
    distinct?: ApplicationsScalarFieldEnum | ApplicationsScalarFieldEnum[]
  }

  /**
   * applications findFirstOrThrow
   */
  export type applicationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applications
     */
    select?: applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applications
     */
    omit?: applicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationsInclude<ExtArgs> | null
    /**
     * Filter, which applications to fetch.
     */
    where?: applicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of applications to fetch.
     */
    orderBy?: applicationsOrderByWithRelationInput | applicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for applications.
     */
    cursor?: applicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of applications.
     */
    distinct?: ApplicationsScalarFieldEnum | ApplicationsScalarFieldEnum[]
  }

  /**
   * applications findMany
   */
  export type applicationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applications
     */
    select?: applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applications
     */
    omit?: applicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationsInclude<ExtArgs> | null
    /**
     * Filter, which applications to fetch.
     */
    where?: applicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of applications to fetch.
     */
    orderBy?: applicationsOrderByWithRelationInput | applicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing applications.
     */
    cursor?: applicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applications.
     */
    skip?: number
    distinct?: ApplicationsScalarFieldEnum | ApplicationsScalarFieldEnum[]
  }

  /**
   * applications create
   */
  export type applicationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applications
     */
    select?: applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applications
     */
    omit?: applicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationsInclude<ExtArgs> | null
    /**
     * The data needed to create a applications.
     */
    data: XOR<applicationsCreateInput, applicationsUncheckedCreateInput>
  }

  /**
   * applications createMany
   */
  export type applicationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many applications.
     */
    data: applicationsCreateManyInput | applicationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * applications createManyAndReturn
   */
  export type applicationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applications
     */
    select?: applicationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the applications
     */
    omit?: applicationsOmit<ExtArgs> | null
    /**
     * The data used to create many applications.
     */
    data: applicationsCreateManyInput | applicationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * applications update
   */
  export type applicationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applications
     */
    select?: applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applications
     */
    omit?: applicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationsInclude<ExtArgs> | null
    /**
     * The data needed to update a applications.
     */
    data: XOR<applicationsUpdateInput, applicationsUncheckedUpdateInput>
    /**
     * Choose, which applications to update.
     */
    where: applicationsWhereUniqueInput
  }

  /**
   * applications updateMany
   */
  export type applicationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update applications.
     */
    data: XOR<applicationsUpdateManyMutationInput, applicationsUncheckedUpdateManyInput>
    /**
     * Filter which applications to update
     */
    where?: applicationsWhereInput
    /**
     * Limit how many applications to update.
     */
    limit?: number
  }

  /**
   * applications updateManyAndReturn
   */
  export type applicationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applications
     */
    select?: applicationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the applications
     */
    omit?: applicationsOmit<ExtArgs> | null
    /**
     * The data used to update applications.
     */
    data: XOR<applicationsUpdateManyMutationInput, applicationsUncheckedUpdateManyInput>
    /**
     * Filter which applications to update
     */
    where?: applicationsWhereInput
    /**
     * Limit how many applications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * applications upsert
   */
  export type applicationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applications
     */
    select?: applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applications
     */
    omit?: applicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationsInclude<ExtArgs> | null
    /**
     * The filter to search for the applications to update in case it exists.
     */
    where: applicationsWhereUniqueInput
    /**
     * In case the applications found by the `where` argument doesn't exist, create a new applications with this data.
     */
    create: XOR<applicationsCreateInput, applicationsUncheckedCreateInput>
    /**
     * In case the applications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<applicationsUpdateInput, applicationsUncheckedUpdateInput>
  }

  /**
   * applications delete
   */
  export type applicationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applications
     */
    select?: applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applications
     */
    omit?: applicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationsInclude<ExtArgs> | null
    /**
     * Filter which applications to delete.
     */
    where: applicationsWhereUniqueInput
  }

  /**
   * applications deleteMany
   */
  export type applicationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which applications to delete
     */
    where?: applicationsWhereInput
    /**
     * Limit how many applications to delete.
     */
    limit?: number
  }

  /**
   * applications.document
   */
  export type applications$documentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the application_documents
     */
    select?: application_documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the application_documents
     */
    omit?: application_documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: application_documentsInclude<ExtArgs> | null
    where?: application_documentsWhereInput
    orderBy?: application_documentsOrderByWithRelationInput | application_documentsOrderByWithRelationInput[]
    cursor?: application_documentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Application_documentsScalarFieldEnum | Application_documentsScalarFieldEnum[]
  }

  /**
   * applications.interview
   */
  export type applications$interviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the interviews
     */
    select?: interviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the interviews
     */
    omit?: interviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: interviewsInclude<ExtArgs> | null
    where?: interviewsWhereInput
    orderBy?: interviewsOrderByWithRelationInput | interviewsOrderByWithRelationInput[]
    cursor?: interviewsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InterviewsScalarFieldEnum | InterviewsScalarFieldEnum[]
  }

  /**
   * applications without action
   */
  export type applicationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applications
     */
    select?: applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applications
     */
    omit?: applicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationsInclude<ExtArgs> | null
  }


  /**
   * Model application_documents
   */

  export type AggregateApplication_documents = {
    _count: Application_documentsCountAggregateOutputType | null
    _avg: Application_documentsAvgAggregateOutputType | null
    _sum: Application_documentsSumAggregateOutputType | null
    _min: Application_documentsMinAggregateOutputType | null
    _max: Application_documentsMaxAggregateOutputType | null
  }

  export type Application_documentsAvgAggregateOutputType = {
    id: number | null
    application_id: number | null
  }

  export type Application_documentsSumAggregateOutputType = {
    id: number | null
    application_id: number | null
  }

  export type Application_documentsMinAggregateOutputType = {
    id: number | null
    application_id: number | null
    document_type: $Enums.appDocumentStatus | null
    file_url: string | null
    uploaded_at: Date | null
  }

  export type Application_documentsMaxAggregateOutputType = {
    id: number | null
    application_id: number | null
    document_type: $Enums.appDocumentStatus | null
    file_url: string | null
    uploaded_at: Date | null
  }

  export type Application_documentsCountAggregateOutputType = {
    id: number
    application_id: number
    document_type: number
    file_url: number
    uploaded_at: number
    _all: number
  }


  export type Application_documentsAvgAggregateInputType = {
    id?: true
    application_id?: true
  }

  export type Application_documentsSumAggregateInputType = {
    id?: true
    application_id?: true
  }

  export type Application_documentsMinAggregateInputType = {
    id?: true
    application_id?: true
    document_type?: true
    file_url?: true
    uploaded_at?: true
  }

  export type Application_documentsMaxAggregateInputType = {
    id?: true
    application_id?: true
    document_type?: true
    file_url?: true
    uploaded_at?: true
  }

  export type Application_documentsCountAggregateInputType = {
    id?: true
    application_id?: true
    document_type?: true
    file_url?: true
    uploaded_at?: true
    _all?: true
  }

  export type Application_documentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which application_documents to aggregate.
     */
    where?: application_documentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of application_documents to fetch.
     */
    orderBy?: application_documentsOrderByWithRelationInput | application_documentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: application_documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` application_documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` application_documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned application_documents
    **/
    _count?: true | Application_documentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Application_documentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Application_documentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Application_documentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Application_documentsMaxAggregateInputType
  }

  export type GetApplication_documentsAggregateType<T extends Application_documentsAggregateArgs> = {
        [P in keyof T & keyof AggregateApplication_documents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApplication_documents[P]>
      : GetScalarType<T[P], AggregateApplication_documents[P]>
  }




  export type application_documentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: application_documentsWhereInput
    orderBy?: application_documentsOrderByWithAggregationInput | application_documentsOrderByWithAggregationInput[]
    by: Application_documentsScalarFieldEnum[] | Application_documentsScalarFieldEnum
    having?: application_documentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Application_documentsCountAggregateInputType | true
    _avg?: Application_documentsAvgAggregateInputType
    _sum?: Application_documentsSumAggregateInputType
    _min?: Application_documentsMinAggregateInputType
    _max?: Application_documentsMaxAggregateInputType
  }

  export type Application_documentsGroupByOutputType = {
    id: number
    application_id: number
    document_type: $Enums.appDocumentStatus
    file_url: string
    uploaded_at: Date
    _count: Application_documentsCountAggregateOutputType | null
    _avg: Application_documentsAvgAggregateOutputType | null
    _sum: Application_documentsSumAggregateOutputType | null
    _min: Application_documentsMinAggregateOutputType | null
    _max: Application_documentsMaxAggregateOutputType | null
  }

  type GetApplication_documentsGroupByPayload<T extends application_documentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Application_documentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Application_documentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Application_documentsGroupByOutputType[P]>
            : GetScalarType<T[P], Application_documentsGroupByOutputType[P]>
        }
      >
    >


  export type application_documentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    application_id?: boolean
    document_type?: boolean
    file_url?: boolean
    uploaded_at?: boolean
    document?: boolean | applicationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["application_documents"]>

  export type application_documentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    application_id?: boolean
    document_type?: boolean
    file_url?: boolean
    uploaded_at?: boolean
    document?: boolean | applicationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["application_documents"]>

  export type application_documentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    application_id?: boolean
    document_type?: boolean
    file_url?: boolean
    uploaded_at?: boolean
    document?: boolean | applicationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["application_documents"]>

  export type application_documentsSelectScalar = {
    id?: boolean
    application_id?: boolean
    document_type?: boolean
    file_url?: boolean
    uploaded_at?: boolean
  }

  export type application_documentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "application_id" | "document_type" | "file_url" | "uploaded_at", ExtArgs["result"]["application_documents"]>
  export type application_documentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | applicationsDefaultArgs<ExtArgs>
  }
  export type application_documentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | applicationsDefaultArgs<ExtArgs>
  }
  export type application_documentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | applicationsDefaultArgs<ExtArgs>
  }

  export type $application_documentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "application_documents"
    objects: {
      document: Prisma.$applicationsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      application_id: number
      document_type: $Enums.appDocumentStatus
      file_url: string
      uploaded_at: Date
    }, ExtArgs["result"]["application_documents"]>
    composites: {}
  }

  type application_documentsGetPayload<S extends boolean | null | undefined | application_documentsDefaultArgs> = $Result.GetResult<Prisma.$application_documentsPayload, S>

  type application_documentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<application_documentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Application_documentsCountAggregateInputType | true
    }

  export interface application_documentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['application_documents'], meta: { name: 'application_documents' } }
    /**
     * Find zero or one Application_documents that matches the filter.
     * @param {application_documentsFindUniqueArgs} args - Arguments to find a Application_documents
     * @example
     * // Get one Application_documents
     * const application_documents = await prisma.application_documents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends application_documentsFindUniqueArgs>(args: SelectSubset<T, application_documentsFindUniqueArgs<ExtArgs>>): Prisma__application_documentsClient<$Result.GetResult<Prisma.$application_documentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Application_documents that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {application_documentsFindUniqueOrThrowArgs} args - Arguments to find a Application_documents
     * @example
     * // Get one Application_documents
     * const application_documents = await prisma.application_documents.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends application_documentsFindUniqueOrThrowArgs>(args: SelectSubset<T, application_documentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__application_documentsClient<$Result.GetResult<Prisma.$application_documentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Application_documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {application_documentsFindFirstArgs} args - Arguments to find a Application_documents
     * @example
     * // Get one Application_documents
     * const application_documents = await prisma.application_documents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends application_documentsFindFirstArgs>(args?: SelectSubset<T, application_documentsFindFirstArgs<ExtArgs>>): Prisma__application_documentsClient<$Result.GetResult<Prisma.$application_documentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Application_documents that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {application_documentsFindFirstOrThrowArgs} args - Arguments to find a Application_documents
     * @example
     * // Get one Application_documents
     * const application_documents = await prisma.application_documents.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends application_documentsFindFirstOrThrowArgs>(args?: SelectSubset<T, application_documentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__application_documentsClient<$Result.GetResult<Prisma.$application_documentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Application_documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {application_documentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Application_documents
     * const application_documents = await prisma.application_documents.findMany()
     * 
     * // Get first 10 Application_documents
     * const application_documents = await prisma.application_documents.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const application_documentsWithIdOnly = await prisma.application_documents.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends application_documentsFindManyArgs>(args?: SelectSubset<T, application_documentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$application_documentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Application_documents.
     * @param {application_documentsCreateArgs} args - Arguments to create a Application_documents.
     * @example
     * // Create one Application_documents
     * const Application_documents = await prisma.application_documents.create({
     *   data: {
     *     // ... data to create a Application_documents
     *   }
     * })
     * 
     */
    create<T extends application_documentsCreateArgs>(args: SelectSubset<T, application_documentsCreateArgs<ExtArgs>>): Prisma__application_documentsClient<$Result.GetResult<Prisma.$application_documentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Application_documents.
     * @param {application_documentsCreateManyArgs} args - Arguments to create many Application_documents.
     * @example
     * // Create many Application_documents
     * const application_documents = await prisma.application_documents.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends application_documentsCreateManyArgs>(args?: SelectSubset<T, application_documentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Application_documents and returns the data saved in the database.
     * @param {application_documentsCreateManyAndReturnArgs} args - Arguments to create many Application_documents.
     * @example
     * // Create many Application_documents
     * const application_documents = await prisma.application_documents.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Application_documents and only return the `id`
     * const application_documentsWithIdOnly = await prisma.application_documents.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends application_documentsCreateManyAndReturnArgs>(args?: SelectSubset<T, application_documentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$application_documentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Application_documents.
     * @param {application_documentsDeleteArgs} args - Arguments to delete one Application_documents.
     * @example
     * // Delete one Application_documents
     * const Application_documents = await prisma.application_documents.delete({
     *   where: {
     *     // ... filter to delete one Application_documents
     *   }
     * })
     * 
     */
    delete<T extends application_documentsDeleteArgs>(args: SelectSubset<T, application_documentsDeleteArgs<ExtArgs>>): Prisma__application_documentsClient<$Result.GetResult<Prisma.$application_documentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Application_documents.
     * @param {application_documentsUpdateArgs} args - Arguments to update one Application_documents.
     * @example
     * // Update one Application_documents
     * const application_documents = await prisma.application_documents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends application_documentsUpdateArgs>(args: SelectSubset<T, application_documentsUpdateArgs<ExtArgs>>): Prisma__application_documentsClient<$Result.GetResult<Prisma.$application_documentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Application_documents.
     * @param {application_documentsDeleteManyArgs} args - Arguments to filter Application_documents to delete.
     * @example
     * // Delete a few Application_documents
     * const { count } = await prisma.application_documents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends application_documentsDeleteManyArgs>(args?: SelectSubset<T, application_documentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Application_documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {application_documentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Application_documents
     * const application_documents = await prisma.application_documents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends application_documentsUpdateManyArgs>(args: SelectSubset<T, application_documentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Application_documents and returns the data updated in the database.
     * @param {application_documentsUpdateManyAndReturnArgs} args - Arguments to update many Application_documents.
     * @example
     * // Update many Application_documents
     * const application_documents = await prisma.application_documents.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Application_documents and only return the `id`
     * const application_documentsWithIdOnly = await prisma.application_documents.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends application_documentsUpdateManyAndReturnArgs>(args: SelectSubset<T, application_documentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$application_documentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Application_documents.
     * @param {application_documentsUpsertArgs} args - Arguments to update or create a Application_documents.
     * @example
     * // Update or create a Application_documents
     * const application_documents = await prisma.application_documents.upsert({
     *   create: {
     *     // ... data to create a Application_documents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Application_documents we want to update
     *   }
     * })
     */
    upsert<T extends application_documentsUpsertArgs>(args: SelectSubset<T, application_documentsUpsertArgs<ExtArgs>>): Prisma__application_documentsClient<$Result.GetResult<Prisma.$application_documentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Application_documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {application_documentsCountArgs} args - Arguments to filter Application_documents to count.
     * @example
     * // Count the number of Application_documents
     * const count = await prisma.application_documents.count({
     *   where: {
     *     // ... the filter for the Application_documents we want to count
     *   }
     * })
    **/
    count<T extends application_documentsCountArgs>(
      args?: Subset<T, application_documentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Application_documentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Application_documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Application_documentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Application_documentsAggregateArgs>(args: Subset<T, Application_documentsAggregateArgs>): Prisma.PrismaPromise<GetApplication_documentsAggregateType<T>>

    /**
     * Group by Application_documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {application_documentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends application_documentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: application_documentsGroupByArgs['orderBy'] }
        : { orderBy?: application_documentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, application_documentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApplication_documentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the application_documents model
   */
  readonly fields: application_documentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for application_documents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__application_documentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    document<T extends applicationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, applicationsDefaultArgs<ExtArgs>>): Prisma__applicationsClient<$Result.GetResult<Prisma.$applicationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the application_documents model
   */
  interface application_documentsFieldRefs {
    readonly id: FieldRef<"application_documents", 'Int'>
    readonly application_id: FieldRef<"application_documents", 'Int'>
    readonly document_type: FieldRef<"application_documents", 'appDocumentStatus'>
    readonly file_url: FieldRef<"application_documents", 'String'>
    readonly uploaded_at: FieldRef<"application_documents", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * application_documents findUnique
   */
  export type application_documentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the application_documents
     */
    select?: application_documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the application_documents
     */
    omit?: application_documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: application_documentsInclude<ExtArgs> | null
    /**
     * Filter, which application_documents to fetch.
     */
    where: application_documentsWhereUniqueInput
  }

  /**
   * application_documents findUniqueOrThrow
   */
  export type application_documentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the application_documents
     */
    select?: application_documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the application_documents
     */
    omit?: application_documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: application_documentsInclude<ExtArgs> | null
    /**
     * Filter, which application_documents to fetch.
     */
    where: application_documentsWhereUniqueInput
  }

  /**
   * application_documents findFirst
   */
  export type application_documentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the application_documents
     */
    select?: application_documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the application_documents
     */
    omit?: application_documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: application_documentsInclude<ExtArgs> | null
    /**
     * Filter, which application_documents to fetch.
     */
    where?: application_documentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of application_documents to fetch.
     */
    orderBy?: application_documentsOrderByWithRelationInput | application_documentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for application_documents.
     */
    cursor?: application_documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` application_documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` application_documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of application_documents.
     */
    distinct?: Application_documentsScalarFieldEnum | Application_documentsScalarFieldEnum[]
  }

  /**
   * application_documents findFirstOrThrow
   */
  export type application_documentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the application_documents
     */
    select?: application_documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the application_documents
     */
    omit?: application_documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: application_documentsInclude<ExtArgs> | null
    /**
     * Filter, which application_documents to fetch.
     */
    where?: application_documentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of application_documents to fetch.
     */
    orderBy?: application_documentsOrderByWithRelationInput | application_documentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for application_documents.
     */
    cursor?: application_documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` application_documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` application_documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of application_documents.
     */
    distinct?: Application_documentsScalarFieldEnum | Application_documentsScalarFieldEnum[]
  }

  /**
   * application_documents findMany
   */
  export type application_documentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the application_documents
     */
    select?: application_documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the application_documents
     */
    omit?: application_documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: application_documentsInclude<ExtArgs> | null
    /**
     * Filter, which application_documents to fetch.
     */
    where?: application_documentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of application_documents to fetch.
     */
    orderBy?: application_documentsOrderByWithRelationInput | application_documentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing application_documents.
     */
    cursor?: application_documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` application_documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` application_documents.
     */
    skip?: number
    distinct?: Application_documentsScalarFieldEnum | Application_documentsScalarFieldEnum[]
  }

  /**
   * application_documents create
   */
  export type application_documentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the application_documents
     */
    select?: application_documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the application_documents
     */
    omit?: application_documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: application_documentsInclude<ExtArgs> | null
    /**
     * The data needed to create a application_documents.
     */
    data: XOR<application_documentsCreateInput, application_documentsUncheckedCreateInput>
  }

  /**
   * application_documents createMany
   */
  export type application_documentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many application_documents.
     */
    data: application_documentsCreateManyInput | application_documentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * application_documents createManyAndReturn
   */
  export type application_documentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the application_documents
     */
    select?: application_documentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the application_documents
     */
    omit?: application_documentsOmit<ExtArgs> | null
    /**
     * The data used to create many application_documents.
     */
    data: application_documentsCreateManyInput | application_documentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: application_documentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * application_documents update
   */
  export type application_documentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the application_documents
     */
    select?: application_documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the application_documents
     */
    omit?: application_documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: application_documentsInclude<ExtArgs> | null
    /**
     * The data needed to update a application_documents.
     */
    data: XOR<application_documentsUpdateInput, application_documentsUncheckedUpdateInput>
    /**
     * Choose, which application_documents to update.
     */
    where: application_documentsWhereUniqueInput
  }

  /**
   * application_documents updateMany
   */
  export type application_documentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update application_documents.
     */
    data: XOR<application_documentsUpdateManyMutationInput, application_documentsUncheckedUpdateManyInput>
    /**
     * Filter which application_documents to update
     */
    where?: application_documentsWhereInput
    /**
     * Limit how many application_documents to update.
     */
    limit?: number
  }

  /**
   * application_documents updateManyAndReturn
   */
  export type application_documentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the application_documents
     */
    select?: application_documentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the application_documents
     */
    omit?: application_documentsOmit<ExtArgs> | null
    /**
     * The data used to update application_documents.
     */
    data: XOR<application_documentsUpdateManyMutationInput, application_documentsUncheckedUpdateManyInput>
    /**
     * Filter which application_documents to update
     */
    where?: application_documentsWhereInput
    /**
     * Limit how many application_documents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: application_documentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * application_documents upsert
   */
  export type application_documentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the application_documents
     */
    select?: application_documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the application_documents
     */
    omit?: application_documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: application_documentsInclude<ExtArgs> | null
    /**
     * The filter to search for the application_documents to update in case it exists.
     */
    where: application_documentsWhereUniqueInput
    /**
     * In case the application_documents found by the `where` argument doesn't exist, create a new application_documents with this data.
     */
    create: XOR<application_documentsCreateInput, application_documentsUncheckedCreateInput>
    /**
     * In case the application_documents was found with the provided `where` argument, update it with this data.
     */
    update: XOR<application_documentsUpdateInput, application_documentsUncheckedUpdateInput>
  }

  /**
   * application_documents delete
   */
  export type application_documentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the application_documents
     */
    select?: application_documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the application_documents
     */
    omit?: application_documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: application_documentsInclude<ExtArgs> | null
    /**
     * Filter which application_documents to delete.
     */
    where: application_documentsWhereUniqueInput
  }

  /**
   * application_documents deleteMany
   */
  export type application_documentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which application_documents to delete
     */
    where?: application_documentsWhereInput
    /**
     * Limit how many application_documents to delete.
     */
    limit?: number
  }

  /**
   * application_documents without action
   */
  export type application_documentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the application_documents
     */
    select?: application_documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the application_documents
     */
    omit?: application_documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: application_documentsInclude<ExtArgs> | null
  }


  /**
   * Model interviews
   */

  export type AggregateInterviews = {
    _count: InterviewsCountAggregateOutputType | null
    _avg: InterviewsAvgAggregateOutputType | null
    _sum: InterviewsSumAggregateOutputType | null
    _min: InterviewsMinAggregateOutputType | null
    _max: InterviewsMaxAggregateOutputType | null
  }

  export type InterviewsAvgAggregateOutputType = {
    id: number | null
    application_id: number | null
    duration_minutes: number | null
    rating: number | null
  }

  export type InterviewsSumAggregateOutputType = {
    id: number | null
    application_id: number | null
    duration_minutes: number | null
    rating: number | null
  }

  export type InterviewsMinAggregateOutputType = {
    id: number | null
    application_id: number | null
    interview_type: $Enums.interviewType | null
    scheduled_time: Date | null
    timezone: string | null
    duration_minutes: number | null
    location: string | null
    meeting_url: string | null
    interview_name: string | null
    interview_position: string | null
    status: $Enums.interviewStatus | null
    feedback: string | null
    rating: number | null
    notes: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type InterviewsMaxAggregateOutputType = {
    id: number | null
    application_id: number | null
    interview_type: $Enums.interviewType | null
    scheduled_time: Date | null
    timezone: string | null
    duration_minutes: number | null
    location: string | null
    meeting_url: string | null
    interview_name: string | null
    interview_position: string | null
    status: $Enums.interviewStatus | null
    feedback: string | null
    rating: number | null
    notes: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type InterviewsCountAggregateOutputType = {
    id: number
    application_id: number
    interview_type: number
    scheduled_time: number
    timezone: number
    duration_minutes: number
    location: number
    meeting_url: number
    interview_name: number
    interview_position: number
    status: number
    feedback: number
    rating: number
    notes: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type InterviewsAvgAggregateInputType = {
    id?: true
    application_id?: true
    duration_minutes?: true
    rating?: true
  }

  export type InterviewsSumAggregateInputType = {
    id?: true
    application_id?: true
    duration_minutes?: true
    rating?: true
  }

  export type InterviewsMinAggregateInputType = {
    id?: true
    application_id?: true
    interview_type?: true
    scheduled_time?: true
    timezone?: true
    duration_minutes?: true
    location?: true
    meeting_url?: true
    interview_name?: true
    interview_position?: true
    status?: true
    feedback?: true
    rating?: true
    notes?: true
    created_at?: true
    updated_at?: true
  }

  export type InterviewsMaxAggregateInputType = {
    id?: true
    application_id?: true
    interview_type?: true
    scheduled_time?: true
    timezone?: true
    duration_minutes?: true
    location?: true
    meeting_url?: true
    interview_name?: true
    interview_position?: true
    status?: true
    feedback?: true
    rating?: true
    notes?: true
    created_at?: true
    updated_at?: true
  }

  export type InterviewsCountAggregateInputType = {
    id?: true
    application_id?: true
    interview_type?: true
    scheduled_time?: true
    timezone?: true
    duration_minutes?: true
    location?: true
    meeting_url?: true
    interview_name?: true
    interview_position?: true
    status?: true
    feedback?: true
    rating?: true
    notes?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type InterviewsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which interviews to aggregate.
     */
    where?: interviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of interviews to fetch.
     */
    orderBy?: interviewsOrderByWithRelationInput | interviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: interviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` interviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` interviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned interviews
    **/
    _count?: true | InterviewsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InterviewsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InterviewsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InterviewsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InterviewsMaxAggregateInputType
  }

  export type GetInterviewsAggregateType<T extends InterviewsAggregateArgs> = {
        [P in keyof T & keyof AggregateInterviews]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInterviews[P]>
      : GetScalarType<T[P], AggregateInterviews[P]>
  }




  export type interviewsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: interviewsWhereInput
    orderBy?: interviewsOrderByWithAggregationInput | interviewsOrderByWithAggregationInput[]
    by: InterviewsScalarFieldEnum[] | InterviewsScalarFieldEnum
    having?: interviewsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InterviewsCountAggregateInputType | true
    _avg?: InterviewsAvgAggregateInputType
    _sum?: InterviewsSumAggregateInputType
    _min?: InterviewsMinAggregateInputType
    _max?: InterviewsMaxAggregateInputType
  }

  export type InterviewsGroupByOutputType = {
    id: number
    application_id: number
    interview_type: $Enums.interviewType
    scheduled_time: Date
    timezone: string
    duration_minutes: number
    location: string
    meeting_url: string
    interview_name: string
    interview_position: string
    status: $Enums.interviewStatus
    feedback: string
    rating: number
    notes: string
    created_at: Date
    updated_at: Date
    _count: InterviewsCountAggregateOutputType | null
    _avg: InterviewsAvgAggregateOutputType | null
    _sum: InterviewsSumAggregateOutputType | null
    _min: InterviewsMinAggregateOutputType | null
    _max: InterviewsMaxAggregateOutputType | null
  }

  type GetInterviewsGroupByPayload<T extends interviewsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InterviewsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InterviewsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InterviewsGroupByOutputType[P]>
            : GetScalarType<T[P], InterviewsGroupByOutputType[P]>
        }
      >
    >


  export type interviewsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    application_id?: boolean
    interview_type?: boolean
    scheduled_time?: boolean
    timezone?: boolean
    duration_minutes?: boolean
    location?: boolean
    meeting_url?: boolean
    interview_name?: boolean
    interview_position?: boolean
    status?: boolean
    feedback?: boolean
    rating?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
    interview?: boolean | applicationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interviews"]>

  export type interviewsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    application_id?: boolean
    interview_type?: boolean
    scheduled_time?: boolean
    timezone?: boolean
    duration_minutes?: boolean
    location?: boolean
    meeting_url?: boolean
    interview_name?: boolean
    interview_position?: boolean
    status?: boolean
    feedback?: boolean
    rating?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
    interview?: boolean | applicationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interviews"]>

  export type interviewsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    application_id?: boolean
    interview_type?: boolean
    scheduled_time?: boolean
    timezone?: boolean
    duration_minutes?: boolean
    location?: boolean
    meeting_url?: boolean
    interview_name?: boolean
    interview_position?: boolean
    status?: boolean
    feedback?: boolean
    rating?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
    interview?: boolean | applicationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interviews"]>

  export type interviewsSelectScalar = {
    id?: boolean
    application_id?: boolean
    interview_type?: boolean
    scheduled_time?: boolean
    timezone?: boolean
    duration_minutes?: boolean
    location?: boolean
    meeting_url?: boolean
    interview_name?: boolean
    interview_position?: boolean
    status?: boolean
    feedback?: boolean
    rating?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type interviewsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "application_id" | "interview_type" | "scheduled_time" | "timezone" | "duration_minutes" | "location" | "meeting_url" | "interview_name" | "interview_position" | "status" | "feedback" | "rating" | "notes" | "created_at" | "updated_at", ExtArgs["result"]["interviews"]>
  export type interviewsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interview?: boolean | applicationsDefaultArgs<ExtArgs>
  }
  export type interviewsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interview?: boolean | applicationsDefaultArgs<ExtArgs>
  }
  export type interviewsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interview?: boolean | applicationsDefaultArgs<ExtArgs>
  }

  export type $interviewsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "interviews"
    objects: {
      interview: Prisma.$applicationsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      application_id: number
      interview_type: $Enums.interviewType
      scheduled_time: Date
      timezone: string
      duration_minutes: number
      location: string
      meeting_url: string
      interview_name: string
      interview_position: string
      status: $Enums.interviewStatus
      feedback: string
      rating: number
      notes: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["interviews"]>
    composites: {}
  }

  type interviewsGetPayload<S extends boolean | null | undefined | interviewsDefaultArgs> = $Result.GetResult<Prisma.$interviewsPayload, S>

  type interviewsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<interviewsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InterviewsCountAggregateInputType | true
    }

  export interface interviewsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['interviews'], meta: { name: 'interviews' } }
    /**
     * Find zero or one Interviews that matches the filter.
     * @param {interviewsFindUniqueArgs} args - Arguments to find a Interviews
     * @example
     * // Get one Interviews
     * const interviews = await prisma.interviews.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends interviewsFindUniqueArgs>(args: SelectSubset<T, interviewsFindUniqueArgs<ExtArgs>>): Prisma__interviewsClient<$Result.GetResult<Prisma.$interviewsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Interviews that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {interviewsFindUniqueOrThrowArgs} args - Arguments to find a Interviews
     * @example
     * // Get one Interviews
     * const interviews = await prisma.interviews.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends interviewsFindUniqueOrThrowArgs>(args: SelectSubset<T, interviewsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__interviewsClient<$Result.GetResult<Prisma.$interviewsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Interviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {interviewsFindFirstArgs} args - Arguments to find a Interviews
     * @example
     * // Get one Interviews
     * const interviews = await prisma.interviews.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends interviewsFindFirstArgs>(args?: SelectSubset<T, interviewsFindFirstArgs<ExtArgs>>): Prisma__interviewsClient<$Result.GetResult<Prisma.$interviewsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Interviews that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {interviewsFindFirstOrThrowArgs} args - Arguments to find a Interviews
     * @example
     * // Get one Interviews
     * const interviews = await prisma.interviews.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends interviewsFindFirstOrThrowArgs>(args?: SelectSubset<T, interviewsFindFirstOrThrowArgs<ExtArgs>>): Prisma__interviewsClient<$Result.GetResult<Prisma.$interviewsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Interviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {interviewsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Interviews
     * const interviews = await prisma.interviews.findMany()
     * 
     * // Get first 10 Interviews
     * const interviews = await prisma.interviews.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interviewsWithIdOnly = await prisma.interviews.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends interviewsFindManyArgs>(args?: SelectSubset<T, interviewsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$interviewsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Interviews.
     * @param {interviewsCreateArgs} args - Arguments to create a Interviews.
     * @example
     * // Create one Interviews
     * const Interviews = await prisma.interviews.create({
     *   data: {
     *     // ... data to create a Interviews
     *   }
     * })
     * 
     */
    create<T extends interviewsCreateArgs>(args: SelectSubset<T, interviewsCreateArgs<ExtArgs>>): Prisma__interviewsClient<$Result.GetResult<Prisma.$interviewsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Interviews.
     * @param {interviewsCreateManyArgs} args - Arguments to create many Interviews.
     * @example
     * // Create many Interviews
     * const interviews = await prisma.interviews.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends interviewsCreateManyArgs>(args?: SelectSubset<T, interviewsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Interviews and returns the data saved in the database.
     * @param {interviewsCreateManyAndReturnArgs} args - Arguments to create many Interviews.
     * @example
     * // Create many Interviews
     * const interviews = await prisma.interviews.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Interviews and only return the `id`
     * const interviewsWithIdOnly = await prisma.interviews.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends interviewsCreateManyAndReturnArgs>(args?: SelectSubset<T, interviewsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$interviewsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Interviews.
     * @param {interviewsDeleteArgs} args - Arguments to delete one Interviews.
     * @example
     * // Delete one Interviews
     * const Interviews = await prisma.interviews.delete({
     *   where: {
     *     // ... filter to delete one Interviews
     *   }
     * })
     * 
     */
    delete<T extends interviewsDeleteArgs>(args: SelectSubset<T, interviewsDeleteArgs<ExtArgs>>): Prisma__interviewsClient<$Result.GetResult<Prisma.$interviewsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Interviews.
     * @param {interviewsUpdateArgs} args - Arguments to update one Interviews.
     * @example
     * // Update one Interviews
     * const interviews = await prisma.interviews.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends interviewsUpdateArgs>(args: SelectSubset<T, interviewsUpdateArgs<ExtArgs>>): Prisma__interviewsClient<$Result.GetResult<Prisma.$interviewsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Interviews.
     * @param {interviewsDeleteManyArgs} args - Arguments to filter Interviews to delete.
     * @example
     * // Delete a few Interviews
     * const { count } = await prisma.interviews.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends interviewsDeleteManyArgs>(args?: SelectSubset<T, interviewsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Interviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {interviewsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Interviews
     * const interviews = await prisma.interviews.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends interviewsUpdateManyArgs>(args: SelectSubset<T, interviewsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Interviews and returns the data updated in the database.
     * @param {interviewsUpdateManyAndReturnArgs} args - Arguments to update many Interviews.
     * @example
     * // Update many Interviews
     * const interviews = await prisma.interviews.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Interviews and only return the `id`
     * const interviewsWithIdOnly = await prisma.interviews.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends interviewsUpdateManyAndReturnArgs>(args: SelectSubset<T, interviewsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$interviewsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Interviews.
     * @param {interviewsUpsertArgs} args - Arguments to update or create a Interviews.
     * @example
     * // Update or create a Interviews
     * const interviews = await prisma.interviews.upsert({
     *   create: {
     *     // ... data to create a Interviews
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Interviews we want to update
     *   }
     * })
     */
    upsert<T extends interviewsUpsertArgs>(args: SelectSubset<T, interviewsUpsertArgs<ExtArgs>>): Prisma__interviewsClient<$Result.GetResult<Prisma.$interviewsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Interviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {interviewsCountArgs} args - Arguments to filter Interviews to count.
     * @example
     * // Count the number of Interviews
     * const count = await prisma.interviews.count({
     *   where: {
     *     // ... the filter for the Interviews we want to count
     *   }
     * })
    **/
    count<T extends interviewsCountArgs>(
      args?: Subset<T, interviewsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InterviewsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Interviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InterviewsAggregateArgs>(args: Subset<T, InterviewsAggregateArgs>): Prisma.PrismaPromise<GetInterviewsAggregateType<T>>

    /**
     * Group by Interviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {interviewsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends interviewsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: interviewsGroupByArgs['orderBy'] }
        : { orderBy?: interviewsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, interviewsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInterviewsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the interviews model
   */
  readonly fields: interviewsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for interviews.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__interviewsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    interview<T extends applicationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, applicationsDefaultArgs<ExtArgs>>): Prisma__applicationsClient<$Result.GetResult<Prisma.$applicationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the interviews model
   */
  interface interviewsFieldRefs {
    readonly id: FieldRef<"interviews", 'Int'>
    readonly application_id: FieldRef<"interviews", 'Int'>
    readonly interview_type: FieldRef<"interviews", 'interviewType'>
    readonly scheduled_time: FieldRef<"interviews", 'DateTime'>
    readonly timezone: FieldRef<"interviews", 'String'>
    readonly duration_minutes: FieldRef<"interviews", 'Int'>
    readonly location: FieldRef<"interviews", 'String'>
    readonly meeting_url: FieldRef<"interviews", 'String'>
    readonly interview_name: FieldRef<"interviews", 'String'>
    readonly interview_position: FieldRef<"interviews", 'String'>
    readonly status: FieldRef<"interviews", 'interviewStatus'>
    readonly feedback: FieldRef<"interviews", 'String'>
    readonly rating: FieldRef<"interviews", 'Int'>
    readonly notes: FieldRef<"interviews", 'String'>
    readonly created_at: FieldRef<"interviews", 'DateTime'>
    readonly updated_at: FieldRef<"interviews", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * interviews findUnique
   */
  export type interviewsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the interviews
     */
    select?: interviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the interviews
     */
    omit?: interviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: interviewsInclude<ExtArgs> | null
    /**
     * Filter, which interviews to fetch.
     */
    where: interviewsWhereUniqueInput
  }

  /**
   * interviews findUniqueOrThrow
   */
  export type interviewsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the interviews
     */
    select?: interviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the interviews
     */
    omit?: interviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: interviewsInclude<ExtArgs> | null
    /**
     * Filter, which interviews to fetch.
     */
    where: interviewsWhereUniqueInput
  }

  /**
   * interviews findFirst
   */
  export type interviewsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the interviews
     */
    select?: interviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the interviews
     */
    omit?: interviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: interviewsInclude<ExtArgs> | null
    /**
     * Filter, which interviews to fetch.
     */
    where?: interviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of interviews to fetch.
     */
    orderBy?: interviewsOrderByWithRelationInput | interviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for interviews.
     */
    cursor?: interviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` interviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` interviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of interviews.
     */
    distinct?: InterviewsScalarFieldEnum | InterviewsScalarFieldEnum[]
  }

  /**
   * interviews findFirstOrThrow
   */
  export type interviewsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the interviews
     */
    select?: interviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the interviews
     */
    omit?: interviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: interviewsInclude<ExtArgs> | null
    /**
     * Filter, which interviews to fetch.
     */
    where?: interviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of interviews to fetch.
     */
    orderBy?: interviewsOrderByWithRelationInput | interviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for interviews.
     */
    cursor?: interviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` interviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` interviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of interviews.
     */
    distinct?: InterviewsScalarFieldEnum | InterviewsScalarFieldEnum[]
  }

  /**
   * interviews findMany
   */
  export type interviewsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the interviews
     */
    select?: interviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the interviews
     */
    omit?: interviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: interviewsInclude<ExtArgs> | null
    /**
     * Filter, which interviews to fetch.
     */
    where?: interviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of interviews to fetch.
     */
    orderBy?: interviewsOrderByWithRelationInput | interviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing interviews.
     */
    cursor?: interviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` interviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` interviews.
     */
    skip?: number
    distinct?: InterviewsScalarFieldEnum | InterviewsScalarFieldEnum[]
  }

  /**
   * interviews create
   */
  export type interviewsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the interviews
     */
    select?: interviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the interviews
     */
    omit?: interviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: interviewsInclude<ExtArgs> | null
    /**
     * The data needed to create a interviews.
     */
    data: XOR<interviewsCreateInput, interviewsUncheckedCreateInput>
  }

  /**
   * interviews createMany
   */
  export type interviewsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many interviews.
     */
    data: interviewsCreateManyInput | interviewsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * interviews createManyAndReturn
   */
  export type interviewsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the interviews
     */
    select?: interviewsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the interviews
     */
    omit?: interviewsOmit<ExtArgs> | null
    /**
     * The data used to create many interviews.
     */
    data: interviewsCreateManyInput | interviewsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: interviewsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * interviews update
   */
  export type interviewsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the interviews
     */
    select?: interviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the interviews
     */
    omit?: interviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: interviewsInclude<ExtArgs> | null
    /**
     * The data needed to update a interviews.
     */
    data: XOR<interviewsUpdateInput, interviewsUncheckedUpdateInput>
    /**
     * Choose, which interviews to update.
     */
    where: interviewsWhereUniqueInput
  }

  /**
   * interviews updateMany
   */
  export type interviewsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update interviews.
     */
    data: XOR<interviewsUpdateManyMutationInput, interviewsUncheckedUpdateManyInput>
    /**
     * Filter which interviews to update
     */
    where?: interviewsWhereInput
    /**
     * Limit how many interviews to update.
     */
    limit?: number
  }

  /**
   * interviews updateManyAndReturn
   */
  export type interviewsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the interviews
     */
    select?: interviewsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the interviews
     */
    omit?: interviewsOmit<ExtArgs> | null
    /**
     * The data used to update interviews.
     */
    data: XOR<interviewsUpdateManyMutationInput, interviewsUncheckedUpdateManyInput>
    /**
     * Filter which interviews to update
     */
    where?: interviewsWhereInput
    /**
     * Limit how many interviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: interviewsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * interviews upsert
   */
  export type interviewsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the interviews
     */
    select?: interviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the interviews
     */
    omit?: interviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: interviewsInclude<ExtArgs> | null
    /**
     * The filter to search for the interviews to update in case it exists.
     */
    where: interviewsWhereUniqueInput
    /**
     * In case the interviews found by the `where` argument doesn't exist, create a new interviews with this data.
     */
    create: XOR<interviewsCreateInput, interviewsUncheckedCreateInput>
    /**
     * In case the interviews was found with the provided `where` argument, update it with this data.
     */
    update: XOR<interviewsUpdateInput, interviewsUncheckedUpdateInput>
  }

  /**
   * interviews delete
   */
  export type interviewsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the interviews
     */
    select?: interviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the interviews
     */
    omit?: interviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: interviewsInclude<ExtArgs> | null
    /**
     * Filter which interviews to delete.
     */
    where: interviewsWhereUniqueInput
  }

  /**
   * interviews deleteMany
   */
  export type interviewsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which interviews to delete
     */
    where?: interviewsWhereInput
    /**
     * Limit how many interviews to delete.
     */
    limit?: number
  }

  /**
   * interviews without action
   */
  export type interviewsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the interviews
     */
    select?: interviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the interviews
     */
    omit?: interviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: interviewsInclude<ExtArgs> | null
  }


  /**
   * Model contacts
   */

  export type AggregateContacts = {
    _count: ContactsCountAggregateOutputType | null
    _avg: ContactsAvgAggregateOutputType | null
    _sum: ContactsSumAggregateOutputType | null
    _min: ContactsMinAggregateOutputType | null
    _max: ContactsMaxAggregateOutputType | null
  }

  export type ContactsAvgAggregateOutputType = {
    id: number | null
    job_id: number | null
    user_id: number | null
    company_id: number | null
    probation_period_months: number | null
    salary_amount: number | null
  }

  export type ContactsSumAggregateOutputType = {
    id: number | null
    job_id: number | null
    user_id: number | null
    company_id: number | null
    probation_period_months: number | null
    salary_amount: number | null
  }

  export type ContactsMinAggregateOutputType = {
    id: number | null
    job_id: number | null
    user_id: number | null
    company_id: number | null
    contact_type: $Enums.contactType | null
    start_date: Date | null
    end_date: Date | null
    probation_period_months: number | null
    salary_amount: number | null
    salary_currency: string | null
    salary_payment_period: $Enums.contactSalaryPaymentPeriod | null
    benefits_description: string | null
    visa_sponsorship_details: string | null
    relocation_assistance_details: string | null
    status: $Enums.contactStatus | null
    signed_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ContactsMaxAggregateOutputType = {
    id: number | null
    job_id: number | null
    user_id: number | null
    company_id: number | null
    contact_type: $Enums.contactType | null
    start_date: Date | null
    end_date: Date | null
    probation_period_months: number | null
    salary_amount: number | null
    salary_currency: string | null
    salary_payment_period: $Enums.contactSalaryPaymentPeriod | null
    benefits_description: string | null
    visa_sponsorship_details: string | null
    relocation_assistance_details: string | null
    status: $Enums.contactStatus | null
    signed_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ContactsCountAggregateOutputType = {
    id: number
    job_id: number
    user_id: number
    company_id: number
    contact_type: number
    start_date: number
    end_date: number
    probation_period_months: number
    salary_amount: number
    salary_currency: number
    salary_payment_period: number
    benefits_description: number
    visa_sponsorship_details: number
    relocation_assistance_details: number
    status: number
    signed_at: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ContactsAvgAggregateInputType = {
    id?: true
    job_id?: true
    user_id?: true
    company_id?: true
    probation_period_months?: true
    salary_amount?: true
  }

  export type ContactsSumAggregateInputType = {
    id?: true
    job_id?: true
    user_id?: true
    company_id?: true
    probation_period_months?: true
    salary_amount?: true
  }

  export type ContactsMinAggregateInputType = {
    id?: true
    job_id?: true
    user_id?: true
    company_id?: true
    contact_type?: true
    start_date?: true
    end_date?: true
    probation_period_months?: true
    salary_amount?: true
    salary_currency?: true
    salary_payment_period?: true
    benefits_description?: true
    visa_sponsorship_details?: true
    relocation_assistance_details?: true
    status?: true
    signed_at?: true
    created_at?: true
    updated_at?: true
  }

  export type ContactsMaxAggregateInputType = {
    id?: true
    job_id?: true
    user_id?: true
    company_id?: true
    contact_type?: true
    start_date?: true
    end_date?: true
    probation_period_months?: true
    salary_amount?: true
    salary_currency?: true
    salary_payment_period?: true
    benefits_description?: true
    visa_sponsorship_details?: true
    relocation_assistance_details?: true
    status?: true
    signed_at?: true
    created_at?: true
    updated_at?: true
  }

  export type ContactsCountAggregateInputType = {
    id?: true
    job_id?: true
    user_id?: true
    company_id?: true
    contact_type?: true
    start_date?: true
    end_date?: true
    probation_period_months?: true
    salary_amount?: true
    salary_currency?: true
    salary_payment_period?: true
    benefits_description?: true
    visa_sponsorship_details?: true
    relocation_assistance_details?: true
    status?: true
    signed_at?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ContactsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contacts to aggregate.
     */
    where?: contactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contacts to fetch.
     */
    orderBy?: contactsOrderByWithRelationInput | contactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: contactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned contacts
    **/
    _count?: true | ContactsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContactsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContactsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactsMaxAggregateInputType
  }

  export type GetContactsAggregateType<T extends ContactsAggregateArgs> = {
        [P in keyof T & keyof AggregateContacts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContacts[P]>
      : GetScalarType<T[P], AggregateContacts[P]>
  }




  export type contactsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contactsWhereInput
    orderBy?: contactsOrderByWithAggregationInput | contactsOrderByWithAggregationInput[]
    by: ContactsScalarFieldEnum[] | ContactsScalarFieldEnum
    having?: contactsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactsCountAggregateInputType | true
    _avg?: ContactsAvgAggregateInputType
    _sum?: ContactsSumAggregateInputType
    _min?: ContactsMinAggregateInputType
    _max?: ContactsMaxAggregateInputType
  }

  export type ContactsGroupByOutputType = {
    id: number
    job_id: number
    user_id: number
    company_id: number
    contact_type: $Enums.contactType
    start_date: Date
    end_date: Date
    probation_period_months: number
    salary_amount: number
    salary_currency: string
    salary_payment_period: $Enums.contactSalaryPaymentPeriod
    benefits_description: string
    visa_sponsorship_details: string
    relocation_assistance_details: string
    status: $Enums.contactStatus
    signed_at: Date
    created_at: Date
    updated_at: Date
    _count: ContactsCountAggregateOutputType | null
    _avg: ContactsAvgAggregateOutputType | null
    _sum: ContactsSumAggregateOutputType | null
    _min: ContactsMinAggregateOutputType | null
    _max: ContactsMaxAggregateOutputType | null
  }

  type GetContactsGroupByPayload<T extends contactsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactsGroupByOutputType[P]>
            : GetScalarType<T[P], ContactsGroupByOutputType[P]>
        }
      >
    >


  export type contactsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    job_id?: boolean
    user_id?: boolean
    company_id?: boolean
    contact_type?: boolean
    start_date?: boolean
    end_date?: boolean
    probation_period_months?: boolean
    salary_amount?: boolean
    salary_currency?: boolean
    salary_payment_period?: boolean
    benefits_description?: boolean
    visa_sponsorship_details?: boolean
    relocation_assistance_details?: boolean
    status?: boolean
    signed_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    contact?: boolean | jobsDefaultArgs<ExtArgs>
    contacts?: boolean | usersDefaultArgs<ExtArgs>
    contac?: boolean | companiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contacts"]>

  export type contactsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    job_id?: boolean
    user_id?: boolean
    company_id?: boolean
    contact_type?: boolean
    start_date?: boolean
    end_date?: boolean
    probation_period_months?: boolean
    salary_amount?: boolean
    salary_currency?: boolean
    salary_payment_period?: boolean
    benefits_description?: boolean
    visa_sponsorship_details?: boolean
    relocation_assistance_details?: boolean
    status?: boolean
    signed_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    contact?: boolean | jobsDefaultArgs<ExtArgs>
    contacts?: boolean | usersDefaultArgs<ExtArgs>
    contac?: boolean | companiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contacts"]>

  export type contactsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    job_id?: boolean
    user_id?: boolean
    company_id?: boolean
    contact_type?: boolean
    start_date?: boolean
    end_date?: boolean
    probation_period_months?: boolean
    salary_amount?: boolean
    salary_currency?: boolean
    salary_payment_period?: boolean
    benefits_description?: boolean
    visa_sponsorship_details?: boolean
    relocation_assistance_details?: boolean
    status?: boolean
    signed_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    contact?: boolean | jobsDefaultArgs<ExtArgs>
    contacts?: boolean | usersDefaultArgs<ExtArgs>
    contac?: boolean | companiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contacts"]>

  export type contactsSelectScalar = {
    id?: boolean
    job_id?: boolean
    user_id?: boolean
    company_id?: boolean
    contact_type?: boolean
    start_date?: boolean
    end_date?: boolean
    probation_period_months?: boolean
    salary_amount?: boolean
    salary_currency?: boolean
    salary_payment_period?: boolean
    benefits_description?: boolean
    visa_sponsorship_details?: boolean
    relocation_assistance_details?: boolean
    status?: boolean
    signed_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type contactsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "job_id" | "user_id" | "company_id" | "contact_type" | "start_date" | "end_date" | "probation_period_months" | "salary_amount" | "salary_currency" | "salary_payment_period" | "benefits_description" | "visa_sponsorship_details" | "relocation_assistance_details" | "status" | "signed_at" | "created_at" | "updated_at", ExtArgs["result"]["contacts"]>
  export type contactsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | jobsDefaultArgs<ExtArgs>
    contacts?: boolean | usersDefaultArgs<ExtArgs>
    contac?: boolean | companiesDefaultArgs<ExtArgs>
  }
  export type contactsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | jobsDefaultArgs<ExtArgs>
    contacts?: boolean | usersDefaultArgs<ExtArgs>
    contac?: boolean | companiesDefaultArgs<ExtArgs>
  }
  export type contactsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | jobsDefaultArgs<ExtArgs>
    contacts?: boolean | usersDefaultArgs<ExtArgs>
    contac?: boolean | companiesDefaultArgs<ExtArgs>
  }

  export type $contactsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "contacts"
    objects: {
      contact: Prisma.$jobsPayload<ExtArgs>
      contacts: Prisma.$usersPayload<ExtArgs>
      contac: Prisma.$companiesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      job_id: number
      user_id: number
      company_id: number
      contact_type: $Enums.contactType
      start_date: Date
      end_date: Date
      probation_period_months: number
      salary_amount: number
      salary_currency: string
      salary_payment_period: $Enums.contactSalaryPaymentPeriod
      benefits_description: string
      visa_sponsorship_details: string
      relocation_assistance_details: string
      status: $Enums.contactStatus
      signed_at: Date
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["contacts"]>
    composites: {}
  }

  type contactsGetPayload<S extends boolean | null | undefined | contactsDefaultArgs> = $Result.GetResult<Prisma.$contactsPayload, S>

  type contactsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<contactsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactsCountAggregateInputType | true
    }

  export interface contactsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['contacts'], meta: { name: 'contacts' } }
    /**
     * Find zero or one Contacts that matches the filter.
     * @param {contactsFindUniqueArgs} args - Arguments to find a Contacts
     * @example
     * // Get one Contacts
     * const contacts = await prisma.contacts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends contactsFindUniqueArgs>(args: SelectSubset<T, contactsFindUniqueArgs<ExtArgs>>): Prisma__contactsClient<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contacts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {contactsFindUniqueOrThrowArgs} args - Arguments to find a Contacts
     * @example
     * // Get one Contacts
     * const contacts = await prisma.contacts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends contactsFindUniqueOrThrowArgs>(args: SelectSubset<T, contactsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__contactsClient<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactsFindFirstArgs} args - Arguments to find a Contacts
     * @example
     * // Get one Contacts
     * const contacts = await prisma.contacts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends contactsFindFirstArgs>(args?: SelectSubset<T, contactsFindFirstArgs<ExtArgs>>): Prisma__contactsClient<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contacts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactsFindFirstOrThrowArgs} args - Arguments to find a Contacts
     * @example
     * // Get one Contacts
     * const contacts = await prisma.contacts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends contactsFindFirstOrThrowArgs>(args?: SelectSubset<T, contactsFindFirstOrThrowArgs<ExtArgs>>): Prisma__contactsClient<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contacts.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contacts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactsWithIdOnly = await prisma.contacts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends contactsFindManyArgs>(args?: SelectSubset<T, contactsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contacts.
     * @param {contactsCreateArgs} args - Arguments to create a Contacts.
     * @example
     * // Create one Contacts
     * const Contacts = await prisma.contacts.create({
     *   data: {
     *     // ... data to create a Contacts
     *   }
     * })
     * 
     */
    create<T extends contactsCreateArgs>(args: SelectSubset<T, contactsCreateArgs<ExtArgs>>): Prisma__contactsClient<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contacts.
     * @param {contactsCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contacts = await prisma.contacts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends contactsCreateManyArgs>(args?: SelectSubset<T, contactsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contacts and returns the data saved in the database.
     * @param {contactsCreateManyAndReturnArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contacts = await prisma.contacts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contacts and only return the `id`
     * const contactsWithIdOnly = await prisma.contacts.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends contactsCreateManyAndReturnArgs>(args?: SelectSubset<T, contactsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Contacts.
     * @param {contactsDeleteArgs} args - Arguments to delete one Contacts.
     * @example
     * // Delete one Contacts
     * const Contacts = await prisma.contacts.delete({
     *   where: {
     *     // ... filter to delete one Contacts
     *   }
     * })
     * 
     */
    delete<T extends contactsDeleteArgs>(args: SelectSubset<T, contactsDeleteArgs<ExtArgs>>): Prisma__contactsClient<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contacts.
     * @param {contactsUpdateArgs} args - Arguments to update one Contacts.
     * @example
     * // Update one Contacts
     * const contacts = await prisma.contacts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends contactsUpdateArgs>(args: SelectSubset<T, contactsUpdateArgs<ExtArgs>>): Prisma__contactsClient<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contacts.
     * @param {contactsDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contacts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends contactsDeleteManyArgs>(args?: SelectSubset<T, contactsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contacts = await prisma.contacts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends contactsUpdateManyArgs>(args: SelectSubset<T, contactsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts and returns the data updated in the database.
     * @param {contactsUpdateManyAndReturnArgs} args - Arguments to update many Contacts.
     * @example
     * // Update many Contacts
     * const contacts = await prisma.contacts.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contacts and only return the `id`
     * const contactsWithIdOnly = await prisma.contacts.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends contactsUpdateManyAndReturnArgs>(args: SelectSubset<T, contactsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Contacts.
     * @param {contactsUpsertArgs} args - Arguments to update or create a Contacts.
     * @example
     * // Update or create a Contacts
     * const contacts = await prisma.contacts.upsert({
     *   create: {
     *     // ... data to create a Contacts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contacts we want to update
     *   }
     * })
     */
    upsert<T extends contactsUpsertArgs>(args: SelectSubset<T, contactsUpsertArgs<ExtArgs>>): Prisma__contactsClient<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactsCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contacts.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends contactsCountArgs>(
      args?: Subset<T, contactsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactsAggregateArgs>(args: Subset<T, ContactsAggregateArgs>): Prisma.PrismaPromise<GetContactsAggregateType<T>>

    /**
     * Group by Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends contactsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: contactsGroupByArgs['orderBy'] }
        : { orderBy?: contactsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, contactsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the contacts model
   */
  readonly fields: contactsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for contacts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__contactsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contact<T extends jobsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, jobsDefaultArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contacts<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contac<T extends companiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, companiesDefaultArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the contacts model
   */
  interface contactsFieldRefs {
    readonly id: FieldRef<"contacts", 'Int'>
    readonly job_id: FieldRef<"contacts", 'Int'>
    readonly user_id: FieldRef<"contacts", 'Int'>
    readonly company_id: FieldRef<"contacts", 'Int'>
    readonly contact_type: FieldRef<"contacts", 'contactType'>
    readonly start_date: FieldRef<"contacts", 'DateTime'>
    readonly end_date: FieldRef<"contacts", 'DateTime'>
    readonly probation_period_months: FieldRef<"contacts", 'Int'>
    readonly salary_amount: FieldRef<"contacts", 'Int'>
    readonly salary_currency: FieldRef<"contacts", 'String'>
    readonly salary_payment_period: FieldRef<"contacts", 'contactSalaryPaymentPeriod'>
    readonly benefits_description: FieldRef<"contacts", 'String'>
    readonly visa_sponsorship_details: FieldRef<"contacts", 'String'>
    readonly relocation_assistance_details: FieldRef<"contacts", 'String'>
    readonly status: FieldRef<"contacts", 'contactStatus'>
    readonly signed_at: FieldRef<"contacts", 'DateTime'>
    readonly created_at: FieldRef<"contacts", 'DateTime'>
    readonly updated_at: FieldRef<"contacts", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * contacts findUnique
   */
  export type contactsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contacts
     */
    omit?: contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactsInclude<ExtArgs> | null
    /**
     * Filter, which contacts to fetch.
     */
    where: contactsWhereUniqueInput
  }

  /**
   * contacts findUniqueOrThrow
   */
  export type contactsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contacts
     */
    omit?: contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactsInclude<ExtArgs> | null
    /**
     * Filter, which contacts to fetch.
     */
    where: contactsWhereUniqueInput
  }

  /**
   * contacts findFirst
   */
  export type contactsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contacts
     */
    omit?: contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactsInclude<ExtArgs> | null
    /**
     * Filter, which contacts to fetch.
     */
    where?: contactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contacts to fetch.
     */
    orderBy?: contactsOrderByWithRelationInput | contactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contacts.
     */
    cursor?: contactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contacts.
     */
    distinct?: ContactsScalarFieldEnum | ContactsScalarFieldEnum[]
  }

  /**
   * contacts findFirstOrThrow
   */
  export type contactsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contacts
     */
    omit?: contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactsInclude<ExtArgs> | null
    /**
     * Filter, which contacts to fetch.
     */
    where?: contactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contacts to fetch.
     */
    orderBy?: contactsOrderByWithRelationInput | contactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contacts.
     */
    cursor?: contactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contacts.
     */
    distinct?: ContactsScalarFieldEnum | ContactsScalarFieldEnum[]
  }

  /**
   * contacts findMany
   */
  export type contactsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contacts
     */
    omit?: contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactsInclude<ExtArgs> | null
    /**
     * Filter, which contacts to fetch.
     */
    where?: contactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contacts to fetch.
     */
    orderBy?: contactsOrderByWithRelationInput | contactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing contacts.
     */
    cursor?: contactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contacts.
     */
    skip?: number
    distinct?: ContactsScalarFieldEnum | ContactsScalarFieldEnum[]
  }

  /**
   * contacts create
   */
  export type contactsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contacts
     */
    omit?: contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactsInclude<ExtArgs> | null
    /**
     * The data needed to create a contacts.
     */
    data: XOR<contactsCreateInput, contactsUncheckedCreateInput>
  }

  /**
   * contacts createMany
   */
  export type contactsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many contacts.
     */
    data: contactsCreateManyInput | contactsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * contacts createManyAndReturn
   */
  export type contactsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the contacts
     */
    omit?: contactsOmit<ExtArgs> | null
    /**
     * The data used to create many contacts.
     */
    data: contactsCreateManyInput | contactsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * contacts update
   */
  export type contactsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contacts
     */
    omit?: contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactsInclude<ExtArgs> | null
    /**
     * The data needed to update a contacts.
     */
    data: XOR<contactsUpdateInput, contactsUncheckedUpdateInput>
    /**
     * Choose, which contacts to update.
     */
    where: contactsWhereUniqueInput
  }

  /**
   * contacts updateMany
   */
  export type contactsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update contacts.
     */
    data: XOR<contactsUpdateManyMutationInput, contactsUncheckedUpdateManyInput>
    /**
     * Filter which contacts to update
     */
    where?: contactsWhereInput
    /**
     * Limit how many contacts to update.
     */
    limit?: number
  }

  /**
   * contacts updateManyAndReturn
   */
  export type contactsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the contacts
     */
    omit?: contactsOmit<ExtArgs> | null
    /**
     * The data used to update contacts.
     */
    data: XOR<contactsUpdateManyMutationInput, contactsUncheckedUpdateManyInput>
    /**
     * Filter which contacts to update
     */
    where?: contactsWhereInput
    /**
     * Limit how many contacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * contacts upsert
   */
  export type contactsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contacts
     */
    omit?: contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactsInclude<ExtArgs> | null
    /**
     * The filter to search for the contacts to update in case it exists.
     */
    where: contactsWhereUniqueInput
    /**
     * In case the contacts found by the `where` argument doesn't exist, create a new contacts with this data.
     */
    create: XOR<contactsCreateInput, contactsUncheckedCreateInput>
    /**
     * In case the contacts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<contactsUpdateInput, contactsUncheckedUpdateInput>
  }

  /**
   * contacts delete
   */
  export type contactsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contacts
     */
    omit?: contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactsInclude<ExtArgs> | null
    /**
     * Filter which contacts to delete.
     */
    where: contactsWhereUniqueInput
  }

  /**
   * contacts deleteMany
   */
  export type contactsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contacts to delete
     */
    where?: contactsWhereInput
    /**
     * Limit how many contacts to delete.
     */
    limit?: number
  }

  /**
   * contacts without action
   */
  export type contactsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contacts
     */
    omit?: contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactsInclude<ExtArgs> | null
  }


  /**
   * Model notifications
   */

  export type AggregateNotifications = {
    _count: NotificationsCountAggregateOutputType | null
    _avg: NotificationsAvgAggregateOutputType | null
    _sum: NotificationsSumAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  export type NotificationsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    related_entity_id: number | null
  }

  export type NotificationsSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    related_entity_id: number | null
  }

  export type NotificationsMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    notification_type: string | null
    title: string | null
    message: string | null
    is_read: boolean | null
    related_entity_type: string | null
    related_entity_id: number | null
    created_at: Date | null
  }

  export type NotificationsMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    notification_type: string | null
    title: string | null
    message: string | null
    is_read: boolean | null
    related_entity_type: string | null
    related_entity_id: number | null
    created_at: Date | null
  }

  export type NotificationsCountAggregateOutputType = {
    id: number
    user_id: number
    notification_type: number
    title: number
    message: number
    is_read: number
    related_entity_type: number
    related_entity_id: number
    created_at: number
    _all: number
  }


  export type NotificationsAvgAggregateInputType = {
    id?: true
    user_id?: true
    related_entity_id?: true
  }

  export type NotificationsSumAggregateInputType = {
    id?: true
    user_id?: true
    related_entity_id?: true
  }

  export type NotificationsMinAggregateInputType = {
    id?: true
    user_id?: true
    notification_type?: true
    title?: true
    message?: true
    is_read?: true
    related_entity_type?: true
    related_entity_id?: true
    created_at?: true
  }

  export type NotificationsMaxAggregateInputType = {
    id?: true
    user_id?: true
    notification_type?: true
    title?: true
    message?: true
    is_read?: true
    related_entity_type?: true
    related_entity_id?: true
    created_at?: true
  }

  export type NotificationsCountAggregateInputType = {
    id?: true
    user_id?: true
    notification_type?: true
    title?: true
    message?: true
    is_read?: true
    related_entity_type?: true
    related_entity_id?: true
    created_at?: true
    _all?: true
  }

  export type NotificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to aggregate.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notifications
    **/
    _count?: true | NotificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationsMaxAggregateInputType
  }

  export type GetNotificationsAggregateType<T extends NotificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateNotifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotifications[P]>
      : GetScalarType<T[P], AggregateNotifications[P]>
  }




  export type notificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationsWhereInput
    orderBy?: notificationsOrderByWithAggregationInput | notificationsOrderByWithAggregationInput[]
    by: NotificationsScalarFieldEnum[] | NotificationsScalarFieldEnum
    having?: notificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationsCountAggregateInputType | true
    _avg?: NotificationsAvgAggregateInputType
    _sum?: NotificationsSumAggregateInputType
    _min?: NotificationsMinAggregateInputType
    _max?: NotificationsMaxAggregateInputType
  }

  export type NotificationsGroupByOutputType = {
    id: number
    user_id: number
    notification_type: string
    title: string
    message: string
    is_read: boolean
    related_entity_type: string
    related_entity_id: number
    created_at: Date
    _count: NotificationsCountAggregateOutputType | null
    _avg: NotificationsAvgAggregateOutputType | null
    _sum: NotificationsSumAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  type GetNotificationsGroupByPayload<T extends notificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
        }
      >
    >


  export type notificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    notification_type?: boolean
    title?: boolean
    message?: boolean
    is_read?: boolean
    related_entity_type?: boolean
    related_entity_id?: boolean
    created_at?: boolean
    notification?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>

  export type notificationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    notification_type?: boolean
    title?: boolean
    message?: boolean
    is_read?: boolean
    related_entity_type?: boolean
    related_entity_id?: boolean
    created_at?: boolean
    notification?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>

  export type notificationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    notification_type?: boolean
    title?: boolean
    message?: boolean
    is_read?: boolean
    related_entity_type?: boolean
    related_entity_id?: boolean
    created_at?: boolean
    notification?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>

  export type notificationsSelectScalar = {
    id?: boolean
    user_id?: boolean
    notification_type?: boolean
    title?: boolean
    message?: boolean
    is_read?: boolean
    related_entity_type?: boolean
    related_entity_id?: boolean
    created_at?: boolean
  }

  export type notificationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "notification_type" | "title" | "message" | "is_read" | "related_entity_type" | "related_entity_id" | "created_at", ExtArgs["result"]["notifications"]>
  export type notificationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notification?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type notificationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notification?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type notificationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notification?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $notificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notifications"
    objects: {
      notification: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      notification_type: string
      title: string
      message: string
      is_read: boolean
      related_entity_type: string
      related_entity_id: number
      created_at: Date
    }, ExtArgs["result"]["notifications"]>
    composites: {}
  }

  type notificationsGetPayload<S extends boolean | null | undefined | notificationsDefaultArgs> = $Result.GetResult<Prisma.$notificationsPayload, S>

  type notificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<notificationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationsCountAggregateInputType | true
    }

  export interface notificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notifications'], meta: { name: 'notifications' } }
    /**
     * Find zero or one Notifications that matches the filter.
     * @param {notificationsFindUniqueArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notificationsFindUniqueArgs>(args: SelectSubset<T, notificationsFindUniqueArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notifications that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {notificationsFindUniqueOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notificationsFindUniqueOrThrowArgs>(args: SelectSubset<T, notificationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindFirstArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notificationsFindFirstArgs>(args?: SelectSubset<T, notificationsFindFirstArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindFirstOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notificationsFindFirstOrThrowArgs>(args?: SelectSubset<T, notificationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notifications.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationsWithIdOnly = await prisma.notifications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends notificationsFindManyArgs>(args?: SelectSubset<T, notificationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notifications.
     * @param {notificationsCreateArgs} args - Arguments to create a Notifications.
     * @example
     * // Create one Notifications
     * const Notifications = await prisma.notifications.create({
     *   data: {
     *     // ... data to create a Notifications
     *   }
     * })
     * 
     */
    create<T extends notificationsCreateArgs>(args: SelectSubset<T, notificationsCreateArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {notificationsCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notificationsCreateManyArgs>(args?: SelectSubset<T, notificationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {notificationsCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationsWithIdOnly = await prisma.notifications.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends notificationsCreateManyAndReturnArgs>(args?: SelectSubset<T, notificationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notifications.
     * @param {notificationsDeleteArgs} args - Arguments to delete one Notifications.
     * @example
     * // Delete one Notifications
     * const Notifications = await prisma.notifications.delete({
     *   where: {
     *     // ... filter to delete one Notifications
     *   }
     * })
     * 
     */
    delete<T extends notificationsDeleteArgs>(args: SelectSubset<T, notificationsDeleteArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notifications.
     * @param {notificationsUpdateArgs} args - Arguments to update one Notifications.
     * @example
     * // Update one Notifications
     * const notifications = await prisma.notifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notificationsUpdateArgs>(args: SelectSubset<T, notificationsUpdateArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {notificationsDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notificationsDeleteManyArgs>(args?: SelectSubset<T, notificationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notifications = await prisma.notifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notificationsUpdateManyArgs>(args: SelectSubset<T, notificationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {notificationsUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notifications = await prisma.notifications.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationsWithIdOnly = await prisma.notifications.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends notificationsUpdateManyAndReturnArgs>(args: SelectSubset<T, notificationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notifications.
     * @param {notificationsUpsertArgs} args - Arguments to update or create a Notifications.
     * @example
     * // Update or create a Notifications
     * const notifications = await prisma.notifications.upsert({
     *   create: {
     *     // ... data to create a Notifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notifications we want to update
     *   }
     * })
     */
    upsert<T extends notificationsUpsertArgs>(args: SelectSubset<T, notificationsUpsertArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notifications.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends notificationsCountArgs>(
      args?: Subset<T, notificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationsAggregateArgs>(args: Subset<T, NotificationsAggregateArgs>): Prisma.PrismaPromise<GetNotificationsAggregateType<T>>

    /**
     * Group by Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notificationsGroupByArgs['orderBy'] }
        : { orderBy?: notificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notifications model
   */
  readonly fields: notificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    notification<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notifications model
   */
  interface notificationsFieldRefs {
    readonly id: FieldRef<"notifications", 'Int'>
    readonly user_id: FieldRef<"notifications", 'Int'>
    readonly notification_type: FieldRef<"notifications", 'String'>
    readonly title: FieldRef<"notifications", 'String'>
    readonly message: FieldRef<"notifications", 'String'>
    readonly is_read: FieldRef<"notifications", 'Boolean'>
    readonly related_entity_type: FieldRef<"notifications", 'String'>
    readonly related_entity_id: FieldRef<"notifications", 'Int'>
    readonly created_at: FieldRef<"notifications", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * notifications findUnique
   */
  export type notificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications findUniqueOrThrow
   */
  export type notificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications findFirst
   */
  export type notificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications findFirstOrThrow
   */
  export type notificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications findMany
   */
  export type notificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications create
   */
  export type notificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The data needed to create a notifications.
     */
    data: XOR<notificationsCreateInput, notificationsUncheckedCreateInput>
  }

  /**
   * notifications createMany
   */
  export type notificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notifications.
     */
    data: notificationsCreateManyInput | notificationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notifications createManyAndReturn
   */
  export type notificationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * The data used to create many notifications.
     */
    data: notificationsCreateManyInput | notificationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * notifications update
   */
  export type notificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The data needed to update a notifications.
     */
    data: XOR<notificationsUpdateInput, notificationsUncheckedUpdateInput>
    /**
     * Choose, which notifications to update.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications updateMany
   */
  export type notificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notifications.
     */
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyInput>
    /**
     * Filter which notifications to update
     */
    where?: notificationsWhereInput
    /**
     * Limit how many notifications to update.
     */
    limit?: number
  }

  /**
   * notifications updateManyAndReturn
   */
  export type notificationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * The data used to update notifications.
     */
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyInput>
    /**
     * Filter which notifications to update
     */
    where?: notificationsWhereInput
    /**
     * Limit how many notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * notifications upsert
   */
  export type notificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The filter to search for the notifications to update in case it exists.
     */
    where: notificationsWhereUniqueInput
    /**
     * In case the notifications found by the `where` argument doesn't exist, create a new notifications with this data.
     */
    create: XOR<notificationsCreateInput, notificationsUncheckedCreateInput>
    /**
     * In case the notifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notificationsUpdateInput, notificationsUncheckedUpdateInput>
  }

  /**
   * notifications delete
   */
  export type notificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter which notifications to delete.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications deleteMany
   */
  export type notificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to delete
     */
    where?: notificationsWhereInput
    /**
     * Limit how many notifications to delete.
     */
    limit?: number
  }

  /**
   * notifications without action
   */
  export type notificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
  }


  /**
   * Model saved_jobs
   */

  export type AggregateSaved_jobs = {
    _count: Saved_jobsCountAggregateOutputType | null
    _avg: Saved_jobsAvgAggregateOutputType | null
    _sum: Saved_jobsSumAggregateOutputType | null
    _min: Saved_jobsMinAggregateOutputType | null
    _max: Saved_jobsMaxAggregateOutputType | null
  }

  export type Saved_jobsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    job_id: number | null
  }

  export type Saved_jobsSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    job_id: number | null
  }

  export type Saved_jobsMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    job_id: number | null
    saved_at: Date | null
    notes: string | null
  }

  export type Saved_jobsMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    job_id: number | null
    saved_at: Date | null
    notes: string | null
  }

  export type Saved_jobsCountAggregateOutputType = {
    id: number
    user_id: number
    job_id: number
    saved_at: number
    notes: number
    _all: number
  }


  export type Saved_jobsAvgAggregateInputType = {
    id?: true
    user_id?: true
    job_id?: true
  }

  export type Saved_jobsSumAggregateInputType = {
    id?: true
    user_id?: true
    job_id?: true
  }

  export type Saved_jobsMinAggregateInputType = {
    id?: true
    user_id?: true
    job_id?: true
    saved_at?: true
    notes?: true
  }

  export type Saved_jobsMaxAggregateInputType = {
    id?: true
    user_id?: true
    job_id?: true
    saved_at?: true
    notes?: true
  }

  export type Saved_jobsCountAggregateInputType = {
    id?: true
    user_id?: true
    job_id?: true
    saved_at?: true
    notes?: true
    _all?: true
  }

  export type Saved_jobsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which saved_jobs to aggregate.
     */
    where?: saved_jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of saved_jobs to fetch.
     */
    orderBy?: saved_jobsOrderByWithRelationInput | saved_jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: saved_jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` saved_jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` saved_jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned saved_jobs
    **/
    _count?: true | Saved_jobsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Saved_jobsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Saved_jobsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Saved_jobsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Saved_jobsMaxAggregateInputType
  }

  export type GetSaved_jobsAggregateType<T extends Saved_jobsAggregateArgs> = {
        [P in keyof T & keyof AggregateSaved_jobs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSaved_jobs[P]>
      : GetScalarType<T[P], AggregateSaved_jobs[P]>
  }




  export type saved_jobsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: saved_jobsWhereInput
    orderBy?: saved_jobsOrderByWithAggregationInput | saved_jobsOrderByWithAggregationInput[]
    by: Saved_jobsScalarFieldEnum[] | Saved_jobsScalarFieldEnum
    having?: saved_jobsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Saved_jobsCountAggregateInputType | true
    _avg?: Saved_jobsAvgAggregateInputType
    _sum?: Saved_jobsSumAggregateInputType
    _min?: Saved_jobsMinAggregateInputType
    _max?: Saved_jobsMaxAggregateInputType
  }

  export type Saved_jobsGroupByOutputType = {
    id: number
    user_id: number
    job_id: number
    saved_at: Date
    notes: string
    _count: Saved_jobsCountAggregateOutputType | null
    _avg: Saved_jobsAvgAggregateOutputType | null
    _sum: Saved_jobsSumAggregateOutputType | null
    _min: Saved_jobsMinAggregateOutputType | null
    _max: Saved_jobsMaxAggregateOutputType | null
  }

  type GetSaved_jobsGroupByPayload<T extends saved_jobsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Saved_jobsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Saved_jobsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Saved_jobsGroupByOutputType[P]>
            : GetScalarType<T[P], Saved_jobsGroupByOutputType[P]>
        }
      >
    >


  export type saved_jobsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    job_id?: boolean
    saved_at?: boolean
    notes?: boolean
    savedjob?: boolean | usersDefaultArgs<ExtArgs>
    savedjobs?: boolean | jobsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saved_jobs"]>

  export type saved_jobsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    job_id?: boolean
    saved_at?: boolean
    notes?: boolean
    savedjob?: boolean | usersDefaultArgs<ExtArgs>
    savedjobs?: boolean | jobsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saved_jobs"]>

  export type saved_jobsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    job_id?: boolean
    saved_at?: boolean
    notes?: boolean
    savedjob?: boolean | usersDefaultArgs<ExtArgs>
    savedjobs?: boolean | jobsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saved_jobs"]>

  export type saved_jobsSelectScalar = {
    id?: boolean
    user_id?: boolean
    job_id?: boolean
    saved_at?: boolean
    notes?: boolean
  }

  export type saved_jobsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "job_id" | "saved_at" | "notes", ExtArgs["result"]["saved_jobs"]>
  export type saved_jobsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    savedjob?: boolean | usersDefaultArgs<ExtArgs>
    savedjobs?: boolean | jobsDefaultArgs<ExtArgs>
  }
  export type saved_jobsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    savedjob?: boolean | usersDefaultArgs<ExtArgs>
    savedjobs?: boolean | jobsDefaultArgs<ExtArgs>
  }
  export type saved_jobsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    savedjob?: boolean | usersDefaultArgs<ExtArgs>
    savedjobs?: boolean | jobsDefaultArgs<ExtArgs>
  }

  export type $saved_jobsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "saved_jobs"
    objects: {
      savedjob: Prisma.$usersPayload<ExtArgs>
      savedjobs: Prisma.$jobsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      job_id: number
      saved_at: Date
      notes: string
    }, ExtArgs["result"]["saved_jobs"]>
    composites: {}
  }

  type saved_jobsGetPayload<S extends boolean | null | undefined | saved_jobsDefaultArgs> = $Result.GetResult<Prisma.$saved_jobsPayload, S>

  type saved_jobsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<saved_jobsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Saved_jobsCountAggregateInputType | true
    }

  export interface saved_jobsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['saved_jobs'], meta: { name: 'saved_jobs' } }
    /**
     * Find zero or one Saved_jobs that matches the filter.
     * @param {saved_jobsFindUniqueArgs} args - Arguments to find a Saved_jobs
     * @example
     * // Get one Saved_jobs
     * const saved_jobs = await prisma.saved_jobs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends saved_jobsFindUniqueArgs>(args: SelectSubset<T, saved_jobsFindUniqueArgs<ExtArgs>>): Prisma__saved_jobsClient<$Result.GetResult<Prisma.$saved_jobsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Saved_jobs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {saved_jobsFindUniqueOrThrowArgs} args - Arguments to find a Saved_jobs
     * @example
     * // Get one Saved_jobs
     * const saved_jobs = await prisma.saved_jobs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends saved_jobsFindUniqueOrThrowArgs>(args: SelectSubset<T, saved_jobsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__saved_jobsClient<$Result.GetResult<Prisma.$saved_jobsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Saved_jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saved_jobsFindFirstArgs} args - Arguments to find a Saved_jobs
     * @example
     * // Get one Saved_jobs
     * const saved_jobs = await prisma.saved_jobs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends saved_jobsFindFirstArgs>(args?: SelectSubset<T, saved_jobsFindFirstArgs<ExtArgs>>): Prisma__saved_jobsClient<$Result.GetResult<Prisma.$saved_jobsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Saved_jobs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saved_jobsFindFirstOrThrowArgs} args - Arguments to find a Saved_jobs
     * @example
     * // Get one Saved_jobs
     * const saved_jobs = await prisma.saved_jobs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends saved_jobsFindFirstOrThrowArgs>(args?: SelectSubset<T, saved_jobsFindFirstOrThrowArgs<ExtArgs>>): Prisma__saved_jobsClient<$Result.GetResult<Prisma.$saved_jobsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Saved_jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saved_jobsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Saved_jobs
     * const saved_jobs = await prisma.saved_jobs.findMany()
     * 
     * // Get first 10 Saved_jobs
     * const saved_jobs = await prisma.saved_jobs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saved_jobsWithIdOnly = await prisma.saved_jobs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends saved_jobsFindManyArgs>(args?: SelectSubset<T, saved_jobsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$saved_jobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Saved_jobs.
     * @param {saved_jobsCreateArgs} args - Arguments to create a Saved_jobs.
     * @example
     * // Create one Saved_jobs
     * const Saved_jobs = await prisma.saved_jobs.create({
     *   data: {
     *     // ... data to create a Saved_jobs
     *   }
     * })
     * 
     */
    create<T extends saved_jobsCreateArgs>(args: SelectSubset<T, saved_jobsCreateArgs<ExtArgs>>): Prisma__saved_jobsClient<$Result.GetResult<Prisma.$saved_jobsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Saved_jobs.
     * @param {saved_jobsCreateManyArgs} args - Arguments to create many Saved_jobs.
     * @example
     * // Create many Saved_jobs
     * const saved_jobs = await prisma.saved_jobs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends saved_jobsCreateManyArgs>(args?: SelectSubset<T, saved_jobsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Saved_jobs and returns the data saved in the database.
     * @param {saved_jobsCreateManyAndReturnArgs} args - Arguments to create many Saved_jobs.
     * @example
     * // Create many Saved_jobs
     * const saved_jobs = await prisma.saved_jobs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Saved_jobs and only return the `id`
     * const saved_jobsWithIdOnly = await prisma.saved_jobs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends saved_jobsCreateManyAndReturnArgs>(args?: SelectSubset<T, saved_jobsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$saved_jobsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Saved_jobs.
     * @param {saved_jobsDeleteArgs} args - Arguments to delete one Saved_jobs.
     * @example
     * // Delete one Saved_jobs
     * const Saved_jobs = await prisma.saved_jobs.delete({
     *   where: {
     *     // ... filter to delete one Saved_jobs
     *   }
     * })
     * 
     */
    delete<T extends saved_jobsDeleteArgs>(args: SelectSubset<T, saved_jobsDeleteArgs<ExtArgs>>): Prisma__saved_jobsClient<$Result.GetResult<Prisma.$saved_jobsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Saved_jobs.
     * @param {saved_jobsUpdateArgs} args - Arguments to update one Saved_jobs.
     * @example
     * // Update one Saved_jobs
     * const saved_jobs = await prisma.saved_jobs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends saved_jobsUpdateArgs>(args: SelectSubset<T, saved_jobsUpdateArgs<ExtArgs>>): Prisma__saved_jobsClient<$Result.GetResult<Prisma.$saved_jobsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Saved_jobs.
     * @param {saved_jobsDeleteManyArgs} args - Arguments to filter Saved_jobs to delete.
     * @example
     * // Delete a few Saved_jobs
     * const { count } = await prisma.saved_jobs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends saved_jobsDeleteManyArgs>(args?: SelectSubset<T, saved_jobsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Saved_jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saved_jobsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Saved_jobs
     * const saved_jobs = await prisma.saved_jobs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends saved_jobsUpdateManyArgs>(args: SelectSubset<T, saved_jobsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Saved_jobs and returns the data updated in the database.
     * @param {saved_jobsUpdateManyAndReturnArgs} args - Arguments to update many Saved_jobs.
     * @example
     * // Update many Saved_jobs
     * const saved_jobs = await prisma.saved_jobs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Saved_jobs and only return the `id`
     * const saved_jobsWithIdOnly = await prisma.saved_jobs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends saved_jobsUpdateManyAndReturnArgs>(args: SelectSubset<T, saved_jobsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$saved_jobsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Saved_jobs.
     * @param {saved_jobsUpsertArgs} args - Arguments to update or create a Saved_jobs.
     * @example
     * // Update or create a Saved_jobs
     * const saved_jobs = await prisma.saved_jobs.upsert({
     *   create: {
     *     // ... data to create a Saved_jobs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Saved_jobs we want to update
     *   }
     * })
     */
    upsert<T extends saved_jobsUpsertArgs>(args: SelectSubset<T, saved_jobsUpsertArgs<ExtArgs>>): Prisma__saved_jobsClient<$Result.GetResult<Prisma.$saved_jobsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Saved_jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saved_jobsCountArgs} args - Arguments to filter Saved_jobs to count.
     * @example
     * // Count the number of Saved_jobs
     * const count = await prisma.saved_jobs.count({
     *   where: {
     *     // ... the filter for the Saved_jobs we want to count
     *   }
     * })
    **/
    count<T extends saved_jobsCountArgs>(
      args?: Subset<T, saved_jobsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Saved_jobsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Saved_jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Saved_jobsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Saved_jobsAggregateArgs>(args: Subset<T, Saved_jobsAggregateArgs>): Prisma.PrismaPromise<GetSaved_jobsAggregateType<T>>

    /**
     * Group by Saved_jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saved_jobsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends saved_jobsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: saved_jobsGroupByArgs['orderBy'] }
        : { orderBy?: saved_jobsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, saved_jobsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaved_jobsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the saved_jobs model
   */
  readonly fields: saved_jobsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for saved_jobs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__saved_jobsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    savedjob<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    savedjobs<T extends jobsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, jobsDefaultArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the saved_jobs model
   */
  interface saved_jobsFieldRefs {
    readonly id: FieldRef<"saved_jobs", 'Int'>
    readonly user_id: FieldRef<"saved_jobs", 'Int'>
    readonly job_id: FieldRef<"saved_jobs", 'Int'>
    readonly saved_at: FieldRef<"saved_jobs", 'DateTime'>
    readonly notes: FieldRef<"saved_jobs", 'String'>
  }
    

  // Custom InputTypes
  /**
   * saved_jobs findUnique
   */
  export type saved_jobsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saved_jobs
     */
    select?: saved_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saved_jobs
     */
    omit?: saved_jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saved_jobsInclude<ExtArgs> | null
    /**
     * Filter, which saved_jobs to fetch.
     */
    where: saved_jobsWhereUniqueInput
  }

  /**
   * saved_jobs findUniqueOrThrow
   */
  export type saved_jobsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saved_jobs
     */
    select?: saved_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saved_jobs
     */
    omit?: saved_jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saved_jobsInclude<ExtArgs> | null
    /**
     * Filter, which saved_jobs to fetch.
     */
    where: saved_jobsWhereUniqueInput
  }

  /**
   * saved_jobs findFirst
   */
  export type saved_jobsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saved_jobs
     */
    select?: saved_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saved_jobs
     */
    omit?: saved_jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saved_jobsInclude<ExtArgs> | null
    /**
     * Filter, which saved_jobs to fetch.
     */
    where?: saved_jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of saved_jobs to fetch.
     */
    orderBy?: saved_jobsOrderByWithRelationInput | saved_jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for saved_jobs.
     */
    cursor?: saved_jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` saved_jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` saved_jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of saved_jobs.
     */
    distinct?: Saved_jobsScalarFieldEnum | Saved_jobsScalarFieldEnum[]
  }

  /**
   * saved_jobs findFirstOrThrow
   */
  export type saved_jobsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saved_jobs
     */
    select?: saved_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saved_jobs
     */
    omit?: saved_jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saved_jobsInclude<ExtArgs> | null
    /**
     * Filter, which saved_jobs to fetch.
     */
    where?: saved_jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of saved_jobs to fetch.
     */
    orderBy?: saved_jobsOrderByWithRelationInput | saved_jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for saved_jobs.
     */
    cursor?: saved_jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` saved_jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` saved_jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of saved_jobs.
     */
    distinct?: Saved_jobsScalarFieldEnum | Saved_jobsScalarFieldEnum[]
  }

  /**
   * saved_jobs findMany
   */
  export type saved_jobsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saved_jobs
     */
    select?: saved_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saved_jobs
     */
    omit?: saved_jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saved_jobsInclude<ExtArgs> | null
    /**
     * Filter, which saved_jobs to fetch.
     */
    where?: saved_jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of saved_jobs to fetch.
     */
    orderBy?: saved_jobsOrderByWithRelationInput | saved_jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing saved_jobs.
     */
    cursor?: saved_jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` saved_jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` saved_jobs.
     */
    skip?: number
    distinct?: Saved_jobsScalarFieldEnum | Saved_jobsScalarFieldEnum[]
  }

  /**
   * saved_jobs create
   */
  export type saved_jobsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saved_jobs
     */
    select?: saved_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saved_jobs
     */
    omit?: saved_jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saved_jobsInclude<ExtArgs> | null
    /**
     * The data needed to create a saved_jobs.
     */
    data: XOR<saved_jobsCreateInput, saved_jobsUncheckedCreateInput>
  }

  /**
   * saved_jobs createMany
   */
  export type saved_jobsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many saved_jobs.
     */
    data: saved_jobsCreateManyInput | saved_jobsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * saved_jobs createManyAndReturn
   */
  export type saved_jobsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saved_jobs
     */
    select?: saved_jobsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the saved_jobs
     */
    omit?: saved_jobsOmit<ExtArgs> | null
    /**
     * The data used to create many saved_jobs.
     */
    data: saved_jobsCreateManyInput | saved_jobsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saved_jobsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * saved_jobs update
   */
  export type saved_jobsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saved_jobs
     */
    select?: saved_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saved_jobs
     */
    omit?: saved_jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saved_jobsInclude<ExtArgs> | null
    /**
     * The data needed to update a saved_jobs.
     */
    data: XOR<saved_jobsUpdateInput, saved_jobsUncheckedUpdateInput>
    /**
     * Choose, which saved_jobs to update.
     */
    where: saved_jobsWhereUniqueInput
  }

  /**
   * saved_jobs updateMany
   */
  export type saved_jobsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update saved_jobs.
     */
    data: XOR<saved_jobsUpdateManyMutationInput, saved_jobsUncheckedUpdateManyInput>
    /**
     * Filter which saved_jobs to update
     */
    where?: saved_jobsWhereInput
    /**
     * Limit how many saved_jobs to update.
     */
    limit?: number
  }

  /**
   * saved_jobs updateManyAndReturn
   */
  export type saved_jobsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saved_jobs
     */
    select?: saved_jobsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the saved_jobs
     */
    omit?: saved_jobsOmit<ExtArgs> | null
    /**
     * The data used to update saved_jobs.
     */
    data: XOR<saved_jobsUpdateManyMutationInput, saved_jobsUncheckedUpdateManyInput>
    /**
     * Filter which saved_jobs to update
     */
    where?: saved_jobsWhereInput
    /**
     * Limit how many saved_jobs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saved_jobsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * saved_jobs upsert
   */
  export type saved_jobsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saved_jobs
     */
    select?: saved_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saved_jobs
     */
    omit?: saved_jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saved_jobsInclude<ExtArgs> | null
    /**
     * The filter to search for the saved_jobs to update in case it exists.
     */
    where: saved_jobsWhereUniqueInput
    /**
     * In case the saved_jobs found by the `where` argument doesn't exist, create a new saved_jobs with this data.
     */
    create: XOR<saved_jobsCreateInput, saved_jobsUncheckedCreateInput>
    /**
     * In case the saved_jobs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<saved_jobsUpdateInput, saved_jobsUncheckedUpdateInput>
  }

  /**
   * saved_jobs delete
   */
  export type saved_jobsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saved_jobs
     */
    select?: saved_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saved_jobs
     */
    omit?: saved_jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saved_jobsInclude<ExtArgs> | null
    /**
     * Filter which saved_jobs to delete.
     */
    where: saved_jobsWhereUniqueInput
  }

  /**
   * saved_jobs deleteMany
   */
  export type saved_jobsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which saved_jobs to delete
     */
    where?: saved_jobsWhereInput
    /**
     * Limit how many saved_jobs to delete.
     */
    limit?: number
  }

  /**
   * saved_jobs without action
   */
  export type saved_jobsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saved_jobs
     */
    select?: saved_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saved_jobs
     */
    omit?: saved_jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saved_jobsInclude<ExtArgs> | null
  }


  /**
   * Model job_searches
   */

  export type AggregateJob_searches = {
    _count: Job_searchesCountAggregateOutputType | null
    _avg: Job_searchesAvgAggregateOutputType | null
    _sum: Job_searchesSumAggregateOutputType | null
    _min: Job_searchesMinAggregateOutputType | null
    _max: Job_searchesMaxAggregateOutputType | null
  }

  export type Job_searchesAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Job_searchesSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Job_searchesMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    search_query: string | null
    country: string | null
    city: string | null
    job_catregory: string | null
    experience_level: string | null
    job_type: string | null
    created_at: Date | null
  }

  export type Job_searchesMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    search_query: string | null
    country: string | null
    city: string | null
    job_catregory: string | null
    experience_level: string | null
    job_type: string | null
    created_at: Date | null
  }

  export type Job_searchesCountAggregateOutputType = {
    id: number
    user_id: number
    search_query: number
    country: number
    city: number
    job_catregory: number
    experience_level: number
    job_type: number
    created_at: number
    _all: number
  }


  export type Job_searchesAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Job_searchesSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Job_searchesMinAggregateInputType = {
    id?: true
    user_id?: true
    search_query?: true
    country?: true
    city?: true
    job_catregory?: true
    experience_level?: true
    job_type?: true
    created_at?: true
  }

  export type Job_searchesMaxAggregateInputType = {
    id?: true
    user_id?: true
    search_query?: true
    country?: true
    city?: true
    job_catregory?: true
    experience_level?: true
    job_type?: true
    created_at?: true
  }

  export type Job_searchesCountAggregateInputType = {
    id?: true
    user_id?: true
    search_query?: true
    country?: true
    city?: true
    job_catregory?: true
    experience_level?: true
    job_type?: true
    created_at?: true
    _all?: true
  }

  export type Job_searchesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job_searches to aggregate.
     */
    where?: job_searchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_searches to fetch.
     */
    orderBy?: job_searchesOrderByWithRelationInput | job_searchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: job_searchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_searches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_searches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned job_searches
    **/
    _count?: true | Job_searchesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Job_searchesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Job_searchesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Job_searchesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Job_searchesMaxAggregateInputType
  }

  export type GetJob_searchesAggregateType<T extends Job_searchesAggregateArgs> = {
        [P in keyof T & keyof AggregateJob_searches]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJob_searches[P]>
      : GetScalarType<T[P], AggregateJob_searches[P]>
  }




  export type job_searchesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: job_searchesWhereInput
    orderBy?: job_searchesOrderByWithAggregationInput | job_searchesOrderByWithAggregationInput[]
    by: Job_searchesScalarFieldEnum[] | Job_searchesScalarFieldEnum
    having?: job_searchesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Job_searchesCountAggregateInputType | true
    _avg?: Job_searchesAvgAggregateInputType
    _sum?: Job_searchesSumAggregateInputType
    _min?: Job_searchesMinAggregateInputType
    _max?: Job_searchesMaxAggregateInputType
  }

  export type Job_searchesGroupByOutputType = {
    id: number
    user_id: number
    search_query: string
    country: string
    city: string
    job_catregory: string
    experience_level: string
    job_type: string
    created_at: Date
    _count: Job_searchesCountAggregateOutputType | null
    _avg: Job_searchesAvgAggregateOutputType | null
    _sum: Job_searchesSumAggregateOutputType | null
    _min: Job_searchesMinAggregateOutputType | null
    _max: Job_searchesMaxAggregateOutputType | null
  }

  type GetJob_searchesGroupByPayload<T extends job_searchesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Job_searchesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Job_searchesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Job_searchesGroupByOutputType[P]>
            : GetScalarType<T[P], Job_searchesGroupByOutputType[P]>
        }
      >
    >


  export type job_searchesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    search_query?: boolean
    country?: boolean
    city?: boolean
    job_catregory?: boolean
    experience_level?: boolean
    job_type?: boolean
    created_at?: boolean
    searches?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job_searches"]>

  export type job_searchesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    search_query?: boolean
    country?: boolean
    city?: boolean
    job_catregory?: boolean
    experience_level?: boolean
    job_type?: boolean
    created_at?: boolean
    searches?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job_searches"]>

  export type job_searchesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    search_query?: boolean
    country?: boolean
    city?: boolean
    job_catregory?: boolean
    experience_level?: boolean
    job_type?: boolean
    created_at?: boolean
    searches?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job_searches"]>

  export type job_searchesSelectScalar = {
    id?: boolean
    user_id?: boolean
    search_query?: boolean
    country?: boolean
    city?: boolean
    job_catregory?: boolean
    experience_level?: boolean
    job_type?: boolean
    created_at?: boolean
  }

  export type job_searchesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "search_query" | "country" | "city" | "job_catregory" | "experience_level" | "job_type" | "created_at", ExtArgs["result"]["job_searches"]>
  export type job_searchesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    searches?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type job_searchesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    searches?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type job_searchesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    searches?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $job_searchesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "job_searches"
    objects: {
      searches: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      search_query: string
      country: string
      city: string
      job_catregory: string
      experience_level: string
      job_type: string
      created_at: Date
    }, ExtArgs["result"]["job_searches"]>
    composites: {}
  }

  type job_searchesGetPayload<S extends boolean | null | undefined | job_searchesDefaultArgs> = $Result.GetResult<Prisma.$job_searchesPayload, S>

  type job_searchesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<job_searchesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Job_searchesCountAggregateInputType | true
    }

  export interface job_searchesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['job_searches'], meta: { name: 'job_searches' } }
    /**
     * Find zero or one Job_searches that matches the filter.
     * @param {job_searchesFindUniqueArgs} args - Arguments to find a Job_searches
     * @example
     * // Get one Job_searches
     * const job_searches = await prisma.job_searches.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends job_searchesFindUniqueArgs>(args: SelectSubset<T, job_searchesFindUniqueArgs<ExtArgs>>): Prisma__job_searchesClient<$Result.GetResult<Prisma.$job_searchesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Job_searches that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {job_searchesFindUniqueOrThrowArgs} args - Arguments to find a Job_searches
     * @example
     * // Get one Job_searches
     * const job_searches = await prisma.job_searches.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends job_searchesFindUniqueOrThrowArgs>(args: SelectSubset<T, job_searchesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__job_searchesClient<$Result.GetResult<Prisma.$job_searchesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job_searches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_searchesFindFirstArgs} args - Arguments to find a Job_searches
     * @example
     * // Get one Job_searches
     * const job_searches = await prisma.job_searches.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends job_searchesFindFirstArgs>(args?: SelectSubset<T, job_searchesFindFirstArgs<ExtArgs>>): Prisma__job_searchesClient<$Result.GetResult<Prisma.$job_searchesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job_searches that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_searchesFindFirstOrThrowArgs} args - Arguments to find a Job_searches
     * @example
     * // Get one Job_searches
     * const job_searches = await prisma.job_searches.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends job_searchesFindFirstOrThrowArgs>(args?: SelectSubset<T, job_searchesFindFirstOrThrowArgs<ExtArgs>>): Prisma__job_searchesClient<$Result.GetResult<Prisma.$job_searchesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Job_searches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_searchesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Job_searches
     * const job_searches = await prisma.job_searches.findMany()
     * 
     * // Get first 10 Job_searches
     * const job_searches = await prisma.job_searches.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const job_searchesWithIdOnly = await prisma.job_searches.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends job_searchesFindManyArgs>(args?: SelectSubset<T, job_searchesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_searchesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Job_searches.
     * @param {job_searchesCreateArgs} args - Arguments to create a Job_searches.
     * @example
     * // Create one Job_searches
     * const Job_searches = await prisma.job_searches.create({
     *   data: {
     *     // ... data to create a Job_searches
     *   }
     * })
     * 
     */
    create<T extends job_searchesCreateArgs>(args: SelectSubset<T, job_searchesCreateArgs<ExtArgs>>): Prisma__job_searchesClient<$Result.GetResult<Prisma.$job_searchesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Job_searches.
     * @param {job_searchesCreateManyArgs} args - Arguments to create many Job_searches.
     * @example
     * // Create many Job_searches
     * const job_searches = await prisma.job_searches.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends job_searchesCreateManyArgs>(args?: SelectSubset<T, job_searchesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Job_searches and returns the data saved in the database.
     * @param {job_searchesCreateManyAndReturnArgs} args - Arguments to create many Job_searches.
     * @example
     * // Create many Job_searches
     * const job_searches = await prisma.job_searches.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Job_searches and only return the `id`
     * const job_searchesWithIdOnly = await prisma.job_searches.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends job_searchesCreateManyAndReturnArgs>(args?: SelectSubset<T, job_searchesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_searchesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Job_searches.
     * @param {job_searchesDeleteArgs} args - Arguments to delete one Job_searches.
     * @example
     * // Delete one Job_searches
     * const Job_searches = await prisma.job_searches.delete({
     *   where: {
     *     // ... filter to delete one Job_searches
     *   }
     * })
     * 
     */
    delete<T extends job_searchesDeleteArgs>(args: SelectSubset<T, job_searchesDeleteArgs<ExtArgs>>): Prisma__job_searchesClient<$Result.GetResult<Prisma.$job_searchesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Job_searches.
     * @param {job_searchesUpdateArgs} args - Arguments to update one Job_searches.
     * @example
     * // Update one Job_searches
     * const job_searches = await prisma.job_searches.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends job_searchesUpdateArgs>(args: SelectSubset<T, job_searchesUpdateArgs<ExtArgs>>): Prisma__job_searchesClient<$Result.GetResult<Prisma.$job_searchesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Job_searches.
     * @param {job_searchesDeleteManyArgs} args - Arguments to filter Job_searches to delete.
     * @example
     * // Delete a few Job_searches
     * const { count } = await prisma.job_searches.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends job_searchesDeleteManyArgs>(args?: SelectSubset<T, job_searchesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Job_searches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_searchesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Job_searches
     * const job_searches = await prisma.job_searches.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends job_searchesUpdateManyArgs>(args: SelectSubset<T, job_searchesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Job_searches and returns the data updated in the database.
     * @param {job_searchesUpdateManyAndReturnArgs} args - Arguments to update many Job_searches.
     * @example
     * // Update many Job_searches
     * const job_searches = await prisma.job_searches.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Job_searches and only return the `id`
     * const job_searchesWithIdOnly = await prisma.job_searches.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends job_searchesUpdateManyAndReturnArgs>(args: SelectSubset<T, job_searchesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_searchesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Job_searches.
     * @param {job_searchesUpsertArgs} args - Arguments to update or create a Job_searches.
     * @example
     * // Update or create a Job_searches
     * const job_searches = await prisma.job_searches.upsert({
     *   create: {
     *     // ... data to create a Job_searches
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Job_searches we want to update
     *   }
     * })
     */
    upsert<T extends job_searchesUpsertArgs>(args: SelectSubset<T, job_searchesUpsertArgs<ExtArgs>>): Prisma__job_searchesClient<$Result.GetResult<Prisma.$job_searchesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Job_searches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_searchesCountArgs} args - Arguments to filter Job_searches to count.
     * @example
     * // Count the number of Job_searches
     * const count = await prisma.job_searches.count({
     *   where: {
     *     // ... the filter for the Job_searches we want to count
     *   }
     * })
    **/
    count<T extends job_searchesCountArgs>(
      args?: Subset<T, job_searchesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Job_searchesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Job_searches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Job_searchesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Job_searchesAggregateArgs>(args: Subset<T, Job_searchesAggregateArgs>): Prisma.PrismaPromise<GetJob_searchesAggregateType<T>>

    /**
     * Group by Job_searches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_searchesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends job_searchesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: job_searchesGroupByArgs['orderBy'] }
        : { orderBy?: job_searchesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, job_searchesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJob_searchesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the job_searches model
   */
  readonly fields: job_searchesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for job_searches.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__job_searchesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    searches<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the job_searches model
   */
  interface job_searchesFieldRefs {
    readonly id: FieldRef<"job_searches", 'Int'>
    readonly user_id: FieldRef<"job_searches", 'Int'>
    readonly search_query: FieldRef<"job_searches", 'String'>
    readonly country: FieldRef<"job_searches", 'String'>
    readonly city: FieldRef<"job_searches", 'String'>
    readonly job_catregory: FieldRef<"job_searches", 'String'>
    readonly experience_level: FieldRef<"job_searches", 'String'>
    readonly job_type: FieldRef<"job_searches", 'String'>
    readonly created_at: FieldRef<"job_searches", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * job_searches findUnique
   */
  export type job_searchesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_searches
     */
    select?: job_searchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_searches
     */
    omit?: job_searchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_searchesInclude<ExtArgs> | null
    /**
     * Filter, which job_searches to fetch.
     */
    where: job_searchesWhereUniqueInput
  }

  /**
   * job_searches findUniqueOrThrow
   */
  export type job_searchesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_searches
     */
    select?: job_searchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_searches
     */
    omit?: job_searchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_searchesInclude<ExtArgs> | null
    /**
     * Filter, which job_searches to fetch.
     */
    where: job_searchesWhereUniqueInput
  }

  /**
   * job_searches findFirst
   */
  export type job_searchesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_searches
     */
    select?: job_searchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_searches
     */
    omit?: job_searchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_searchesInclude<ExtArgs> | null
    /**
     * Filter, which job_searches to fetch.
     */
    where?: job_searchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_searches to fetch.
     */
    orderBy?: job_searchesOrderByWithRelationInput | job_searchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for job_searches.
     */
    cursor?: job_searchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_searches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_searches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of job_searches.
     */
    distinct?: Job_searchesScalarFieldEnum | Job_searchesScalarFieldEnum[]
  }

  /**
   * job_searches findFirstOrThrow
   */
  export type job_searchesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_searches
     */
    select?: job_searchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_searches
     */
    omit?: job_searchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_searchesInclude<ExtArgs> | null
    /**
     * Filter, which job_searches to fetch.
     */
    where?: job_searchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_searches to fetch.
     */
    orderBy?: job_searchesOrderByWithRelationInput | job_searchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for job_searches.
     */
    cursor?: job_searchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_searches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_searches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of job_searches.
     */
    distinct?: Job_searchesScalarFieldEnum | Job_searchesScalarFieldEnum[]
  }

  /**
   * job_searches findMany
   */
  export type job_searchesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_searches
     */
    select?: job_searchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_searches
     */
    omit?: job_searchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_searchesInclude<ExtArgs> | null
    /**
     * Filter, which job_searches to fetch.
     */
    where?: job_searchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_searches to fetch.
     */
    orderBy?: job_searchesOrderByWithRelationInput | job_searchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing job_searches.
     */
    cursor?: job_searchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_searches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_searches.
     */
    skip?: number
    distinct?: Job_searchesScalarFieldEnum | Job_searchesScalarFieldEnum[]
  }

  /**
   * job_searches create
   */
  export type job_searchesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_searches
     */
    select?: job_searchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_searches
     */
    omit?: job_searchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_searchesInclude<ExtArgs> | null
    /**
     * The data needed to create a job_searches.
     */
    data: XOR<job_searchesCreateInput, job_searchesUncheckedCreateInput>
  }

  /**
   * job_searches createMany
   */
  export type job_searchesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many job_searches.
     */
    data: job_searchesCreateManyInput | job_searchesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * job_searches createManyAndReturn
   */
  export type job_searchesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_searches
     */
    select?: job_searchesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the job_searches
     */
    omit?: job_searchesOmit<ExtArgs> | null
    /**
     * The data used to create many job_searches.
     */
    data: job_searchesCreateManyInput | job_searchesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_searchesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * job_searches update
   */
  export type job_searchesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_searches
     */
    select?: job_searchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_searches
     */
    omit?: job_searchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_searchesInclude<ExtArgs> | null
    /**
     * The data needed to update a job_searches.
     */
    data: XOR<job_searchesUpdateInput, job_searchesUncheckedUpdateInput>
    /**
     * Choose, which job_searches to update.
     */
    where: job_searchesWhereUniqueInput
  }

  /**
   * job_searches updateMany
   */
  export type job_searchesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update job_searches.
     */
    data: XOR<job_searchesUpdateManyMutationInput, job_searchesUncheckedUpdateManyInput>
    /**
     * Filter which job_searches to update
     */
    where?: job_searchesWhereInput
    /**
     * Limit how many job_searches to update.
     */
    limit?: number
  }

  /**
   * job_searches updateManyAndReturn
   */
  export type job_searchesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_searches
     */
    select?: job_searchesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the job_searches
     */
    omit?: job_searchesOmit<ExtArgs> | null
    /**
     * The data used to update job_searches.
     */
    data: XOR<job_searchesUpdateManyMutationInput, job_searchesUncheckedUpdateManyInput>
    /**
     * Filter which job_searches to update
     */
    where?: job_searchesWhereInput
    /**
     * Limit how many job_searches to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_searchesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * job_searches upsert
   */
  export type job_searchesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_searches
     */
    select?: job_searchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_searches
     */
    omit?: job_searchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_searchesInclude<ExtArgs> | null
    /**
     * The filter to search for the job_searches to update in case it exists.
     */
    where: job_searchesWhereUniqueInput
    /**
     * In case the job_searches found by the `where` argument doesn't exist, create a new job_searches with this data.
     */
    create: XOR<job_searchesCreateInput, job_searchesUncheckedCreateInput>
    /**
     * In case the job_searches was found with the provided `where` argument, update it with this data.
     */
    update: XOR<job_searchesUpdateInput, job_searchesUncheckedUpdateInput>
  }

  /**
   * job_searches delete
   */
  export type job_searchesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_searches
     */
    select?: job_searchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_searches
     */
    omit?: job_searchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_searchesInclude<ExtArgs> | null
    /**
     * Filter which job_searches to delete.
     */
    where: job_searchesWhereUniqueInput
  }

  /**
   * job_searches deleteMany
   */
  export type job_searchesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job_searches to delete
     */
    where?: job_searchesWhereInput
    /**
     * Limit how many job_searches to delete.
     */
    limit?: number
  }

  /**
   * job_searches without action
   */
  export type job_searchesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_searches
     */
    select?: job_searchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_searches
     */
    omit?: job_searchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_searchesInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsersScalarFieldEnum: {
    id: 'id',
    first_name: 'first_name',
    last_name: 'last_name',
    email: 'email',
    password_hash: 'password_hash',
    phone_number: 'phone_number',
    country_code: 'country_code',
    date_of_birth: 'date_of_birth',
    gender: 'gender',
    profile_picture_url: 'profile_picture_url',
    bio: 'bio',
    created_at: 'created_at',
    updated_at: 'updated_at',
    last_login_at: 'last_login_at',
    status: 'status'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const User_addressesScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    adress_line1: 'adress_line1',
    adress_line2: 'adress_line2',
    city: 'city',
    state: 'state',
    postal_code: 'postal_code',
    country: 'country',
    is_primary: 'is_primary',
    created_at: 'created_at'
  };

  export type User_addressesScalarFieldEnum = (typeof User_addressesScalarFieldEnum)[keyof typeof User_addressesScalarFieldEnum]


  export const ResumesScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    title: 'title',
    file_url: 'file_url',
    is_default: 'is_default',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ResumesScalarFieldEnum = (typeof ResumesScalarFieldEnum)[keyof typeof ResumesScalarFieldEnum]


  export const EducationsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    institution: 'institution',
    degree: 'degree',
    field_of_study: 'field_of_study',
    start_date: 'start_date',
    end_date: 'end_date',
    grade: 'grade',
    description: 'description',
    is_foreign_education: 'is_foreign_education',
    country: 'country'
  };

  export type EducationsScalarFieldEnum = (typeof EducationsScalarFieldEnum)[keyof typeof EducationsScalarFieldEnum]


  export const Work_experiencesScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    company_name: 'company_name',
    position: 'position',
    location: 'location',
    country: 'country',
    start_date: 'start_date',
    end_date: 'end_date',
    is_current_job: 'is_current_job',
    description: 'description',
    is_foregin_experience: 'is_foregin_experience'
  };

  export type Work_experiencesScalarFieldEnum = (typeof Work_experiencesScalarFieldEnum)[keyof typeof Work_experiencesScalarFieldEnum]


  export const SkillsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    skill_name: 'skill_name',
    proficiency: 'proficiency',
    year_of_experience: 'year_of_experience',
    is_certifield: 'is_certifield'
  };

  export type SkillsScalarFieldEnum = (typeof SkillsScalarFieldEnum)[keyof typeof SkillsScalarFieldEnum]


  export const LanguagesScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    languages: 'languages',
    proficiency: 'proficiency',
    is_primary: 'is_primary'
  };

  export type LanguagesScalarFieldEnum = (typeof LanguagesScalarFieldEnum)[keyof typeof LanguagesScalarFieldEnum]


  export const CertificationsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    name: 'name',
    issuing_organization: 'issuing_organization',
    issue_date: 'issue_date',
    expiration_date: 'expiration_date',
    credential_id: 'credential_id',
    credential_url: 'credential_url',
    is_foreign_certification: 'is_foreign_certification'
  };

  export type CertificationsScalarFieldEnum = (typeof CertificationsScalarFieldEnum)[keyof typeof CertificationsScalarFieldEnum]


  export const Visa_informationScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    visa_type: 'visa_type',
    country: 'country',
    status: 'status',
    expiry__date: 'expiry__date',
    is_multiple_entry: 'is_multiple_entry',
    notes: 'notes'
  };

  export type Visa_informationScalarFieldEnum = (typeof Visa_informationScalarFieldEnum)[keyof typeof Visa_informationScalarFieldEnum]


  export const CompaniesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    industry: 'industry',
    founded_year: 'founded_year',
    website_url: 'website_url',
    logo_url: 'logo_url',
    headquarters_country: 'headquarters_country',
    company_siz: 'company_siz',
    is_verified: 'is_verified',
    created_at: 'created_at'
  };

  export type CompaniesScalarFieldEnum = (typeof CompaniesScalarFieldEnum)[keyof typeof CompaniesScalarFieldEnum]


  export const Company_locationsScalarFieldEnum: {
    id: 'id',
    company_id: 'company_id',
    country: 'country',
    city: 'city',
    address: 'address',
    is_headquarters: 'is_headquarters',
    phone_number: 'phone_number'
  };

  export type Company_locationsScalarFieldEnum = (typeof Company_locationsScalarFieldEnum)[keyof typeof Company_locationsScalarFieldEnum]


  export const JobsScalarFieldEnum: {
    id: 'id',
    company_id: 'company_id',
    title: 'title',
    description: 'description',
    job_category: 'job_category',
    job_type: 'job_type',
    location_country: 'location_country',
    location_city: 'location_city',
    is_relocation_assistance: 'is_relocation_assistance',
    is_remote_possible: 'is_remote_possible',
    salary_currency: 'salary_currency',
    salary_min: 'salary_min',
    salary_max: 'salary_max',
    salary_period: 'salary_period',
    visa_sponsorship: 'visa_sponsorship',
    experience_level: 'experience_level',
    education_requirement: 'education_requirement',
    posted_by: 'posted_by',
    status: 'status',
    posted_at: 'posted_at',
    deadline: 'deadline',
    views_count: 'views_count'
  };

  export type JobsScalarFieldEnum = (typeof JobsScalarFieldEnum)[keyof typeof JobsScalarFieldEnum]


  export const Job_requirementsScalarFieldEnum: {
    id: 'id',
    job_id: 'job_id',
    requirement_type: 'requirement_type',
    requirement_text: 'requirement_text',
    is_mandatory: 'is_mandatory',
    priority: 'priority'
  };

  export type Job_requirementsScalarFieldEnum = (typeof Job_requirementsScalarFieldEnum)[keyof typeof Job_requirementsScalarFieldEnum]


  export const Job_responsibilitesScalarFieldEnum: {
    id: 'id',
    job_id: 'job_id',
    responsibility_text: 'responsibility_text',
    priority: 'priority'
  };

  export type Job_responsibilitesScalarFieldEnum = (typeof Job_responsibilitesScalarFieldEnum)[keyof typeof Job_responsibilitesScalarFieldEnum]


  export const Job_benefitsScalarFieldEnum: {
    id: 'id',
    job_id: 'job_id',
    benefit_type: 'benefit_type',
    description: 'description'
  };

  export type Job_benefitsScalarFieldEnum = (typeof Job_benefitsScalarFieldEnum)[keyof typeof Job_benefitsScalarFieldEnum]


  export const ApplicationsScalarFieldEnum: {
    id: 'id',
    job_id: 'job_id',
    user_id: 'user_id',
    resume_id: 'resume_id',
    cover_letter: 'cover_letter',
    status: 'status',
    applited_at: 'applited_at',
    updated_at: 'updated_at',
    notes: 'notes'
  };

  export type ApplicationsScalarFieldEnum = (typeof ApplicationsScalarFieldEnum)[keyof typeof ApplicationsScalarFieldEnum]


  export const Application_documentsScalarFieldEnum: {
    id: 'id',
    application_id: 'application_id',
    document_type: 'document_type',
    file_url: 'file_url',
    uploaded_at: 'uploaded_at'
  };

  export type Application_documentsScalarFieldEnum = (typeof Application_documentsScalarFieldEnum)[keyof typeof Application_documentsScalarFieldEnum]


  export const InterviewsScalarFieldEnum: {
    id: 'id',
    application_id: 'application_id',
    interview_type: 'interview_type',
    scheduled_time: 'scheduled_time',
    timezone: 'timezone',
    duration_minutes: 'duration_minutes',
    location: 'location',
    meeting_url: 'meeting_url',
    interview_name: 'interview_name',
    interview_position: 'interview_position',
    status: 'status',
    feedback: 'feedback',
    rating: 'rating',
    notes: 'notes',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type InterviewsScalarFieldEnum = (typeof InterviewsScalarFieldEnum)[keyof typeof InterviewsScalarFieldEnum]


  export const ContactsScalarFieldEnum: {
    id: 'id',
    job_id: 'job_id',
    user_id: 'user_id',
    company_id: 'company_id',
    contact_type: 'contact_type',
    start_date: 'start_date',
    end_date: 'end_date',
    probation_period_months: 'probation_period_months',
    salary_amount: 'salary_amount',
    salary_currency: 'salary_currency',
    salary_payment_period: 'salary_payment_period',
    benefits_description: 'benefits_description',
    visa_sponsorship_details: 'visa_sponsorship_details',
    relocation_assistance_details: 'relocation_assistance_details',
    status: 'status',
    signed_at: 'signed_at',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ContactsScalarFieldEnum = (typeof ContactsScalarFieldEnum)[keyof typeof ContactsScalarFieldEnum]


  export const NotificationsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    notification_type: 'notification_type',
    title: 'title',
    message: 'message',
    is_read: 'is_read',
    related_entity_type: 'related_entity_type',
    related_entity_id: 'related_entity_id',
    created_at: 'created_at'
  };

  export type NotificationsScalarFieldEnum = (typeof NotificationsScalarFieldEnum)[keyof typeof NotificationsScalarFieldEnum]


  export const Saved_jobsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    job_id: 'job_id',
    saved_at: 'saved_at',
    notes: 'notes'
  };

  export type Saved_jobsScalarFieldEnum = (typeof Saved_jobsScalarFieldEnum)[keyof typeof Saved_jobsScalarFieldEnum]


  export const Job_searchesScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    search_query: 'search_query',
    country: 'country',
    city: 'city',
    job_catregory: 'job_catregory',
    experience_level: 'experience_level',
    job_type: 'job_type',
    created_at: 'created_at'
  };

  export type Job_searchesScalarFieldEnum = (typeof Job_searchesScalarFieldEnum)[keyof typeof Job_searchesScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'userstatus'
   */
  export type EnumuserstatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'userstatus'>
    


  /**
   * Reference to a field of type 'userstatus[]'
   */
  export type ListEnumuserstatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'userstatus[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'skillsstatus'
   */
  export type EnumskillsstatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'skillsstatus'>
    


  /**
   * Reference to a field of type 'skillsstatus[]'
   */
  export type ListEnumskillsstatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'skillsstatus[]'>
    


  /**
   * Reference to a field of type 'proficiencylanguages'
   */
  export type EnumproficiencylanguagesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'proficiencylanguages'>
    


  /**
   * Reference to a field of type 'proficiencylanguages[]'
   */
  export type ListEnumproficiencylanguagesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'proficiencylanguages[]'>
    


  /**
   * Reference to a field of type 'companySize'
   */
  export type EnumcompanySizeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'companySize'>
    


  /**
   * Reference to a field of type 'companySize[]'
   */
  export type ListEnumcompanySizeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'companySize[]'>
    


  /**
   * Reference to a field of type 'jobType'
   */
  export type EnumjobTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'jobType'>
    


  /**
   * Reference to a field of type 'jobType[]'
   */
  export type ListEnumjobTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'jobType[]'>
    


  /**
   * Reference to a field of type 'salaryPeriod'
   */
  export type EnumsalaryPeriodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'salaryPeriod'>
    


  /**
   * Reference to a field of type 'salaryPeriod[]'
   */
  export type ListEnumsalaryPeriodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'salaryPeriod[]'>
    


  /**
   * Reference to a field of type 'visaSponsorship'
   */
  export type EnumvisaSponsorshipFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'visaSponsorship'>
    


  /**
   * Reference to a field of type 'visaSponsorship[]'
   */
  export type ListEnumvisaSponsorshipFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'visaSponsorship[]'>
    


  /**
   * Reference to a field of type 'expLevel'
   */
  export type EnumexpLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'expLevel'>
    


  /**
   * Reference to a field of type 'expLevel[]'
   */
  export type ListEnumexpLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'expLevel[]'>
    


  /**
   * Reference to a field of type 'jobStatus'
   */
  export type EnumjobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'jobStatus'>
    


  /**
   * Reference to a field of type 'jobStatus[]'
   */
  export type ListEnumjobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'jobStatus[]'>
    


  /**
   * Reference to a field of type 'jobRequirements'
   */
  export type EnumjobRequirementsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'jobRequirements'>
    


  /**
   * Reference to a field of type 'jobRequirements[]'
   */
  export type ListEnumjobRequirementsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'jobRequirements[]'>
    


  /**
   * Reference to a field of type 'jobBenefit'
   */
  export type EnumjobBenefitFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'jobBenefit'>
    


  /**
   * Reference to a field of type 'jobBenefit[]'
   */
  export type ListEnumjobBenefitFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'jobBenefit[]'>
    


  /**
   * Reference to a field of type 'applicationStatus'
   */
  export type EnumapplicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'applicationStatus'>
    


  /**
   * Reference to a field of type 'applicationStatus[]'
   */
  export type ListEnumapplicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'applicationStatus[]'>
    


  /**
   * Reference to a field of type 'appDocumentStatus'
   */
  export type EnumappDocumentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'appDocumentStatus'>
    


  /**
   * Reference to a field of type 'appDocumentStatus[]'
   */
  export type ListEnumappDocumentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'appDocumentStatus[]'>
    


  /**
   * Reference to a field of type 'interviewType'
   */
  export type EnuminterviewTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'interviewType'>
    


  /**
   * Reference to a field of type 'interviewType[]'
   */
  export type ListEnuminterviewTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'interviewType[]'>
    


  /**
   * Reference to a field of type 'interviewStatus'
   */
  export type EnuminterviewStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'interviewStatus'>
    


  /**
   * Reference to a field of type 'interviewStatus[]'
   */
  export type ListEnuminterviewStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'interviewStatus[]'>
    


  /**
   * Reference to a field of type 'contactType'
   */
  export type EnumcontactTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'contactType'>
    


  /**
   * Reference to a field of type 'contactType[]'
   */
  export type ListEnumcontactTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'contactType[]'>
    


  /**
   * Reference to a field of type 'contactSalaryPaymentPeriod'
   */
  export type EnumcontactSalaryPaymentPeriodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'contactSalaryPaymentPeriod'>
    


  /**
   * Reference to a field of type 'contactSalaryPaymentPeriod[]'
   */
  export type ListEnumcontactSalaryPaymentPeriodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'contactSalaryPaymentPeriod[]'>
    


  /**
   * Reference to a field of type 'contactStatus'
   */
  export type EnumcontactStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'contactStatus'>
    


  /**
   * Reference to a field of type 'contactStatus[]'
   */
  export type ListEnumcontactStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'contactStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: IntFilter<"users"> | number
    first_name?: StringFilter<"users"> | string
    last_name?: StringFilter<"users"> | string
    email?: StringFilter<"users"> | string
    password_hash?: StringFilter<"users"> | string
    phone_number?: StringNullableFilter<"users"> | string | null
    country_code?: StringNullableFilter<"users"> | string | null
    date_of_birth?: DateTimeNullableFilter<"users"> | Date | string | null
    gender?: StringNullableFilter<"users"> | string | null
    profile_picture_url?: StringNullableFilter<"users"> | string | null
    bio?: StringNullableFilter<"users"> | string | null
    created_at?: DateTimeFilter<"users"> | Date | string
    updated_at?: DateTimeFilter<"users"> | Date | string
    last_login_at?: DateTimeNullableFilter<"users"> | Date | string | null
    status?: EnumuserstatusFilter<"users"> | $Enums.userstatus
    addresses?: User_addressesListRelationFilter
    resumes?: ResumesListRelationFilter
    educations?: EducationsListRelationFilter
    experiences?: Work_experiencesListRelationFilter
    skills?: SkillsListRelationFilter
    languages?: LanguagesListRelationFilter
    certifications?: CertificationsListRelationFilter
    visa?: Visa_informationListRelationFilter
    application?: ApplicationsListRelationFilter
    contacts?: ContactsListRelationFilter
    notification?: NotificationsListRelationFilter
    savedjob?: Saved_jobsListRelationFilter
    searches?: Job_searchesListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    phone_number?: SortOrderInput | SortOrder
    country_code?: SortOrderInput | SortOrder
    date_of_birth?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    profile_picture_url?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    last_login_at?: SortOrderInput | SortOrder
    status?: SortOrder
    addresses?: user_addressesOrderByRelationAggregateInput
    resumes?: resumesOrderByRelationAggregateInput
    educations?: educationsOrderByRelationAggregateInput
    experiences?: work_experiencesOrderByRelationAggregateInput
    skills?: skillsOrderByRelationAggregateInput
    languages?: languagesOrderByRelationAggregateInput
    certifications?: certificationsOrderByRelationAggregateInput
    visa?: visa_informationOrderByRelationAggregateInput
    application?: applicationsOrderByRelationAggregateInput
    contacts?: contactsOrderByRelationAggregateInput
    notification?: notificationsOrderByRelationAggregateInput
    savedjob?: saved_jobsOrderByRelationAggregateInput
    searches?: job_searchesOrderByRelationAggregateInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    first_name?: StringFilter<"users"> | string
    last_name?: StringFilter<"users"> | string
    email?: StringFilter<"users"> | string
    password_hash?: StringFilter<"users"> | string
    phone_number?: StringNullableFilter<"users"> | string | null
    country_code?: StringNullableFilter<"users"> | string | null
    date_of_birth?: DateTimeNullableFilter<"users"> | Date | string | null
    gender?: StringNullableFilter<"users"> | string | null
    profile_picture_url?: StringNullableFilter<"users"> | string | null
    bio?: StringNullableFilter<"users"> | string | null
    created_at?: DateTimeFilter<"users"> | Date | string
    updated_at?: DateTimeFilter<"users"> | Date | string
    last_login_at?: DateTimeNullableFilter<"users"> | Date | string | null
    status?: EnumuserstatusFilter<"users"> | $Enums.userstatus
    addresses?: User_addressesListRelationFilter
    resumes?: ResumesListRelationFilter
    educations?: EducationsListRelationFilter
    experiences?: Work_experiencesListRelationFilter
    skills?: SkillsListRelationFilter
    languages?: LanguagesListRelationFilter
    certifications?: CertificationsListRelationFilter
    visa?: Visa_informationListRelationFilter
    application?: ApplicationsListRelationFilter
    contacts?: ContactsListRelationFilter
    notification?: NotificationsListRelationFilter
    savedjob?: Saved_jobsListRelationFilter
    searches?: Job_searchesListRelationFilter
  }, "id">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    phone_number?: SortOrderInput | SortOrder
    country_code?: SortOrderInput | SortOrder
    date_of_birth?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    profile_picture_url?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    last_login_at?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"users"> | number
    first_name?: StringWithAggregatesFilter<"users"> | string
    last_name?: StringWithAggregatesFilter<"users"> | string
    email?: StringWithAggregatesFilter<"users"> | string
    password_hash?: StringWithAggregatesFilter<"users"> | string
    phone_number?: StringNullableWithAggregatesFilter<"users"> | string | null
    country_code?: StringNullableWithAggregatesFilter<"users"> | string | null
    date_of_birth?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    gender?: StringNullableWithAggregatesFilter<"users"> | string | null
    profile_picture_url?: StringNullableWithAggregatesFilter<"users"> | string | null
    bio?: StringNullableWithAggregatesFilter<"users"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"users"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"users"> | Date | string
    last_login_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    status?: EnumuserstatusWithAggregatesFilter<"users"> | $Enums.userstatus
  }

  export type user_addressesWhereInput = {
    AND?: user_addressesWhereInput | user_addressesWhereInput[]
    OR?: user_addressesWhereInput[]
    NOT?: user_addressesWhereInput | user_addressesWhereInput[]
    id?: IntFilter<"user_addresses"> | number
    user_id?: IntFilter<"user_addresses"> | number
    adress_line1?: StringFilter<"user_addresses"> | string
    adress_line2?: StringNullableFilter<"user_addresses"> | string | null
    city?: StringFilter<"user_addresses"> | string
    state?: StringNullableFilter<"user_addresses"> | string | null
    postal_code?: StringNullableFilter<"user_addresses"> | string | null
    country?: StringFilter<"user_addresses"> | string
    is_primary?: BoolNullableFilter<"user_addresses"> | boolean | null
    created_at?: DateTimeNullableFilter<"user_addresses"> | Date | string | null
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type user_addressesOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    adress_line1?: SortOrder
    adress_line2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrderInput | SortOrder
    postal_code?: SortOrderInput | SortOrder
    country?: SortOrder
    is_primary?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    user?: usersOrderByWithRelationInput
  }

  export type user_addressesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: user_addressesWhereInput | user_addressesWhereInput[]
    OR?: user_addressesWhereInput[]
    NOT?: user_addressesWhereInput | user_addressesWhereInput[]
    user_id?: IntFilter<"user_addresses"> | number
    adress_line1?: StringFilter<"user_addresses"> | string
    adress_line2?: StringNullableFilter<"user_addresses"> | string | null
    city?: StringFilter<"user_addresses"> | string
    state?: StringNullableFilter<"user_addresses"> | string | null
    postal_code?: StringNullableFilter<"user_addresses"> | string | null
    country?: StringFilter<"user_addresses"> | string
    is_primary?: BoolNullableFilter<"user_addresses"> | boolean | null
    created_at?: DateTimeNullableFilter<"user_addresses"> | Date | string | null
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type user_addressesOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    adress_line1?: SortOrder
    adress_line2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrderInput | SortOrder
    postal_code?: SortOrderInput | SortOrder
    country?: SortOrder
    is_primary?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: user_addressesCountOrderByAggregateInput
    _avg?: user_addressesAvgOrderByAggregateInput
    _max?: user_addressesMaxOrderByAggregateInput
    _min?: user_addressesMinOrderByAggregateInput
    _sum?: user_addressesSumOrderByAggregateInput
  }

  export type user_addressesScalarWhereWithAggregatesInput = {
    AND?: user_addressesScalarWhereWithAggregatesInput | user_addressesScalarWhereWithAggregatesInput[]
    OR?: user_addressesScalarWhereWithAggregatesInput[]
    NOT?: user_addressesScalarWhereWithAggregatesInput | user_addressesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"user_addresses"> | number
    user_id?: IntWithAggregatesFilter<"user_addresses"> | number
    adress_line1?: StringWithAggregatesFilter<"user_addresses"> | string
    adress_line2?: StringNullableWithAggregatesFilter<"user_addresses"> | string | null
    city?: StringWithAggregatesFilter<"user_addresses"> | string
    state?: StringNullableWithAggregatesFilter<"user_addresses"> | string | null
    postal_code?: StringNullableWithAggregatesFilter<"user_addresses"> | string | null
    country?: StringWithAggregatesFilter<"user_addresses"> | string
    is_primary?: BoolNullableWithAggregatesFilter<"user_addresses"> | boolean | null
    created_at?: DateTimeNullableWithAggregatesFilter<"user_addresses"> | Date | string | null
  }

  export type resumesWhereInput = {
    AND?: resumesWhereInput | resumesWhereInput[]
    OR?: resumesWhereInput[]
    NOT?: resumesWhereInput | resumesWhereInput[]
    id?: IntFilter<"resumes"> | number
    user_id?: IntFilter<"resumes"> | number
    title?: StringFilter<"resumes"> | string
    file_url?: StringFilter<"resumes"> | string
    is_default?: BoolFilter<"resumes"> | boolean
    created_at?: DateTimeFilter<"resumes"> | Date | string
    updated_at?: DateTimeFilter<"resumes"> | Date | string
    applications?: ApplicationsListRelationFilter
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type resumesOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    file_url?: SortOrder
    is_default?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    applications?: applicationsOrderByRelationAggregateInput
    user?: usersOrderByWithRelationInput
  }

  export type resumesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: resumesWhereInput | resumesWhereInput[]
    OR?: resumesWhereInput[]
    NOT?: resumesWhereInput | resumesWhereInput[]
    user_id?: IntFilter<"resumes"> | number
    title?: StringFilter<"resumes"> | string
    file_url?: StringFilter<"resumes"> | string
    is_default?: BoolFilter<"resumes"> | boolean
    created_at?: DateTimeFilter<"resumes"> | Date | string
    updated_at?: DateTimeFilter<"resumes"> | Date | string
    applications?: ApplicationsListRelationFilter
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type resumesOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    file_url?: SortOrder
    is_default?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: resumesCountOrderByAggregateInput
    _avg?: resumesAvgOrderByAggregateInput
    _max?: resumesMaxOrderByAggregateInput
    _min?: resumesMinOrderByAggregateInput
    _sum?: resumesSumOrderByAggregateInput
  }

  export type resumesScalarWhereWithAggregatesInput = {
    AND?: resumesScalarWhereWithAggregatesInput | resumesScalarWhereWithAggregatesInput[]
    OR?: resumesScalarWhereWithAggregatesInput[]
    NOT?: resumesScalarWhereWithAggregatesInput | resumesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"resumes"> | number
    user_id?: IntWithAggregatesFilter<"resumes"> | number
    title?: StringWithAggregatesFilter<"resumes"> | string
    file_url?: StringWithAggregatesFilter<"resumes"> | string
    is_default?: BoolWithAggregatesFilter<"resumes"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"resumes"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"resumes"> | Date | string
  }

  export type educationsWhereInput = {
    AND?: educationsWhereInput | educationsWhereInput[]
    OR?: educationsWhereInput[]
    NOT?: educationsWhereInput | educationsWhereInput[]
    id?: IntFilter<"educations"> | number
    user_id?: IntFilter<"educations"> | number
    institution?: StringFilter<"educations"> | string
    degree?: StringFilter<"educations"> | string
    field_of_study?: StringFilter<"educations"> | string
    start_date?: DateTimeFilter<"educations"> | Date | string
    end_date?: DateTimeFilter<"educations"> | Date | string
    grade?: StringFilter<"educations"> | string
    description?: StringFilter<"educations"> | string
    is_foreign_education?: BoolFilter<"educations"> | boolean
    country?: StringFilter<"educations"> | string
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type educationsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    institution?: SortOrder
    degree?: SortOrder
    field_of_study?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    grade?: SortOrder
    description?: SortOrder
    is_foreign_education?: SortOrder
    country?: SortOrder
    user?: usersOrderByWithRelationInput
  }

  export type educationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: educationsWhereInput | educationsWhereInput[]
    OR?: educationsWhereInput[]
    NOT?: educationsWhereInput | educationsWhereInput[]
    user_id?: IntFilter<"educations"> | number
    institution?: StringFilter<"educations"> | string
    degree?: StringFilter<"educations"> | string
    field_of_study?: StringFilter<"educations"> | string
    start_date?: DateTimeFilter<"educations"> | Date | string
    end_date?: DateTimeFilter<"educations"> | Date | string
    grade?: StringFilter<"educations"> | string
    description?: StringFilter<"educations"> | string
    is_foreign_education?: BoolFilter<"educations"> | boolean
    country?: StringFilter<"educations"> | string
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type educationsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    institution?: SortOrder
    degree?: SortOrder
    field_of_study?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    grade?: SortOrder
    description?: SortOrder
    is_foreign_education?: SortOrder
    country?: SortOrder
    _count?: educationsCountOrderByAggregateInput
    _avg?: educationsAvgOrderByAggregateInput
    _max?: educationsMaxOrderByAggregateInput
    _min?: educationsMinOrderByAggregateInput
    _sum?: educationsSumOrderByAggregateInput
  }

  export type educationsScalarWhereWithAggregatesInput = {
    AND?: educationsScalarWhereWithAggregatesInput | educationsScalarWhereWithAggregatesInput[]
    OR?: educationsScalarWhereWithAggregatesInput[]
    NOT?: educationsScalarWhereWithAggregatesInput | educationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"educations"> | number
    user_id?: IntWithAggregatesFilter<"educations"> | number
    institution?: StringWithAggregatesFilter<"educations"> | string
    degree?: StringWithAggregatesFilter<"educations"> | string
    field_of_study?: StringWithAggregatesFilter<"educations"> | string
    start_date?: DateTimeWithAggregatesFilter<"educations"> | Date | string
    end_date?: DateTimeWithAggregatesFilter<"educations"> | Date | string
    grade?: StringWithAggregatesFilter<"educations"> | string
    description?: StringWithAggregatesFilter<"educations"> | string
    is_foreign_education?: BoolWithAggregatesFilter<"educations"> | boolean
    country?: StringWithAggregatesFilter<"educations"> | string
  }

  export type work_experiencesWhereInput = {
    AND?: work_experiencesWhereInput | work_experiencesWhereInput[]
    OR?: work_experiencesWhereInput[]
    NOT?: work_experiencesWhereInput | work_experiencesWhereInput[]
    id?: IntFilter<"work_experiences"> | number
    user_id?: IntFilter<"work_experiences"> | number
    company_name?: StringFilter<"work_experiences"> | string
    position?: StringFilter<"work_experiences"> | string
    location?: StringFilter<"work_experiences"> | string
    country?: StringFilter<"work_experiences"> | string
    start_date?: DateTimeFilter<"work_experiences"> | Date | string
    end_date?: DateTimeFilter<"work_experiences"> | Date | string
    is_current_job?: BoolFilter<"work_experiences"> | boolean
    description?: StringFilter<"work_experiences"> | string
    is_foregin_experience?: BoolFilter<"work_experiences"> | boolean
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type work_experiencesOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    company_name?: SortOrder
    position?: SortOrder
    location?: SortOrder
    country?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    is_current_job?: SortOrder
    description?: SortOrder
    is_foregin_experience?: SortOrder
    user?: usersOrderByWithRelationInput
  }

  export type work_experiencesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: work_experiencesWhereInput | work_experiencesWhereInput[]
    OR?: work_experiencesWhereInput[]
    NOT?: work_experiencesWhereInput | work_experiencesWhereInput[]
    user_id?: IntFilter<"work_experiences"> | number
    company_name?: StringFilter<"work_experiences"> | string
    position?: StringFilter<"work_experiences"> | string
    location?: StringFilter<"work_experiences"> | string
    country?: StringFilter<"work_experiences"> | string
    start_date?: DateTimeFilter<"work_experiences"> | Date | string
    end_date?: DateTimeFilter<"work_experiences"> | Date | string
    is_current_job?: BoolFilter<"work_experiences"> | boolean
    description?: StringFilter<"work_experiences"> | string
    is_foregin_experience?: BoolFilter<"work_experiences"> | boolean
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type work_experiencesOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    company_name?: SortOrder
    position?: SortOrder
    location?: SortOrder
    country?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    is_current_job?: SortOrder
    description?: SortOrder
    is_foregin_experience?: SortOrder
    _count?: work_experiencesCountOrderByAggregateInput
    _avg?: work_experiencesAvgOrderByAggregateInput
    _max?: work_experiencesMaxOrderByAggregateInput
    _min?: work_experiencesMinOrderByAggregateInput
    _sum?: work_experiencesSumOrderByAggregateInput
  }

  export type work_experiencesScalarWhereWithAggregatesInput = {
    AND?: work_experiencesScalarWhereWithAggregatesInput | work_experiencesScalarWhereWithAggregatesInput[]
    OR?: work_experiencesScalarWhereWithAggregatesInput[]
    NOT?: work_experiencesScalarWhereWithAggregatesInput | work_experiencesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"work_experiences"> | number
    user_id?: IntWithAggregatesFilter<"work_experiences"> | number
    company_name?: StringWithAggregatesFilter<"work_experiences"> | string
    position?: StringWithAggregatesFilter<"work_experiences"> | string
    location?: StringWithAggregatesFilter<"work_experiences"> | string
    country?: StringWithAggregatesFilter<"work_experiences"> | string
    start_date?: DateTimeWithAggregatesFilter<"work_experiences"> | Date | string
    end_date?: DateTimeWithAggregatesFilter<"work_experiences"> | Date | string
    is_current_job?: BoolWithAggregatesFilter<"work_experiences"> | boolean
    description?: StringWithAggregatesFilter<"work_experiences"> | string
    is_foregin_experience?: BoolWithAggregatesFilter<"work_experiences"> | boolean
  }

  export type skillsWhereInput = {
    AND?: skillsWhereInput | skillsWhereInput[]
    OR?: skillsWhereInput[]
    NOT?: skillsWhereInput | skillsWhereInput[]
    id?: IntFilter<"skills"> | number
    user_id?: IntFilter<"skills"> | number
    skill_name?: StringFilter<"skills"> | string
    proficiency?: EnumskillsstatusFilter<"skills"> | $Enums.skillsstatus
    year_of_experience?: IntFilter<"skills"> | number
    is_certifield?: BoolFilter<"skills"> | boolean
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type skillsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    skill_name?: SortOrder
    proficiency?: SortOrder
    year_of_experience?: SortOrder
    is_certifield?: SortOrder
    user?: usersOrderByWithRelationInput
  }

  export type skillsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: skillsWhereInput | skillsWhereInput[]
    OR?: skillsWhereInput[]
    NOT?: skillsWhereInput | skillsWhereInput[]
    user_id?: IntFilter<"skills"> | number
    skill_name?: StringFilter<"skills"> | string
    proficiency?: EnumskillsstatusFilter<"skills"> | $Enums.skillsstatus
    year_of_experience?: IntFilter<"skills"> | number
    is_certifield?: BoolFilter<"skills"> | boolean
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type skillsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    skill_name?: SortOrder
    proficiency?: SortOrder
    year_of_experience?: SortOrder
    is_certifield?: SortOrder
    _count?: skillsCountOrderByAggregateInput
    _avg?: skillsAvgOrderByAggregateInput
    _max?: skillsMaxOrderByAggregateInput
    _min?: skillsMinOrderByAggregateInput
    _sum?: skillsSumOrderByAggregateInput
  }

  export type skillsScalarWhereWithAggregatesInput = {
    AND?: skillsScalarWhereWithAggregatesInput | skillsScalarWhereWithAggregatesInput[]
    OR?: skillsScalarWhereWithAggregatesInput[]
    NOT?: skillsScalarWhereWithAggregatesInput | skillsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"skills"> | number
    user_id?: IntWithAggregatesFilter<"skills"> | number
    skill_name?: StringWithAggregatesFilter<"skills"> | string
    proficiency?: EnumskillsstatusWithAggregatesFilter<"skills"> | $Enums.skillsstatus
    year_of_experience?: IntWithAggregatesFilter<"skills"> | number
    is_certifield?: BoolWithAggregatesFilter<"skills"> | boolean
  }

  export type languagesWhereInput = {
    AND?: languagesWhereInput | languagesWhereInput[]
    OR?: languagesWhereInput[]
    NOT?: languagesWhereInput | languagesWhereInput[]
    id?: IntFilter<"languages"> | number
    user_id?: IntFilter<"languages"> | number
    languages?: StringFilter<"languages"> | string
    proficiency?: EnumproficiencylanguagesFilter<"languages"> | $Enums.proficiencylanguages
    is_primary?: BoolFilter<"languages"> | boolean
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type languagesOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    languages?: SortOrder
    proficiency?: SortOrder
    is_primary?: SortOrder
    user?: usersOrderByWithRelationInput
  }

  export type languagesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: languagesWhereInput | languagesWhereInput[]
    OR?: languagesWhereInput[]
    NOT?: languagesWhereInput | languagesWhereInput[]
    user_id?: IntFilter<"languages"> | number
    languages?: StringFilter<"languages"> | string
    proficiency?: EnumproficiencylanguagesFilter<"languages"> | $Enums.proficiencylanguages
    is_primary?: BoolFilter<"languages"> | boolean
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type languagesOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    languages?: SortOrder
    proficiency?: SortOrder
    is_primary?: SortOrder
    _count?: languagesCountOrderByAggregateInput
    _avg?: languagesAvgOrderByAggregateInput
    _max?: languagesMaxOrderByAggregateInput
    _min?: languagesMinOrderByAggregateInput
    _sum?: languagesSumOrderByAggregateInput
  }

  export type languagesScalarWhereWithAggregatesInput = {
    AND?: languagesScalarWhereWithAggregatesInput | languagesScalarWhereWithAggregatesInput[]
    OR?: languagesScalarWhereWithAggregatesInput[]
    NOT?: languagesScalarWhereWithAggregatesInput | languagesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"languages"> | number
    user_id?: IntWithAggregatesFilter<"languages"> | number
    languages?: StringWithAggregatesFilter<"languages"> | string
    proficiency?: EnumproficiencylanguagesWithAggregatesFilter<"languages"> | $Enums.proficiencylanguages
    is_primary?: BoolWithAggregatesFilter<"languages"> | boolean
  }

  export type certificationsWhereInput = {
    AND?: certificationsWhereInput | certificationsWhereInput[]
    OR?: certificationsWhereInput[]
    NOT?: certificationsWhereInput | certificationsWhereInput[]
    id?: IntFilter<"certifications"> | number
    user_id?: IntFilter<"certifications"> | number
    name?: StringFilter<"certifications"> | string
    issuing_organization?: StringFilter<"certifications"> | string
    issue_date?: DateTimeFilter<"certifications"> | Date | string
    expiration_date?: DateTimeFilter<"certifications"> | Date | string
    credential_id?: StringFilter<"certifications"> | string
    credential_url?: StringFilter<"certifications"> | string
    is_foreign_certification?: BoolFilter<"certifications"> | boolean
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type certificationsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    issuing_organization?: SortOrder
    issue_date?: SortOrder
    expiration_date?: SortOrder
    credential_id?: SortOrder
    credential_url?: SortOrder
    is_foreign_certification?: SortOrder
    user?: usersOrderByWithRelationInput
  }

  export type certificationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: certificationsWhereInput | certificationsWhereInput[]
    OR?: certificationsWhereInput[]
    NOT?: certificationsWhereInput | certificationsWhereInput[]
    user_id?: IntFilter<"certifications"> | number
    name?: StringFilter<"certifications"> | string
    issuing_organization?: StringFilter<"certifications"> | string
    issue_date?: DateTimeFilter<"certifications"> | Date | string
    expiration_date?: DateTimeFilter<"certifications"> | Date | string
    credential_id?: StringFilter<"certifications"> | string
    credential_url?: StringFilter<"certifications"> | string
    is_foreign_certification?: BoolFilter<"certifications"> | boolean
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type certificationsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    issuing_organization?: SortOrder
    issue_date?: SortOrder
    expiration_date?: SortOrder
    credential_id?: SortOrder
    credential_url?: SortOrder
    is_foreign_certification?: SortOrder
    _count?: certificationsCountOrderByAggregateInput
    _avg?: certificationsAvgOrderByAggregateInput
    _max?: certificationsMaxOrderByAggregateInput
    _min?: certificationsMinOrderByAggregateInput
    _sum?: certificationsSumOrderByAggregateInput
  }

  export type certificationsScalarWhereWithAggregatesInput = {
    AND?: certificationsScalarWhereWithAggregatesInput | certificationsScalarWhereWithAggregatesInput[]
    OR?: certificationsScalarWhereWithAggregatesInput[]
    NOT?: certificationsScalarWhereWithAggregatesInput | certificationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"certifications"> | number
    user_id?: IntWithAggregatesFilter<"certifications"> | number
    name?: StringWithAggregatesFilter<"certifications"> | string
    issuing_organization?: StringWithAggregatesFilter<"certifications"> | string
    issue_date?: DateTimeWithAggregatesFilter<"certifications"> | Date | string
    expiration_date?: DateTimeWithAggregatesFilter<"certifications"> | Date | string
    credential_id?: StringWithAggregatesFilter<"certifications"> | string
    credential_url?: StringWithAggregatesFilter<"certifications"> | string
    is_foreign_certification?: BoolWithAggregatesFilter<"certifications"> | boolean
  }

  export type visa_informationWhereInput = {
    AND?: visa_informationWhereInput | visa_informationWhereInput[]
    OR?: visa_informationWhereInput[]
    NOT?: visa_informationWhereInput | visa_informationWhereInput[]
    id?: IntFilter<"visa_information"> | number
    user_id?: IntFilter<"visa_information"> | number
    visa_type?: StringFilter<"visa_information"> | string
    country?: StringFilter<"visa_information"> | string
    status?: StringFilter<"visa_information"> | string
    expiry__date?: DateTimeFilter<"visa_information"> | Date | string
    is_multiple_entry?: BoolFilter<"visa_information"> | boolean
    notes?: StringFilter<"visa_information"> | string
    visa?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type visa_informationOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    visa_type?: SortOrder
    country?: SortOrder
    status?: SortOrder
    expiry__date?: SortOrder
    is_multiple_entry?: SortOrder
    notes?: SortOrder
    visa?: usersOrderByWithRelationInput
  }

  export type visa_informationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: visa_informationWhereInput | visa_informationWhereInput[]
    OR?: visa_informationWhereInput[]
    NOT?: visa_informationWhereInput | visa_informationWhereInput[]
    user_id?: IntFilter<"visa_information"> | number
    visa_type?: StringFilter<"visa_information"> | string
    country?: StringFilter<"visa_information"> | string
    status?: StringFilter<"visa_information"> | string
    expiry__date?: DateTimeFilter<"visa_information"> | Date | string
    is_multiple_entry?: BoolFilter<"visa_information"> | boolean
    notes?: StringFilter<"visa_information"> | string
    visa?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type visa_informationOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    visa_type?: SortOrder
    country?: SortOrder
    status?: SortOrder
    expiry__date?: SortOrder
    is_multiple_entry?: SortOrder
    notes?: SortOrder
    _count?: visa_informationCountOrderByAggregateInput
    _avg?: visa_informationAvgOrderByAggregateInput
    _max?: visa_informationMaxOrderByAggregateInput
    _min?: visa_informationMinOrderByAggregateInput
    _sum?: visa_informationSumOrderByAggregateInput
  }

  export type visa_informationScalarWhereWithAggregatesInput = {
    AND?: visa_informationScalarWhereWithAggregatesInput | visa_informationScalarWhereWithAggregatesInput[]
    OR?: visa_informationScalarWhereWithAggregatesInput[]
    NOT?: visa_informationScalarWhereWithAggregatesInput | visa_informationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"visa_information"> | number
    user_id?: IntWithAggregatesFilter<"visa_information"> | number
    visa_type?: StringWithAggregatesFilter<"visa_information"> | string
    country?: StringWithAggregatesFilter<"visa_information"> | string
    status?: StringWithAggregatesFilter<"visa_information"> | string
    expiry__date?: DateTimeWithAggregatesFilter<"visa_information"> | Date | string
    is_multiple_entry?: BoolWithAggregatesFilter<"visa_information"> | boolean
    notes?: StringWithAggregatesFilter<"visa_information"> | string
  }

  export type companiesWhereInput = {
    AND?: companiesWhereInput | companiesWhereInput[]
    OR?: companiesWhereInput[]
    NOT?: companiesWhereInput | companiesWhereInput[]
    id?: IntFilter<"companies"> | number
    name?: StringFilter<"companies"> | string
    description?: StringFilter<"companies"> | string
    industry?: StringFilter<"companies"> | string
    founded_year?: IntFilter<"companies"> | number
    website_url?: StringFilter<"companies"> | string
    logo_url?: StringFilter<"companies"> | string
    headquarters_country?: StringFilter<"companies"> | string
    company_siz?: EnumcompanySizeFilter<"companies"> | $Enums.companySize
    is_verified?: BoolFilter<"companies"> | boolean
    created_at?: DateTimeFilter<"companies"> | Date | string
    companies?: Company_locationsListRelationFilter
    job?: JobsListRelationFilter
    contacts?: ContactsListRelationFilter
  }

  export type companiesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    industry?: SortOrder
    founded_year?: SortOrder
    website_url?: SortOrder
    logo_url?: SortOrder
    headquarters_country?: SortOrder
    company_siz?: SortOrder
    is_verified?: SortOrder
    created_at?: SortOrder
    companies?: company_locationsOrderByRelationAggregateInput
    job?: jobsOrderByRelationAggregateInput
    contacts?: contactsOrderByRelationAggregateInput
  }

  export type companiesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: companiesWhereInput | companiesWhereInput[]
    OR?: companiesWhereInput[]
    NOT?: companiesWhereInput | companiesWhereInput[]
    name?: StringFilter<"companies"> | string
    description?: StringFilter<"companies"> | string
    industry?: StringFilter<"companies"> | string
    founded_year?: IntFilter<"companies"> | number
    website_url?: StringFilter<"companies"> | string
    logo_url?: StringFilter<"companies"> | string
    headquarters_country?: StringFilter<"companies"> | string
    company_siz?: EnumcompanySizeFilter<"companies"> | $Enums.companySize
    is_verified?: BoolFilter<"companies"> | boolean
    created_at?: DateTimeFilter<"companies"> | Date | string
    companies?: Company_locationsListRelationFilter
    job?: JobsListRelationFilter
    contacts?: ContactsListRelationFilter
  }, "id">

  export type companiesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    industry?: SortOrder
    founded_year?: SortOrder
    website_url?: SortOrder
    logo_url?: SortOrder
    headquarters_country?: SortOrder
    company_siz?: SortOrder
    is_verified?: SortOrder
    created_at?: SortOrder
    _count?: companiesCountOrderByAggregateInput
    _avg?: companiesAvgOrderByAggregateInput
    _max?: companiesMaxOrderByAggregateInput
    _min?: companiesMinOrderByAggregateInput
    _sum?: companiesSumOrderByAggregateInput
  }

  export type companiesScalarWhereWithAggregatesInput = {
    AND?: companiesScalarWhereWithAggregatesInput | companiesScalarWhereWithAggregatesInput[]
    OR?: companiesScalarWhereWithAggregatesInput[]
    NOT?: companiesScalarWhereWithAggregatesInput | companiesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"companies"> | number
    name?: StringWithAggregatesFilter<"companies"> | string
    description?: StringWithAggregatesFilter<"companies"> | string
    industry?: StringWithAggregatesFilter<"companies"> | string
    founded_year?: IntWithAggregatesFilter<"companies"> | number
    website_url?: StringWithAggregatesFilter<"companies"> | string
    logo_url?: StringWithAggregatesFilter<"companies"> | string
    headquarters_country?: StringWithAggregatesFilter<"companies"> | string
    company_siz?: EnumcompanySizeWithAggregatesFilter<"companies"> | $Enums.companySize
    is_verified?: BoolWithAggregatesFilter<"companies"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"companies"> | Date | string
  }

  export type company_locationsWhereInput = {
    AND?: company_locationsWhereInput | company_locationsWhereInput[]
    OR?: company_locationsWhereInput[]
    NOT?: company_locationsWhereInput | company_locationsWhereInput[]
    id?: IntFilter<"company_locations"> | number
    company_id?: IntFilter<"company_locations"> | number
    country?: StringFilter<"company_locations"> | string
    city?: StringFilter<"company_locations"> | string
    address?: StringFilter<"company_locations"> | string
    is_headquarters?: BoolFilter<"company_locations"> | boolean
    phone_number?: StringFilter<"company_locations"> | string
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
  }

  export type company_locationsOrderByWithRelationInput = {
    id?: SortOrder
    company_id?: SortOrder
    country?: SortOrder
    city?: SortOrder
    address?: SortOrder
    is_headquarters?: SortOrder
    phone_number?: SortOrder
    companies?: companiesOrderByWithRelationInput
  }

  export type company_locationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: company_locationsWhereInput | company_locationsWhereInput[]
    OR?: company_locationsWhereInput[]
    NOT?: company_locationsWhereInput | company_locationsWhereInput[]
    company_id?: IntFilter<"company_locations"> | number
    country?: StringFilter<"company_locations"> | string
    city?: StringFilter<"company_locations"> | string
    address?: StringFilter<"company_locations"> | string
    is_headquarters?: BoolFilter<"company_locations"> | boolean
    phone_number?: StringFilter<"company_locations"> | string
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
  }, "id">

  export type company_locationsOrderByWithAggregationInput = {
    id?: SortOrder
    company_id?: SortOrder
    country?: SortOrder
    city?: SortOrder
    address?: SortOrder
    is_headquarters?: SortOrder
    phone_number?: SortOrder
    _count?: company_locationsCountOrderByAggregateInput
    _avg?: company_locationsAvgOrderByAggregateInput
    _max?: company_locationsMaxOrderByAggregateInput
    _min?: company_locationsMinOrderByAggregateInput
    _sum?: company_locationsSumOrderByAggregateInput
  }

  export type company_locationsScalarWhereWithAggregatesInput = {
    AND?: company_locationsScalarWhereWithAggregatesInput | company_locationsScalarWhereWithAggregatesInput[]
    OR?: company_locationsScalarWhereWithAggregatesInput[]
    NOT?: company_locationsScalarWhereWithAggregatesInput | company_locationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"company_locations"> | number
    company_id?: IntWithAggregatesFilter<"company_locations"> | number
    country?: StringWithAggregatesFilter<"company_locations"> | string
    city?: StringWithAggregatesFilter<"company_locations"> | string
    address?: StringWithAggregatesFilter<"company_locations"> | string
    is_headquarters?: BoolWithAggregatesFilter<"company_locations"> | boolean
    phone_number?: StringWithAggregatesFilter<"company_locations"> | string
  }

  export type jobsWhereInput = {
    AND?: jobsWhereInput | jobsWhereInput[]
    OR?: jobsWhereInput[]
    NOT?: jobsWhereInput | jobsWhereInput[]
    id?: IntFilter<"jobs"> | number
    company_id?: IntFilter<"jobs"> | number
    title?: StringFilter<"jobs"> | string
    description?: StringFilter<"jobs"> | string
    job_category?: StringFilter<"jobs"> | string
    job_type?: EnumjobTypeFilter<"jobs"> | $Enums.jobType
    location_country?: StringFilter<"jobs"> | string
    location_city?: StringFilter<"jobs"> | string
    is_relocation_assistance?: BoolFilter<"jobs"> | boolean
    is_remote_possible?: BoolFilter<"jobs"> | boolean
    salary_currency?: StringFilter<"jobs"> | string
    salary_min?: IntFilter<"jobs"> | number
    salary_max?: IntFilter<"jobs"> | number
    salary_period?: EnumsalaryPeriodFilter<"jobs"> | $Enums.salaryPeriod
    visa_sponsorship?: EnumvisaSponsorshipFilter<"jobs"> | $Enums.visaSponsorship
    experience_level?: EnumexpLevelFilter<"jobs"> | $Enums.expLevel
    education_requirement?: StringFilter<"jobs"> | string
    posted_by?: IntFilter<"jobs"> | number
    status?: EnumjobStatusFilter<"jobs"> | $Enums.jobStatus
    posted_at?: DateTimeFilter<"jobs"> | Date | string
    deadline?: DateTimeFilter<"jobs"> | Date | string
    views_count?: IntFilter<"jobs"> | number
    job?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
    requirements?: Job_requirementsListRelationFilter
    responsibilites?: Job_responsibilitesListRelationFilter
    benefits?: Job_benefitsListRelationFilter
    application?: ApplicationsListRelationFilter
    contact?: ContactsListRelationFilter
    savedjob?: Saved_jobsListRelationFilter
  }

  export type jobsOrderByWithRelationInput = {
    id?: SortOrder
    company_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    job_category?: SortOrder
    job_type?: SortOrder
    location_country?: SortOrder
    location_city?: SortOrder
    is_relocation_assistance?: SortOrder
    is_remote_possible?: SortOrder
    salary_currency?: SortOrder
    salary_min?: SortOrder
    salary_max?: SortOrder
    salary_period?: SortOrder
    visa_sponsorship?: SortOrder
    experience_level?: SortOrder
    education_requirement?: SortOrder
    posted_by?: SortOrder
    status?: SortOrder
    posted_at?: SortOrder
    deadline?: SortOrder
    views_count?: SortOrder
    job?: companiesOrderByWithRelationInput
    requirements?: job_requirementsOrderByRelationAggregateInput
    responsibilites?: job_responsibilitesOrderByRelationAggregateInput
    benefits?: job_benefitsOrderByRelationAggregateInput
    application?: applicationsOrderByRelationAggregateInput
    contact?: contactsOrderByRelationAggregateInput
    savedjob?: saved_jobsOrderByRelationAggregateInput
  }

  export type jobsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: jobsWhereInput | jobsWhereInput[]
    OR?: jobsWhereInput[]
    NOT?: jobsWhereInput | jobsWhereInput[]
    company_id?: IntFilter<"jobs"> | number
    title?: StringFilter<"jobs"> | string
    description?: StringFilter<"jobs"> | string
    job_category?: StringFilter<"jobs"> | string
    job_type?: EnumjobTypeFilter<"jobs"> | $Enums.jobType
    location_country?: StringFilter<"jobs"> | string
    location_city?: StringFilter<"jobs"> | string
    is_relocation_assistance?: BoolFilter<"jobs"> | boolean
    is_remote_possible?: BoolFilter<"jobs"> | boolean
    salary_currency?: StringFilter<"jobs"> | string
    salary_min?: IntFilter<"jobs"> | number
    salary_max?: IntFilter<"jobs"> | number
    salary_period?: EnumsalaryPeriodFilter<"jobs"> | $Enums.salaryPeriod
    visa_sponsorship?: EnumvisaSponsorshipFilter<"jobs"> | $Enums.visaSponsorship
    experience_level?: EnumexpLevelFilter<"jobs"> | $Enums.expLevel
    education_requirement?: StringFilter<"jobs"> | string
    posted_by?: IntFilter<"jobs"> | number
    status?: EnumjobStatusFilter<"jobs"> | $Enums.jobStatus
    posted_at?: DateTimeFilter<"jobs"> | Date | string
    deadline?: DateTimeFilter<"jobs"> | Date | string
    views_count?: IntFilter<"jobs"> | number
    job?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
    requirements?: Job_requirementsListRelationFilter
    responsibilites?: Job_responsibilitesListRelationFilter
    benefits?: Job_benefitsListRelationFilter
    application?: ApplicationsListRelationFilter
    contact?: ContactsListRelationFilter
    savedjob?: Saved_jobsListRelationFilter
  }, "id">

  export type jobsOrderByWithAggregationInput = {
    id?: SortOrder
    company_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    job_category?: SortOrder
    job_type?: SortOrder
    location_country?: SortOrder
    location_city?: SortOrder
    is_relocation_assistance?: SortOrder
    is_remote_possible?: SortOrder
    salary_currency?: SortOrder
    salary_min?: SortOrder
    salary_max?: SortOrder
    salary_period?: SortOrder
    visa_sponsorship?: SortOrder
    experience_level?: SortOrder
    education_requirement?: SortOrder
    posted_by?: SortOrder
    status?: SortOrder
    posted_at?: SortOrder
    deadline?: SortOrder
    views_count?: SortOrder
    _count?: jobsCountOrderByAggregateInput
    _avg?: jobsAvgOrderByAggregateInput
    _max?: jobsMaxOrderByAggregateInput
    _min?: jobsMinOrderByAggregateInput
    _sum?: jobsSumOrderByAggregateInput
  }

  export type jobsScalarWhereWithAggregatesInput = {
    AND?: jobsScalarWhereWithAggregatesInput | jobsScalarWhereWithAggregatesInput[]
    OR?: jobsScalarWhereWithAggregatesInput[]
    NOT?: jobsScalarWhereWithAggregatesInput | jobsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"jobs"> | number
    company_id?: IntWithAggregatesFilter<"jobs"> | number
    title?: StringWithAggregatesFilter<"jobs"> | string
    description?: StringWithAggregatesFilter<"jobs"> | string
    job_category?: StringWithAggregatesFilter<"jobs"> | string
    job_type?: EnumjobTypeWithAggregatesFilter<"jobs"> | $Enums.jobType
    location_country?: StringWithAggregatesFilter<"jobs"> | string
    location_city?: StringWithAggregatesFilter<"jobs"> | string
    is_relocation_assistance?: BoolWithAggregatesFilter<"jobs"> | boolean
    is_remote_possible?: BoolWithAggregatesFilter<"jobs"> | boolean
    salary_currency?: StringWithAggregatesFilter<"jobs"> | string
    salary_min?: IntWithAggregatesFilter<"jobs"> | number
    salary_max?: IntWithAggregatesFilter<"jobs"> | number
    salary_period?: EnumsalaryPeriodWithAggregatesFilter<"jobs"> | $Enums.salaryPeriod
    visa_sponsorship?: EnumvisaSponsorshipWithAggregatesFilter<"jobs"> | $Enums.visaSponsorship
    experience_level?: EnumexpLevelWithAggregatesFilter<"jobs"> | $Enums.expLevel
    education_requirement?: StringWithAggregatesFilter<"jobs"> | string
    posted_by?: IntWithAggregatesFilter<"jobs"> | number
    status?: EnumjobStatusWithAggregatesFilter<"jobs"> | $Enums.jobStatus
    posted_at?: DateTimeWithAggregatesFilter<"jobs"> | Date | string
    deadline?: DateTimeWithAggregatesFilter<"jobs"> | Date | string
    views_count?: IntWithAggregatesFilter<"jobs"> | number
  }

  export type job_requirementsWhereInput = {
    AND?: job_requirementsWhereInput | job_requirementsWhereInput[]
    OR?: job_requirementsWhereInput[]
    NOT?: job_requirementsWhereInput | job_requirementsWhereInput[]
    id?: IntFilter<"job_requirements"> | number
    job_id?: IntFilter<"job_requirements"> | number
    requirement_type?: EnumjobRequirementsFilter<"job_requirements"> | $Enums.jobRequirements
    requirement_text?: StringFilter<"job_requirements"> | string
    is_mandatory?: BoolFilter<"job_requirements"> | boolean
    priority?: IntFilter<"job_requirements"> | number
    requirements?: XOR<JobsScalarRelationFilter, jobsWhereInput>
  }

  export type job_requirementsOrderByWithRelationInput = {
    id?: SortOrder
    job_id?: SortOrder
    requirement_type?: SortOrder
    requirement_text?: SortOrder
    is_mandatory?: SortOrder
    priority?: SortOrder
    requirements?: jobsOrderByWithRelationInput
  }

  export type job_requirementsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: job_requirementsWhereInput | job_requirementsWhereInput[]
    OR?: job_requirementsWhereInput[]
    NOT?: job_requirementsWhereInput | job_requirementsWhereInput[]
    job_id?: IntFilter<"job_requirements"> | number
    requirement_type?: EnumjobRequirementsFilter<"job_requirements"> | $Enums.jobRequirements
    requirement_text?: StringFilter<"job_requirements"> | string
    is_mandatory?: BoolFilter<"job_requirements"> | boolean
    priority?: IntFilter<"job_requirements"> | number
    requirements?: XOR<JobsScalarRelationFilter, jobsWhereInput>
  }, "id">

  export type job_requirementsOrderByWithAggregationInput = {
    id?: SortOrder
    job_id?: SortOrder
    requirement_type?: SortOrder
    requirement_text?: SortOrder
    is_mandatory?: SortOrder
    priority?: SortOrder
    _count?: job_requirementsCountOrderByAggregateInput
    _avg?: job_requirementsAvgOrderByAggregateInput
    _max?: job_requirementsMaxOrderByAggregateInput
    _min?: job_requirementsMinOrderByAggregateInput
    _sum?: job_requirementsSumOrderByAggregateInput
  }

  export type job_requirementsScalarWhereWithAggregatesInput = {
    AND?: job_requirementsScalarWhereWithAggregatesInput | job_requirementsScalarWhereWithAggregatesInput[]
    OR?: job_requirementsScalarWhereWithAggregatesInput[]
    NOT?: job_requirementsScalarWhereWithAggregatesInput | job_requirementsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"job_requirements"> | number
    job_id?: IntWithAggregatesFilter<"job_requirements"> | number
    requirement_type?: EnumjobRequirementsWithAggregatesFilter<"job_requirements"> | $Enums.jobRequirements
    requirement_text?: StringWithAggregatesFilter<"job_requirements"> | string
    is_mandatory?: BoolWithAggregatesFilter<"job_requirements"> | boolean
    priority?: IntWithAggregatesFilter<"job_requirements"> | number
  }

  export type job_responsibilitesWhereInput = {
    AND?: job_responsibilitesWhereInput | job_responsibilitesWhereInput[]
    OR?: job_responsibilitesWhereInput[]
    NOT?: job_responsibilitesWhereInput | job_responsibilitesWhereInput[]
    id?: IntFilter<"job_responsibilites"> | number
    job_id?: IntFilter<"job_responsibilites"> | number
    responsibility_text?: StringFilter<"job_responsibilites"> | string
    priority?: IntFilter<"job_responsibilites"> | number
    responsibilites?: XOR<JobsScalarRelationFilter, jobsWhereInput>
  }

  export type job_responsibilitesOrderByWithRelationInput = {
    id?: SortOrder
    job_id?: SortOrder
    responsibility_text?: SortOrder
    priority?: SortOrder
    responsibilites?: jobsOrderByWithRelationInput
  }

  export type job_responsibilitesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: job_responsibilitesWhereInput | job_responsibilitesWhereInput[]
    OR?: job_responsibilitesWhereInput[]
    NOT?: job_responsibilitesWhereInput | job_responsibilitesWhereInput[]
    job_id?: IntFilter<"job_responsibilites"> | number
    responsibility_text?: StringFilter<"job_responsibilites"> | string
    priority?: IntFilter<"job_responsibilites"> | number
    responsibilites?: XOR<JobsScalarRelationFilter, jobsWhereInput>
  }, "id">

  export type job_responsibilitesOrderByWithAggregationInput = {
    id?: SortOrder
    job_id?: SortOrder
    responsibility_text?: SortOrder
    priority?: SortOrder
    _count?: job_responsibilitesCountOrderByAggregateInput
    _avg?: job_responsibilitesAvgOrderByAggregateInput
    _max?: job_responsibilitesMaxOrderByAggregateInput
    _min?: job_responsibilitesMinOrderByAggregateInput
    _sum?: job_responsibilitesSumOrderByAggregateInput
  }

  export type job_responsibilitesScalarWhereWithAggregatesInput = {
    AND?: job_responsibilitesScalarWhereWithAggregatesInput | job_responsibilitesScalarWhereWithAggregatesInput[]
    OR?: job_responsibilitesScalarWhereWithAggregatesInput[]
    NOT?: job_responsibilitesScalarWhereWithAggregatesInput | job_responsibilitesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"job_responsibilites"> | number
    job_id?: IntWithAggregatesFilter<"job_responsibilites"> | number
    responsibility_text?: StringWithAggregatesFilter<"job_responsibilites"> | string
    priority?: IntWithAggregatesFilter<"job_responsibilites"> | number
  }

  export type job_benefitsWhereInput = {
    AND?: job_benefitsWhereInput | job_benefitsWhereInput[]
    OR?: job_benefitsWhereInput[]
    NOT?: job_benefitsWhereInput | job_benefitsWhereInput[]
    id?: IntFilter<"job_benefits"> | number
    job_id?: IntFilter<"job_benefits"> | number
    benefit_type?: EnumjobBenefitFilter<"job_benefits"> | $Enums.jobBenefit
    description?: StringFilter<"job_benefits"> | string
    benefits?: XOR<JobsScalarRelationFilter, jobsWhereInput>
  }

  export type job_benefitsOrderByWithRelationInput = {
    id?: SortOrder
    job_id?: SortOrder
    benefit_type?: SortOrder
    description?: SortOrder
    benefits?: jobsOrderByWithRelationInput
  }

  export type job_benefitsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: job_benefitsWhereInput | job_benefitsWhereInput[]
    OR?: job_benefitsWhereInput[]
    NOT?: job_benefitsWhereInput | job_benefitsWhereInput[]
    job_id?: IntFilter<"job_benefits"> | number
    benefit_type?: EnumjobBenefitFilter<"job_benefits"> | $Enums.jobBenefit
    description?: StringFilter<"job_benefits"> | string
    benefits?: XOR<JobsScalarRelationFilter, jobsWhereInput>
  }, "id">

  export type job_benefitsOrderByWithAggregationInput = {
    id?: SortOrder
    job_id?: SortOrder
    benefit_type?: SortOrder
    description?: SortOrder
    _count?: job_benefitsCountOrderByAggregateInput
    _avg?: job_benefitsAvgOrderByAggregateInput
    _max?: job_benefitsMaxOrderByAggregateInput
    _min?: job_benefitsMinOrderByAggregateInput
    _sum?: job_benefitsSumOrderByAggregateInput
  }

  export type job_benefitsScalarWhereWithAggregatesInput = {
    AND?: job_benefitsScalarWhereWithAggregatesInput | job_benefitsScalarWhereWithAggregatesInput[]
    OR?: job_benefitsScalarWhereWithAggregatesInput[]
    NOT?: job_benefitsScalarWhereWithAggregatesInput | job_benefitsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"job_benefits"> | number
    job_id?: IntWithAggregatesFilter<"job_benefits"> | number
    benefit_type?: EnumjobBenefitWithAggregatesFilter<"job_benefits"> | $Enums.jobBenefit
    description?: StringWithAggregatesFilter<"job_benefits"> | string
  }

  export type applicationsWhereInput = {
    AND?: applicationsWhereInput | applicationsWhereInput[]
    OR?: applicationsWhereInput[]
    NOT?: applicationsWhereInput | applicationsWhereInput[]
    id?: IntFilter<"applications"> | number
    job_id?: IntFilter<"applications"> | number
    user_id?: IntFilter<"applications"> | number
    resume_id?: IntFilter<"applications"> | number
    cover_letter?: StringFilter<"applications"> | string
    status?: EnumapplicationStatusFilter<"applications"> | $Enums.applicationStatus
    applited_at?: DateTimeFilter<"applications"> | Date | string
    updated_at?: DateTimeFilter<"applications"> | Date | string
    notes?: StringFilter<"applications"> | string
    application?: XOR<JobsScalarRelationFilter, jobsWhereInput>
    aplication?: XOR<UsersScalarRelationFilter, usersWhereInput>
    applications?: XOR<ResumesScalarRelationFilter, resumesWhereInput>
    document?: Application_documentsListRelationFilter
    interview?: InterviewsListRelationFilter
  }

  export type applicationsOrderByWithRelationInput = {
    id?: SortOrder
    job_id?: SortOrder
    user_id?: SortOrder
    resume_id?: SortOrder
    cover_letter?: SortOrder
    status?: SortOrder
    applited_at?: SortOrder
    updated_at?: SortOrder
    notes?: SortOrder
    application?: jobsOrderByWithRelationInput
    aplication?: usersOrderByWithRelationInput
    applications?: resumesOrderByWithRelationInput
    document?: application_documentsOrderByRelationAggregateInput
    interview?: interviewsOrderByRelationAggregateInput
  }

  export type applicationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: applicationsWhereInput | applicationsWhereInput[]
    OR?: applicationsWhereInput[]
    NOT?: applicationsWhereInput | applicationsWhereInput[]
    job_id?: IntFilter<"applications"> | number
    user_id?: IntFilter<"applications"> | number
    resume_id?: IntFilter<"applications"> | number
    cover_letter?: StringFilter<"applications"> | string
    status?: EnumapplicationStatusFilter<"applications"> | $Enums.applicationStatus
    applited_at?: DateTimeFilter<"applications"> | Date | string
    updated_at?: DateTimeFilter<"applications"> | Date | string
    notes?: StringFilter<"applications"> | string
    application?: XOR<JobsScalarRelationFilter, jobsWhereInput>
    aplication?: XOR<UsersScalarRelationFilter, usersWhereInput>
    applications?: XOR<ResumesScalarRelationFilter, resumesWhereInput>
    document?: Application_documentsListRelationFilter
    interview?: InterviewsListRelationFilter
  }, "id">

  export type applicationsOrderByWithAggregationInput = {
    id?: SortOrder
    job_id?: SortOrder
    user_id?: SortOrder
    resume_id?: SortOrder
    cover_letter?: SortOrder
    status?: SortOrder
    applited_at?: SortOrder
    updated_at?: SortOrder
    notes?: SortOrder
    _count?: applicationsCountOrderByAggregateInput
    _avg?: applicationsAvgOrderByAggregateInput
    _max?: applicationsMaxOrderByAggregateInput
    _min?: applicationsMinOrderByAggregateInput
    _sum?: applicationsSumOrderByAggregateInput
  }

  export type applicationsScalarWhereWithAggregatesInput = {
    AND?: applicationsScalarWhereWithAggregatesInput | applicationsScalarWhereWithAggregatesInput[]
    OR?: applicationsScalarWhereWithAggregatesInput[]
    NOT?: applicationsScalarWhereWithAggregatesInput | applicationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"applications"> | number
    job_id?: IntWithAggregatesFilter<"applications"> | number
    user_id?: IntWithAggregatesFilter<"applications"> | number
    resume_id?: IntWithAggregatesFilter<"applications"> | number
    cover_letter?: StringWithAggregatesFilter<"applications"> | string
    status?: EnumapplicationStatusWithAggregatesFilter<"applications"> | $Enums.applicationStatus
    applited_at?: DateTimeWithAggregatesFilter<"applications"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"applications"> | Date | string
    notes?: StringWithAggregatesFilter<"applications"> | string
  }

  export type application_documentsWhereInput = {
    AND?: application_documentsWhereInput | application_documentsWhereInput[]
    OR?: application_documentsWhereInput[]
    NOT?: application_documentsWhereInput | application_documentsWhereInput[]
    id?: IntFilter<"application_documents"> | number
    application_id?: IntFilter<"application_documents"> | number
    document_type?: EnumappDocumentStatusFilter<"application_documents"> | $Enums.appDocumentStatus
    file_url?: StringFilter<"application_documents"> | string
    uploaded_at?: DateTimeFilter<"application_documents"> | Date | string
    document?: XOR<ApplicationsScalarRelationFilter, applicationsWhereInput>
  }

  export type application_documentsOrderByWithRelationInput = {
    id?: SortOrder
    application_id?: SortOrder
    document_type?: SortOrder
    file_url?: SortOrder
    uploaded_at?: SortOrder
    document?: applicationsOrderByWithRelationInput
  }

  export type application_documentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: application_documentsWhereInput | application_documentsWhereInput[]
    OR?: application_documentsWhereInput[]
    NOT?: application_documentsWhereInput | application_documentsWhereInput[]
    application_id?: IntFilter<"application_documents"> | number
    document_type?: EnumappDocumentStatusFilter<"application_documents"> | $Enums.appDocumentStatus
    file_url?: StringFilter<"application_documents"> | string
    uploaded_at?: DateTimeFilter<"application_documents"> | Date | string
    document?: XOR<ApplicationsScalarRelationFilter, applicationsWhereInput>
  }, "id">

  export type application_documentsOrderByWithAggregationInput = {
    id?: SortOrder
    application_id?: SortOrder
    document_type?: SortOrder
    file_url?: SortOrder
    uploaded_at?: SortOrder
    _count?: application_documentsCountOrderByAggregateInput
    _avg?: application_documentsAvgOrderByAggregateInput
    _max?: application_documentsMaxOrderByAggregateInput
    _min?: application_documentsMinOrderByAggregateInput
    _sum?: application_documentsSumOrderByAggregateInput
  }

  export type application_documentsScalarWhereWithAggregatesInput = {
    AND?: application_documentsScalarWhereWithAggregatesInput | application_documentsScalarWhereWithAggregatesInput[]
    OR?: application_documentsScalarWhereWithAggregatesInput[]
    NOT?: application_documentsScalarWhereWithAggregatesInput | application_documentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"application_documents"> | number
    application_id?: IntWithAggregatesFilter<"application_documents"> | number
    document_type?: EnumappDocumentStatusWithAggregatesFilter<"application_documents"> | $Enums.appDocumentStatus
    file_url?: StringWithAggregatesFilter<"application_documents"> | string
    uploaded_at?: DateTimeWithAggregatesFilter<"application_documents"> | Date | string
  }

  export type interviewsWhereInput = {
    AND?: interviewsWhereInput | interviewsWhereInput[]
    OR?: interviewsWhereInput[]
    NOT?: interviewsWhereInput | interviewsWhereInput[]
    id?: IntFilter<"interviews"> | number
    application_id?: IntFilter<"interviews"> | number
    interview_type?: EnuminterviewTypeFilter<"interviews"> | $Enums.interviewType
    scheduled_time?: DateTimeFilter<"interviews"> | Date | string
    timezone?: StringFilter<"interviews"> | string
    duration_minutes?: IntFilter<"interviews"> | number
    location?: StringFilter<"interviews"> | string
    meeting_url?: StringFilter<"interviews"> | string
    interview_name?: StringFilter<"interviews"> | string
    interview_position?: StringFilter<"interviews"> | string
    status?: EnuminterviewStatusFilter<"interviews"> | $Enums.interviewStatus
    feedback?: StringFilter<"interviews"> | string
    rating?: IntFilter<"interviews"> | number
    notes?: StringFilter<"interviews"> | string
    created_at?: DateTimeFilter<"interviews"> | Date | string
    updated_at?: DateTimeFilter<"interviews"> | Date | string
    interview?: XOR<ApplicationsScalarRelationFilter, applicationsWhereInput>
  }

  export type interviewsOrderByWithRelationInput = {
    id?: SortOrder
    application_id?: SortOrder
    interview_type?: SortOrder
    scheduled_time?: SortOrder
    timezone?: SortOrder
    duration_minutes?: SortOrder
    location?: SortOrder
    meeting_url?: SortOrder
    interview_name?: SortOrder
    interview_position?: SortOrder
    status?: SortOrder
    feedback?: SortOrder
    rating?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    interview?: applicationsOrderByWithRelationInput
  }

  export type interviewsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: interviewsWhereInput | interviewsWhereInput[]
    OR?: interviewsWhereInput[]
    NOT?: interviewsWhereInput | interviewsWhereInput[]
    application_id?: IntFilter<"interviews"> | number
    interview_type?: EnuminterviewTypeFilter<"interviews"> | $Enums.interviewType
    scheduled_time?: DateTimeFilter<"interviews"> | Date | string
    timezone?: StringFilter<"interviews"> | string
    duration_minutes?: IntFilter<"interviews"> | number
    location?: StringFilter<"interviews"> | string
    meeting_url?: StringFilter<"interviews"> | string
    interview_name?: StringFilter<"interviews"> | string
    interview_position?: StringFilter<"interviews"> | string
    status?: EnuminterviewStatusFilter<"interviews"> | $Enums.interviewStatus
    feedback?: StringFilter<"interviews"> | string
    rating?: IntFilter<"interviews"> | number
    notes?: StringFilter<"interviews"> | string
    created_at?: DateTimeFilter<"interviews"> | Date | string
    updated_at?: DateTimeFilter<"interviews"> | Date | string
    interview?: XOR<ApplicationsScalarRelationFilter, applicationsWhereInput>
  }, "id">

  export type interviewsOrderByWithAggregationInput = {
    id?: SortOrder
    application_id?: SortOrder
    interview_type?: SortOrder
    scheduled_time?: SortOrder
    timezone?: SortOrder
    duration_minutes?: SortOrder
    location?: SortOrder
    meeting_url?: SortOrder
    interview_name?: SortOrder
    interview_position?: SortOrder
    status?: SortOrder
    feedback?: SortOrder
    rating?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: interviewsCountOrderByAggregateInput
    _avg?: interviewsAvgOrderByAggregateInput
    _max?: interviewsMaxOrderByAggregateInput
    _min?: interviewsMinOrderByAggregateInput
    _sum?: interviewsSumOrderByAggregateInput
  }

  export type interviewsScalarWhereWithAggregatesInput = {
    AND?: interviewsScalarWhereWithAggregatesInput | interviewsScalarWhereWithAggregatesInput[]
    OR?: interviewsScalarWhereWithAggregatesInput[]
    NOT?: interviewsScalarWhereWithAggregatesInput | interviewsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"interviews"> | number
    application_id?: IntWithAggregatesFilter<"interviews"> | number
    interview_type?: EnuminterviewTypeWithAggregatesFilter<"interviews"> | $Enums.interviewType
    scheduled_time?: DateTimeWithAggregatesFilter<"interviews"> | Date | string
    timezone?: StringWithAggregatesFilter<"interviews"> | string
    duration_minutes?: IntWithAggregatesFilter<"interviews"> | number
    location?: StringWithAggregatesFilter<"interviews"> | string
    meeting_url?: StringWithAggregatesFilter<"interviews"> | string
    interview_name?: StringWithAggregatesFilter<"interviews"> | string
    interview_position?: StringWithAggregatesFilter<"interviews"> | string
    status?: EnuminterviewStatusWithAggregatesFilter<"interviews"> | $Enums.interviewStatus
    feedback?: StringWithAggregatesFilter<"interviews"> | string
    rating?: IntWithAggregatesFilter<"interviews"> | number
    notes?: StringWithAggregatesFilter<"interviews"> | string
    created_at?: DateTimeWithAggregatesFilter<"interviews"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"interviews"> | Date | string
  }

  export type contactsWhereInput = {
    AND?: contactsWhereInput | contactsWhereInput[]
    OR?: contactsWhereInput[]
    NOT?: contactsWhereInput | contactsWhereInput[]
    id?: IntFilter<"contacts"> | number
    job_id?: IntFilter<"contacts"> | number
    user_id?: IntFilter<"contacts"> | number
    company_id?: IntFilter<"contacts"> | number
    contact_type?: EnumcontactTypeFilter<"contacts"> | $Enums.contactType
    start_date?: DateTimeFilter<"contacts"> | Date | string
    end_date?: DateTimeFilter<"contacts"> | Date | string
    probation_period_months?: IntFilter<"contacts"> | number
    salary_amount?: IntFilter<"contacts"> | number
    salary_currency?: StringFilter<"contacts"> | string
    salary_payment_period?: EnumcontactSalaryPaymentPeriodFilter<"contacts"> | $Enums.contactSalaryPaymentPeriod
    benefits_description?: StringFilter<"contacts"> | string
    visa_sponsorship_details?: StringFilter<"contacts"> | string
    relocation_assistance_details?: StringFilter<"contacts"> | string
    status?: EnumcontactStatusFilter<"contacts"> | $Enums.contactStatus
    signed_at?: DateTimeFilter<"contacts"> | Date | string
    created_at?: DateTimeFilter<"contacts"> | Date | string
    updated_at?: DateTimeFilter<"contacts"> | Date | string
    contact?: XOR<JobsScalarRelationFilter, jobsWhereInput>
    contacts?: XOR<UsersScalarRelationFilter, usersWhereInput>
    contac?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
  }

  export type contactsOrderByWithRelationInput = {
    id?: SortOrder
    job_id?: SortOrder
    user_id?: SortOrder
    company_id?: SortOrder
    contact_type?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    probation_period_months?: SortOrder
    salary_amount?: SortOrder
    salary_currency?: SortOrder
    salary_payment_period?: SortOrder
    benefits_description?: SortOrder
    visa_sponsorship_details?: SortOrder
    relocation_assistance_details?: SortOrder
    status?: SortOrder
    signed_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    contact?: jobsOrderByWithRelationInput
    contacts?: usersOrderByWithRelationInput
    contac?: companiesOrderByWithRelationInput
  }

  export type contactsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: contactsWhereInput | contactsWhereInput[]
    OR?: contactsWhereInput[]
    NOT?: contactsWhereInput | contactsWhereInput[]
    job_id?: IntFilter<"contacts"> | number
    user_id?: IntFilter<"contacts"> | number
    company_id?: IntFilter<"contacts"> | number
    contact_type?: EnumcontactTypeFilter<"contacts"> | $Enums.contactType
    start_date?: DateTimeFilter<"contacts"> | Date | string
    end_date?: DateTimeFilter<"contacts"> | Date | string
    probation_period_months?: IntFilter<"contacts"> | number
    salary_amount?: IntFilter<"contacts"> | number
    salary_currency?: StringFilter<"contacts"> | string
    salary_payment_period?: EnumcontactSalaryPaymentPeriodFilter<"contacts"> | $Enums.contactSalaryPaymentPeriod
    benefits_description?: StringFilter<"contacts"> | string
    visa_sponsorship_details?: StringFilter<"contacts"> | string
    relocation_assistance_details?: StringFilter<"contacts"> | string
    status?: EnumcontactStatusFilter<"contacts"> | $Enums.contactStatus
    signed_at?: DateTimeFilter<"contacts"> | Date | string
    created_at?: DateTimeFilter<"contacts"> | Date | string
    updated_at?: DateTimeFilter<"contacts"> | Date | string
    contact?: XOR<JobsScalarRelationFilter, jobsWhereInput>
    contacts?: XOR<UsersScalarRelationFilter, usersWhereInput>
    contac?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
  }, "id">

  export type contactsOrderByWithAggregationInput = {
    id?: SortOrder
    job_id?: SortOrder
    user_id?: SortOrder
    company_id?: SortOrder
    contact_type?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    probation_period_months?: SortOrder
    salary_amount?: SortOrder
    salary_currency?: SortOrder
    salary_payment_period?: SortOrder
    benefits_description?: SortOrder
    visa_sponsorship_details?: SortOrder
    relocation_assistance_details?: SortOrder
    status?: SortOrder
    signed_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: contactsCountOrderByAggregateInput
    _avg?: contactsAvgOrderByAggregateInput
    _max?: contactsMaxOrderByAggregateInput
    _min?: contactsMinOrderByAggregateInput
    _sum?: contactsSumOrderByAggregateInput
  }

  export type contactsScalarWhereWithAggregatesInput = {
    AND?: contactsScalarWhereWithAggregatesInput | contactsScalarWhereWithAggregatesInput[]
    OR?: contactsScalarWhereWithAggregatesInput[]
    NOT?: contactsScalarWhereWithAggregatesInput | contactsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"contacts"> | number
    job_id?: IntWithAggregatesFilter<"contacts"> | number
    user_id?: IntWithAggregatesFilter<"contacts"> | number
    company_id?: IntWithAggregatesFilter<"contacts"> | number
    contact_type?: EnumcontactTypeWithAggregatesFilter<"contacts"> | $Enums.contactType
    start_date?: DateTimeWithAggregatesFilter<"contacts"> | Date | string
    end_date?: DateTimeWithAggregatesFilter<"contacts"> | Date | string
    probation_period_months?: IntWithAggregatesFilter<"contacts"> | number
    salary_amount?: IntWithAggregatesFilter<"contacts"> | number
    salary_currency?: StringWithAggregatesFilter<"contacts"> | string
    salary_payment_period?: EnumcontactSalaryPaymentPeriodWithAggregatesFilter<"contacts"> | $Enums.contactSalaryPaymentPeriod
    benefits_description?: StringWithAggregatesFilter<"contacts"> | string
    visa_sponsorship_details?: StringWithAggregatesFilter<"contacts"> | string
    relocation_assistance_details?: StringWithAggregatesFilter<"contacts"> | string
    status?: EnumcontactStatusWithAggregatesFilter<"contacts"> | $Enums.contactStatus
    signed_at?: DateTimeWithAggregatesFilter<"contacts"> | Date | string
    created_at?: DateTimeWithAggregatesFilter<"contacts"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"contacts"> | Date | string
  }

  export type notificationsWhereInput = {
    AND?: notificationsWhereInput | notificationsWhereInput[]
    OR?: notificationsWhereInput[]
    NOT?: notificationsWhereInput | notificationsWhereInput[]
    id?: IntFilter<"notifications"> | number
    user_id?: IntFilter<"notifications"> | number
    notification_type?: StringFilter<"notifications"> | string
    title?: StringFilter<"notifications"> | string
    message?: StringFilter<"notifications"> | string
    is_read?: BoolFilter<"notifications"> | boolean
    related_entity_type?: StringFilter<"notifications"> | string
    related_entity_id?: IntFilter<"notifications"> | number
    created_at?: DateTimeFilter<"notifications"> | Date | string
    notification?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type notificationsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    notification_type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    is_read?: SortOrder
    related_entity_type?: SortOrder
    related_entity_id?: SortOrder
    created_at?: SortOrder
    notification?: usersOrderByWithRelationInput
  }

  export type notificationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: notificationsWhereInput | notificationsWhereInput[]
    OR?: notificationsWhereInput[]
    NOT?: notificationsWhereInput | notificationsWhereInput[]
    user_id?: IntFilter<"notifications"> | number
    notification_type?: StringFilter<"notifications"> | string
    title?: StringFilter<"notifications"> | string
    message?: StringFilter<"notifications"> | string
    is_read?: BoolFilter<"notifications"> | boolean
    related_entity_type?: StringFilter<"notifications"> | string
    related_entity_id?: IntFilter<"notifications"> | number
    created_at?: DateTimeFilter<"notifications"> | Date | string
    notification?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type notificationsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    notification_type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    is_read?: SortOrder
    related_entity_type?: SortOrder
    related_entity_id?: SortOrder
    created_at?: SortOrder
    _count?: notificationsCountOrderByAggregateInput
    _avg?: notificationsAvgOrderByAggregateInput
    _max?: notificationsMaxOrderByAggregateInput
    _min?: notificationsMinOrderByAggregateInput
    _sum?: notificationsSumOrderByAggregateInput
  }

  export type notificationsScalarWhereWithAggregatesInput = {
    AND?: notificationsScalarWhereWithAggregatesInput | notificationsScalarWhereWithAggregatesInput[]
    OR?: notificationsScalarWhereWithAggregatesInput[]
    NOT?: notificationsScalarWhereWithAggregatesInput | notificationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"notifications"> | number
    user_id?: IntWithAggregatesFilter<"notifications"> | number
    notification_type?: StringWithAggregatesFilter<"notifications"> | string
    title?: StringWithAggregatesFilter<"notifications"> | string
    message?: StringWithAggregatesFilter<"notifications"> | string
    is_read?: BoolWithAggregatesFilter<"notifications"> | boolean
    related_entity_type?: StringWithAggregatesFilter<"notifications"> | string
    related_entity_id?: IntWithAggregatesFilter<"notifications"> | number
    created_at?: DateTimeWithAggregatesFilter<"notifications"> | Date | string
  }

  export type saved_jobsWhereInput = {
    AND?: saved_jobsWhereInput | saved_jobsWhereInput[]
    OR?: saved_jobsWhereInput[]
    NOT?: saved_jobsWhereInput | saved_jobsWhereInput[]
    id?: IntFilter<"saved_jobs"> | number
    user_id?: IntFilter<"saved_jobs"> | number
    job_id?: IntFilter<"saved_jobs"> | number
    saved_at?: DateTimeFilter<"saved_jobs"> | Date | string
    notes?: StringFilter<"saved_jobs"> | string
    savedjob?: XOR<UsersScalarRelationFilter, usersWhereInput>
    savedjobs?: XOR<JobsScalarRelationFilter, jobsWhereInput>
  }

  export type saved_jobsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    job_id?: SortOrder
    saved_at?: SortOrder
    notes?: SortOrder
    savedjob?: usersOrderByWithRelationInput
    savedjobs?: jobsOrderByWithRelationInput
  }

  export type saved_jobsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: saved_jobsWhereInput | saved_jobsWhereInput[]
    OR?: saved_jobsWhereInput[]
    NOT?: saved_jobsWhereInput | saved_jobsWhereInput[]
    user_id?: IntFilter<"saved_jobs"> | number
    job_id?: IntFilter<"saved_jobs"> | number
    saved_at?: DateTimeFilter<"saved_jobs"> | Date | string
    notes?: StringFilter<"saved_jobs"> | string
    savedjob?: XOR<UsersScalarRelationFilter, usersWhereInput>
    savedjobs?: XOR<JobsScalarRelationFilter, jobsWhereInput>
  }, "id">

  export type saved_jobsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    job_id?: SortOrder
    saved_at?: SortOrder
    notes?: SortOrder
    _count?: saved_jobsCountOrderByAggregateInput
    _avg?: saved_jobsAvgOrderByAggregateInput
    _max?: saved_jobsMaxOrderByAggregateInput
    _min?: saved_jobsMinOrderByAggregateInput
    _sum?: saved_jobsSumOrderByAggregateInput
  }

  export type saved_jobsScalarWhereWithAggregatesInput = {
    AND?: saved_jobsScalarWhereWithAggregatesInput | saved_jobsScalarWhereWithAggregatesInput[]
    OR?: saved_jobsScalarWhereWithAggregatesInput[]
    NOT?: saved_jobsScalarWhereWithAggregatesInput | saved_jobsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"saved_jobs"> | number
    user_id?: IntWithAggregatesFilter<"saved_jobs"> | number
    job_id?: IntWithAggregatesFilter<"saved_jobs"> | number
    saved_at?: DateTimeWithAggregatesFilter<"saved_jobs"> | Date | string
    notes?: StringWithAggregatesFilter<"saved_jobs"> | string
  }

  export type job_searchesWhereInput = {
    AND?: job_searchesWhereInput | job_searchesWhereInput[]
    OR?: job_searchesWhereInput[]
    NOT?: job_searchesWhereInput | job_searchesWhereInput[]
    id?: IntFilter<"job_searches"> | number
    user_id?: IntFilter<"job_searches"> | number
    search_query?: StringFilter<"job_searches"> | string
    country?: StringFilter<"job_searches"> | string
    city?: StringFilter<"job_searches"> | string
    job_catregory?: StringFilter<"job_searches"> | string
    experience_level?: StringFilter<"job_searches"> | string
    job_type?: StringFilter<"job_searches"> | string
    created_at?: DateTimeFilter<"job_searches"> | Date | string
    searches?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type job_searchesOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    search_query?: SortOrder
    country?: SortOrder
    city?: SortOrder
    job_catregory?: SortOrder
    experience_level?: SortOrder
    job_type?: SortOrder
    created_at?: SortOrder
    searches?: usersOrderByWithRelationInput
  }

  export type job_searchesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: job_searchesWhereInput | job_searchesWhereInput[]
    OR?: job_searchesWhereInput[]
    NOT?: job_searchesWhereInput | job_searchesWhereInput[]
    user_id?: IntFilter<"job_searches"> | number
    search_query?: StringFilter<"job_searches"> | string
    country?: StringFilter<"job_searches"> | string
    city?: StringFilter<"job_searches"> | string
    job_catregory?: StringFilter<"job_searches"> | string
    experience_level?: StringFilter<"job_searches"> | string
    job_type?: StringFilter<"job_searches"> | string
    created_at?: DateTimeFilter<"job_searches"> | Date | string
    searches?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type job_searchesOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    search_query?: SortOrder
    country?: SortOrder
    city?: SortOrder
    job_catregory?: SortOrder
    experience_level?: SortOrder
    job_type?: SortOrder
    created_at?: SortOrder
    _count?: job_searchesCountOrderByAggregateInput
    _avg?: job_searchesAvgOrderByAggregateInput
    _max?: job_searchesMaxOrderByAggregateInput
    _min?: job_searchesMinOrderByAggregateInput
    _sum?: job_searchesSumOrderByAggregateInput
  }

  export type job_searchesScalarWhereWithAggregatesInput = {
    AND?: job_searchesScalarWhereWithAggregatesInput | job_searchesScalarWhereWithAggregatesInput[]
    OR?: job_searchesScalarWhereWithAggregatesInput[]
    NOT?: job_searchesScalarWhereWithAggregatesInput | job_searchesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"job_searches"> | number
    user_id?: IntWithAggregatesFilter<"job_searches"> | number
    search_query?: StringWithAggregatesFilter<"job_searches"> | string
    country?: StringWithAggregatesFilter<"job_searches"> | string
    city?: StringWithAggregatesFilter<"job_searches"> | string
    job_catregory?: StringWithAggregatesFilter<"job_searches"> | string
    experience_level?: StringWithAggregatesFilter<"job_searches"> | string
    job_type?: StringWithAggregatesFilter<"job_searches"> | string
    created_at?: DateTimeWithAggregatesFilter<"job_searches"> | Date | string
  }

  export type usersCreateInput = {
    first_name: string
    last_name: string
    email: string
    password_hash: string
    phone_number?: string | null
    country_code?: string | null
    date_of_birth?: Date | string | null
    gender?: string | null
    profile_picture_url?: string | null
    bio?: string | null
    created_at?: Date | string
    updated_at: Date | string
    last_login_at?: Date | string | null
    status?: $Enums.userstatus
    addresses?: user_addressesCreateNestedManyWithoutUserInput
    resumes?: resumesCreateNestedManyWithoutUserInput
    educations?: educationsCreateNestedManyWithoutUserInput
    experiences?: work_experiencesCreateNestedManyWithoutUserInput
    skills?: skillsCreateNestedManyWithoutUserInput
    languages?: languagesCreateNestedManyWithoutUserInput
    certifications?: certificationsCreateNestedManyWithoutUserInput
    visa?: visa_informationCreateNestedManyWithoutVisaInput
    application?: applicationsCreateNestedManyWithoutAplicationInput
    contacts?: contactsCreateNestedManyWithoutContactsInput
    notification?: notificationsCreateNestedManyWithoutNotificationInput
    savedjob?: saved_jobsCreateNestedManyWithoutSavedjobInput
    searches?: job_searchesCreateNestedManyWithoutSearchesInput
  }

  export type usersUncheckedCreateInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password_hash: string
    phone_number?: string | null
    country_code?: string | null
    date_of_birth?: Date | string | null
    gender?: string | null
    profile_picture_url?: string | null
    bio?: string | null
    created_at?: Date | string
    updated_at: Date | string
    last_login_at?: Date | string | null
    status?: $Enums.userstatus
    addresses?: user_addressesUncheckedCreateNestedManyWithoutUserInput
    resumes?: resumesUncheckedCreateNestedManyWithoutUserInput
    educations?: educationsUncheckedCreateNestedManyWithoutUserInput
    experiences?: work_experiencesUncheckedCreateNestedManyWithoutUserInput
    skills?: skillsUncheckedCreateNestedManyWithoutUserInput
    languages?: languagesUncheckedCreateNestedManyWithoutUserInput
    certifications?: certificationsUncheckedCreateNestedManyWithoutUserInput
    visa?: visa_informationUncheckedCreateNestedManyWithoutVisaInput
    application?: applicationsUncheckedCreateNestedManyWithoutAplicationInput
    contacts?: contactsUncheckedCreateNestedManyWithoutContactsInput
    notification?: notificationsUncheckedCreateNestedManyWithoutNotificationInput
    savedjob?: saved_jobsUncheckedCreateNestedManyWithoutSavedjobInput
    searches?: job_searchesUncheckedCreateNestedManyWithoutSearchesInput
  }

  export type usersUpdateInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumuserstatusFieldUpdateOperationsInput | $Enums.userstatus
    addresses?: user_addressesUpdateManyWithoutUserNestedInput
    resumes?: resumesUpdateManyWithoutUserNestedInput
    educations?: educationsUpdateManyWithoutUserNestedInput
    experiences?: work_experiencesUpdateManyWithoutUserNestedInput
    skills?: skillsUpdateManyWithoutUserNestedInput
    languages?: languagesUpdateManyWithoutUserNestedInput
    certifications?: certificationsUpdateManyWithoutUserNestedInput
    visa?: visa_informationUpdateManyWithoutVisaNestedInput
    application?: applicationsUpdateManyWithoutAplicationNestedInput
    contacts?: contactsUpdateManyWithoutContactsNestedInput
    notification?: notificationsUpdateManyWithoutNotificationNestedInput
    savedjob?: saved_jobsUpdateManyWithoutSavedjobNestedInput
    searches?: job_searchesUpdateManyWithoutSearchesNestedInput
  }

  export type usersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumuserstatusFieldUpdateOperationsInput | $Enums.userstatus
    addresses?: user_addressesUncheckedUpdateManyWithoutUserNestedInput
    resumes?: resumesUncheckedUpdateManyWithoutUserNestedInput
    educations?: educationsUncheckedUpdateManyWithoutUserNestedInput
    experiences?: work_experiencesUncheckedUpdateManyWithoutUserNestedInput
    skills?: skillsUncheckedUpdateManyWithoutUserNestedInput
    languages?: languagesUncheckedUpdateManyWithoutUserNestedInput
    certifications?: certificationsUncheckedUpdateManyWithoutUserNestedInput
    visa?: visa_informationUncheckedUpdateManyWithoutVisaNestedInput
    application?: applicationsUncheckedUpdateManyWithoutAplicationNestedInput
    contacts?: contactsUncheckedUpdateManyWithoutContactsNestedInput
    notification?: notificationsUncheckedUpdateManyWithoutNotificationNestedInput
    savedjob?: saved_jobsUncheckedUpdateManyWithoutSavedjobNestedInput
    searches?: job_searchesUncheckedUpdateManyWithoutSearchesNestedInput
  }

  export type usersCreateManyInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password_hash: string
    phone_number?: string | null
    country_code?: string | null
    date_of_birth?: Date | string | null
    gender?: string | null
    profile_picture_url?: string | null
    bio?: string | null
    created_at?: Date | string
    updated_at: Date | string
    last_login_at?: Date | string | null
    status?: $Enums.userstatus
  }

  export type usersUpdateManyMutationInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumuserstatusFieldUpdateOperationsInput | $Enums.userstatus
  }

  export type usersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumuserstatusFieldUpdateOperationsInput | $Enums.userstatus
  }

  export type user_addressesCreateInput = {
    adress_line1: string
    adress_line2?: string | null
    city: string
    state?: string | null
    postal_code?: string | null
    country: string
    is_primary?: boolean | null
    created_at?: Date | string | null
    user: usersCreateNestedOneWithoutAddressesInput
  }

  export type user_addressesUncheckedCreateInput = {
    id?: number
    user_id: number
    adress_line1: string
    adress_line2?: string | null
    city: string
    state?: string | null
    postal_code?: string | null
    country: string
    is_primary?: boolean | null
    created_at?: Date | string | null
  }

  export type user_addressesUpdateInput = {
    adress_line1?: StringFieldUpdateOperationsInput | string
    adress_line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    is_primary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: usersUpdateOneRequiredWithoutAddressesNestedInput
  }

  export type user_addressesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    adress_line1?: StringFieldUpdateOperationsInput | string
    adress_line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    is_primary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_addressesCreateManyInput = {
    id?: number
    user_id: number
    adress_line1: string
    adress_line2?: string | null
    city: string
    state?: string | null
    postal_code?: string | null
    country: string
    is_primary?: boolean | null
    created_at?: Date | string | null
  }

  export type user_addressesUpdateManyMutationInput = {
    adress_line1?: StringFieldUpdateOperationsInput | string
    adress_line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    is_primary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_addressesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    adress_line1?: StringFieldUpdateOperationsInput | string
    adress_line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    is_primary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type resumesCreateInput = {
    title: string
    file_url: string
    is_default?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    applications?: applicationsCreateNestedManyWithoutApplicationsInput
    user: usersCreateNestedOneWithoutResumesInput
  }

  export type resumesUncheckedCreateInput = {
    id?: number
    user_id: number
    title: string
    file_url: string
    is_default?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    applications?: applicationsUncheckedCreateNestedManyWithoutApplicationsInput
  }

  export type resumesUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    file_url?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: applicationsUpdateManyWithoutApplicationsNestedInput
    user?: usersUpdateOneRequiredWithoutResumesNestedInput
  }

  export type resumesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    file_url?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: applicationsUncheckedUpdateManyWithoutApplicationsNestedInput
  }

  export type resumesCreateManyInput = {
    id?: number
    user_id: number
    title: string
    file_url: string
    is_default?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type resumesUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    file_url?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type resumesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    file_url?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type educationsCreateInput = {
    institution: string
    degree: string
    field_of_study: string
    start_date: Date | string
    end_date: Date | string
    grade: string
    description: string
    is_foreign_education?: boolean
    country: string
    user: usersCreateNestedOneWithoutEducationsInput
  }

  export type educationsUncheckedCreateInput = {
    id?: number
    user_id: number
    institution: string
    degree: string
    field_of_study: string
    start_date: Date | string
    end_date: Date | string
    grade: string
    description: string
    is_foreign_education?: boolean
    country: string
  }

  export type educationsUpdateInput = {
    institution?: StringFieldUpdateOperationsInput | string
    degree?: StringFieldUpdateOperationsInput | string
    field_of_study?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    grade?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    is_foreign_education?: BoolFieldUpdateOperationsInput | boolean
    country?: StringFieldUpdateOperationsInput | string
    user?: usersUpdateOneRequiredWithoutEducationsNestedInput
  }

  export type educationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    institution?: StringFieldUpdateOperationsInput | string
    degree?: StringFieldUpdateOperationsInput | string
    field_of_study?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    grade?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    is_foreign_education?: BoolFieldUpdateOperationsInput | boolean
    country?: StringFieldUpdateOperationsInput | string
  }

  export type educationsCreateManyInput = {
    id?: number
    user_id: number
    institution: string
    degree: string
    field_of_study: string
    start_date: Date | string
    end_date: Date | string
    grade: string
    description: string
    is_foreign_education?: boolean
    country: string
  }

  export type educationsUpdateManyMutationInput = {
    institution?: StringFieldUpdateOperationsInput | string
    degree?: StringFieldUpdateOperationsInput | string
    field_of_study?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    grade?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    is_foreign_education?: BoolFieldUpdateOperationsInput | boolean
    country?: StringFieldUpdateOperationsInput | string
  }

  export type educationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    institution?: StringFieldUpdateOperationsInput | string
    degree?: StringFieldUpdateOperationsInput | string
    field_of_study?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    grade?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    is_foreign_education?: BoolFieldUpdateOperationsInput | boolean
    country?: StringFieldUpdateOperationsInput | string
  }

  export type work_experiencesCreateInput = {
    company_name: string
    position: string
    location: string
    country: string
    start_date: Date | string
    end_date: Date | string
    is_current_job?: boolean
    description: string
    is_foregin_experience?: boolean
    user: usersCreateNestedOneWithoutExperiencesInput
  }

  export type work_experiencesUncheckedCreateInput = {
    id?: number
    user_id: number
    company_name: string
    position: string
    location: string
    country: string
    start_date: Date | string
    end_date: Date | string
    is_current_job?: boolean
    description: string
    is_foregin_experience?: boolean
  }

  export type work_experiencesUpdateInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_current_job?: BoolFieldUpdateOperationsInput | boolean
    description?: StringFieldUpdateOperationsInput | string
    is_foregin_experience?: BoolFieldUpdateOperationsInput | boolean
    user?: usersUpdateOneRequiredWithoutExperiencesNestedInput
  }

  export type work_experiencesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_current_job?: BoolFieldUpdateOperationsInput | boolean
    description?: StringFieldUpdateOperationsInput | string
    is_foregin_experience?: BoolFieldUpdateOperationsInput | boolean
  }

  export type work_experiencesCreateManyInput = {
    id?: number
    user_id: number
    company_name: string
    position: string
    location: string
    country: string
    start_date: Date | string
    end_date: Date | string
    is_current_job?: boolean
    description: string
    is_foregin_experience?: boolean
  }

  export type work_experiencesUpdateManyMutationInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_current_job?: BoolFieldUpdateOperationsInput | boolean
    description?: StringFieldUpdateOperationsInput | string
    is_foregin_experience?: BoolFieldUpdateOperationsInput | boolean
  }

  export type work_experiencesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_current_job?: BoolFieldUpdateOperationsInput | boolean
    description?: StringFieldUpdateOperationsInput | string
    is_foregin_experience?: BoolFieldUpdateOperationsInput | boolean
  }

  export type skillsCreateInput = {
    skill_name: string
    proficiency?: $Enums.skillsstatus
    year_of_experience: number
    is_certifield?: boolean
    user: usersCreateNestedOneWithoutSkillsInput
  }

  export type skillsUncheckedCreateInput = {
    id?: number
    user_id: number
    skill_name: string
    proficiency?: $Enums.skillsstatus
    year_of_experience: number
    is_certifield?: boolean
  }

  export type skillsUpdateInput = {
    skill_name?: StringFieldUpdateOperationsInput | string
    proficiency?: EnumskillsstatusFieldUpdateOperationsInput | $Enums.skillsstatus
    year_of_experience?: IntFieldUpdateOperationsInput | number
    is_certifield?: BoolFieldUpdateOperationsInput | boolean
    user?: usersUpdateOneRequiredWithoutSkillsNestedInput
  }

  export type skillsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    skill_name?: StringFieldUpdateOperationsInput | string
    proficiency?: EnumskillsstatusFieldUpdateOperationsInput | $Enums.skillsstatus
    year_of_experience?: IntFieldUpdateOperationsInput | number
    is_certifield?: BoolFieldUpdateOperationsInput | boolean
  }

  export type skillsCreateManyInput = {
    id?: number
    user_id: number
    skill_name: string
    proficiency?: $Enums.skillsstatus
    year_of_experience: number
    is_certifield?: boolean
  }

  export type skillsUpdateManyMutationInput = {
    skill_name?: StringFieldUpdateOperationsInput | string
    proficiency?: EnumskillsstatusFieldUpdateOperationsInput | $Enums.skillsstatus
    year_of_experience?: IntFieldUpdateOperationsInput | number
    is_certifield?: BoolFieldUpdateOperationsInput | boolean
  }

  export type skillsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    skill_name?: StringFieldUpdateOperationsInput | string
    proficiency?: EnumskillsstatusFieldUpdateOperationsInput | $Enums.skillsstatus
    year_of_experience?: IntFieldUpdateOperationsInput | number
    is_certifield?: BoolFieldUpdateOperationsInput | boolean
  }

  export type languagesCreateInput = {
    languages: string
    proficiency: $Enums.proficiencylanguages
    is_primary?: boolean
    user: usersCreateNestedOneWithoutLanguagesInput
  }

  export type languagesUncheckedCreateInput = {
    id?: number
    user_id: number
    languages: string
    proficiency: $Enums.proficiencylanguages
    is_primary?: boolean
  }

  export type languagesUpdateInput = {
    languages?: StringFieldUpdateOperationsInput | string
    proficiency?: EnumproficiencylanguagesFieldUpdateOperationsInput | $Enums.proficiencylanguages
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    user?: usersUpdateOneRequiredWithoutLanguagesNestedInput
  }

  export type languagesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    languages?: StringFieldUpdateOperationsInput | string
    proficiency?: EnumproficiencylanguagesFieldUpdateOperationsInput | $Enums.proficiencylanguages
    is_primary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type languagesCreateManyInput = {
    id?: number
    user_id: number
    languages: string
    proficiency: $Enums.proficiencylanguages
    is_primary?: boolean
  }

  export type languagesUpdateManyMutationInput = {
    languages?: StringFieldUpdateOperationsInput | string
    proficiency?: EnumproficiencylanguagesFieldUpdateOperationsInput | $Enums.proficiencylanguages
    is_primary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type languagesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    languages?: StringFieldUpdateOperationsInput | string
    proficiency?: EnumproficiencylanguagesFieldUpdateOperationsInput | $Enums.proficiencylanguages
    is_primary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type certificationsCreateInput = {
    name: string
    issuing_organization: string
    issue_date: Date | string
    expiration_date: Date | string
    credential_id: string
    credential_url: string
    is_foreign_certification?: boolean
    user: usersCreateNestedOneWithoutCertificationsInput
  }

  export type certificationsUncheckedCreateInput = {
    id?: number
    user_id: number
    name: string
    issuing_organization: string
    issue_date: Date | string
    expiration_date: Date | string
    credential_id: string
    credential_url: string
    is_foreign_certification?: boolean
  }

  export type certificationsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    issuing_organization?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expiration_date?: DateTimeFieldUpdateOperationsInput | Date | string
    credential_id?: StringFieldUpdateOperationsInput | string
    credential_url?: StringFieldUpdateOperationsInput | string
    is_foreign_certification?: BoolFieldUpdateOperationsInput | boolean
    user?: usersUpdateOneRequiredWithoutCertificationsNestedInput
  }

  export type certificationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    issuing_organization?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expiration_date?: DateTimeFieldUpdateOperationsInput | Date | string
    credential_id?: StringFieldUpdateOperationsInput | string
    credential_url?: StringFieldUpdateOperationsInput | string
    is_foreign_certification?: BoolFieldUpdateOperationsInput | boolean
  }

  export type certificationsCreateManyInput = {
    id?: number
    user_id: number
    name: string
    issuing_organization: string
    issue_date: Date | string
    expiration_date: Date | string
    credential_id: string
    credential_url: string
    is_foreign_certification?: boolean
  }

  export type certificationsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    issuing_organization?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expiration_date?: DateTimeFieldUpdateOperationsInput | Date | string
    credential_id?: StringFieldUpdateOperationsInput | string
    credential_url?: StringFieldUpdateOperationsInput | string
    is_foreign_certification?: BoolFieldUpdateOperationsInput | boolean
  }

  export type certificationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    issuing_organization?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expiration_date?: DateTimeFieldUpdateOperationsInput | Date | string
    credential_id?: StringFieldUpdateOperationsInput | string
    credential_url?: StringFieldUpdateOperationsInput | string
    is_foreign_certification?: BoolFieldUpdateOperationsInput | boolean
  }

  export type visa_informationCreateInput = {
    visa_type: string
    country: string
    status: string
    expiry__date: Date | string
    is_multiple_entry?: boolean
    notes: string
    visa: usersCreateNestedOneWithoutVisaInput
  }

  export type visa_informationUncheckedCreateInput = {
    id?: number
    user_id: number
    visa_type: string
    country: string
    status: string
    expiry__date: Date | string
    is_multiple_entry?: boolean
    notes: string
  }

  export type visa_informationUpdateInput = {
    visa_type?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    expiry__date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_multiple_entry?: BoolFieldUpdateOperationsInput | boolean
    notes?: StringFieldUpdateOperationsInput | string
    visa?: usersUpdateOneRequiredWithoutVisaNestedInput
  }

  export type visa_informationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    visa_type?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    expiry__date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_multiple_entry?: BoolFieldUpdateOperationsInput | boolean
    notes?: StringFieldUpdateOperationsInput | string
  }

  export type visa_informationCreateManyInput = {
    id?: number
    user_id: number
    visa_type: string
    country: string
    status: string
    expiry__date: Date | string
    is_multiple_entry?: boolean
    notes: string
  }

  export type visa_informationUpdateManyMutationInput = {
    visa_type?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    expiry__date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_multiple_entry?: BoolFieldUpdateOperationsInput | boolean
    notes?: StringFieldUpdateOperationsInput | string
  }

  export type visa_informationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    visa_type?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    expiry__date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_multiple_entry?: BoolFieldUpdateOperationsInput | boolean
    notes?: StringFieldUpdateOperationsInput | string
  }

  export type companiesCreateInput = {
    name: string
    description: string
    industry: string
    founded_year: number
    website_url: string
    logo_url: string
    headquarters_country: string
    company_siz?: $Enums.companySize
    is_verified?: boolean
    created_at?: Date | string
    companies?: company_locationsCreateNestedManyWithoutCompaniesInput
    job?: jobsCreateNestedManyWithoutJobInput
    contacts?: contactsCreateNestedManyWithoutContacInput
  }

  export type companiesUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    industry: string
    founded_year: number
    website_url: string
    logo_url: string
    headquarters_country: string
    company_siz?: $Enums.companySize
    is_verified?: boolean
    created_at?: Date | string
    companies?: company_locationsUncheckedCreateNestedManyWithoutCompaniesInput
    job?: jobsUncheckedCreateNestedManyWithoutJobInput
    contacts?: contactsUncheckedCreateNestedManyWithoutContacInput
  }

  export type companiesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    founded_year?: IntFieldUpdateOperationsInput | number
    website_url?: StringFieldUpdateOperationsInput | string
    logo_url?: StringFieldUpdateOperationsInput | string
    headquarters_country?: StringFieldUpdateOperationsInput | string
    company_siz?: EnumcompanySizeFieldUpdateOperationsInput | $Enums.companySize
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: company_locationsUpdateManyWithoutCompaniesNestedInput
    job?: jobsUpdateManyWithoutJobNestedInput
    contacts?: contactsUpdateManyWithoutContacNestedInput
  }

  export type companiesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    founded_year?: IntFieldUpdateOperationsInput | number
    website_url?: StringFieldUpdateOperationsInput | string
    logo_url?: StringFieldUpdateOperationsInput | string
    headquarters_country?: StringFieldUpdateOperationsInput | string
    company_siz?: EnumcompanySizeFieldUpdateOperationsInput | $Enums.companySize
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: company_locationsUncheckedUpdateManyWithoutCompaniesNestedInput
    job?: jobsUncheckedUpdateManyWithoutJobNestedInput
    contacts?: contactsUncheckedUpdateManyWithoutContacNestedInput
  }

  export type companiesCreateManyInput = {
    id?: number
    name: string
    description: string
    industry: string
    founded_year: number
    website_url: string
    logo_url: string
    headquarters_country: string
    company_siz?: $Enums.companySize
    is_verified?: boolean
    created_at?: Date | string
  }

  export type companiesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    founded_year?: IntFieldUpdateOperationsInput | number
    website_url?: StringFieldUpdateOperationsInput | string
    logo_url?: StringFieldUpdateOperationsInput | string
    headquarters_country?: StringFieldUpdateOperationsInput | string
    company_siz?: EnumcompanySizeFieldUpdateOperationsInput | $Enums.companySize
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type companiesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    founded_year?: IntFieldUpdateOperationsInput | number
    website_url?: StringFieldUpdateOperationsInput | string
    logo_url?: StringFieldUpdateOperationsInput | string
    headquarters_country?: StringFieldUpdateOperationsInput | string
    company_siz?: EnumcompanySizeFieldUpdateOperationsInput | $Enums.companySize
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type company_locationsCreateInput = {
    country: string
    city: string
    address: string
    is_headquarters?: boolean
    phone_number: string
    companies: companiesCreateNestedOneWithoutCompaniesInput
  }

  export type company_locationsUncheckedCreateInput = {
    id?: number
    company_id: number
    country: string
    city: string
    address: string
    is_headquarters?: boolean
    phone_number: string
  }

  export type company_locationsUpdateInput = {
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    is_headquarters?: BoolFieldUpdateOperationsInput | boolean
    phone_number?: StringFieldUpdateOperationsInput | string
    companies?: companiesUpdateOneRequiredWithoutCompaniesNestedInput
  }

  export type company_locationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    is_headquarters?: BoolFieldUpdateOperationsInput | boolean
    phone_number?: StringFieldUpdateOperationsInput | string
  }

  export type company_locationsCreateManyInput = {
    id?: number
    company_id: number
    country: string
    city: string
    address: string
    is_headquarters?: boolean
    phone_number: string
  }

  export type company_locationsUpdateManyMutationInput = {
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    is_headquarters?: BoolFieldUpdateOperationsInput | boolean
    phone_number?: StringFieldUpdateOperationsInput | string
  }

  export type company_locationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    is_headquarters?: BoolFieldUpdateOperationsInput | boolean
    phone_number?: StringFieldUpdateOperationsInput | string
  }

  export type jobsCreateInput = {
    title: string
    description: string
    job_category: string
    job_type: $Enums.jobType
    location_country: string
    location_city: string
    is_relocation_assistance?: boolean
    is_remote_possible?: boolean
    salary_currency: string
    salary_min: number
    salary_max: number
    salary_period?: $Enums.salaryPeriod
    visa_sponsorship?: $Enums.visaSponsorship
    experience_level?: $Enums.expLevel
    education_requirement: string
    posted_by: number
    status: $Enums.jobStatus
    posted_at?: Date | string
    deadline: Date | string
    views_count?: number
    job: companiesCreateNestedOneWithoutJobInput
    requirements?: job_requirementsCreateNestedManyWithoutRequirementsInput
    responsibilites?: job_responsibilitesCreateNestedManyWithoutResponsibilitesInput
    benefits?: job_benefitsCreateNestedManyWithoutBenefitsInput
    application?: applicationsCreateNestedManyWithoutApplicationInput
    contact?: contactsCreateNestedManyWithoutContactInput
    savedjob?: saved_jobsCreateNestedManyWithoutSavedjobsInput
  }

  export type jobsUncheckedCreateInput = {
    id?: number
    company_id: number
    title: string
    description: string
    job_category: string
    job_type: $Enums.jobType
    location_country: string
    location_city: string
    is_relocation_assistance?: boolean
    is_remote_possible?: boolean
    salary_currency: string
    salary_min: number
    salary_max: number
    salary_period?: $Enums.salaryPeriod
    visa_sponsorship?: $Enums.visaSponsorship
    experience_level?: $Enums.expLevel
    education_requirement: string
    posted_by: number
    status: $Enums.jobStatus
    posted_at?: Date | string
    deadline: Date | string
    views_count?: number
    requirements?: job_requirementsUncheckedCreateNestedManyWithoutRequirementsInput
    responsibilites?: job_responsibilitesUncheckedCreateNestedManyWithoutResponsibilitesInput
    benefits?: job_benefitsUncheckedCreateNestedManyWithoutBenefitsInput
    application?: applicationsUncheckedCreateNestedManyWithoutApplicationInput
    contact?: contactsUncheckedCreateNestedManyWithoutContactInput
    savedjob?: saved_jobsUncheckedCreateNestedManyWithoutSavedjobsInput
  }

  export type jobsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    job_category?: StringFieldUpdateOperationsInput | string
    job_type?: EnumjobTypeFieldUpdateOperationsInput | $Enums.jobType
    location_country?: StringFieldUpdateOperationsInput | string
    location_city?: StringFieldUpdateOperationsInput | string
    is_relocation_assistance?: BoolFieldUpdateOperationsInput | boolean
    is_remote_possible?: BoolFieldUpdateOperationsInput | boolean
    salary_currency?: StringFieldUpdateOperationsInput | string
    salary_min?: IntFieldUpdateOperationsInput | number
    salary_max?: IntFieldUpdateOperationsInput | number
    salary_period?: EnumsalaryPeriodFieldUpdateOperationsInput | $Enums.salaryPeriod
    visa_sponsorship?: EnumvisaSponsorshipFieldUpdateOperationsInput | $Enums.visaSponsorship
    experience_level?: EnumexpLevelFieldUpdateOperationsInput | $Enums.expLevel
    education_requirement?: StringFieldUpdateOperationsInput | string
    posted_by?: IntFieldUpdateOperationsInput | number
    status?: EnumjobStatusFieldUpdateOperationsInput | $Enums.jobStatus
    posted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    views_count?: IntFieldUpdateOperationsInput | number
    job?: companiesUpdateOneRequiredWithoutJobNestedInput
    requirements?: job_requirementsUpdateManyWithoutRequirementsNestedInput
    responsibilites?: job_responsibilitesUpdateManyWithoutResponsibilitesNestedInput
    benefits?: job_benefitsUpdateManyWithoutBenefitsNestedInput
    application?: applicationsUpdateManyWithoutApplicationNestedInput
    contact?: contactsUpdateManyWithoutContactNestedInput
    savedjob?: saved_jobsUpdateManyWithoutSavedjobsNestedInput
  }

  export type jobsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    job_category?: StringFieldUpdateOperationsInput | string
    job_type?: EnumjobTypeFieldUpdateOperationsInput | $Enums.jobType
    location_country?: StringFieldUpdateOperationsInput | string
    location_city?: StringFieldUpdateOperationsInput | string
    is_relocation_assistance?: BoolFieldUpdateOperationsInput | boolean
    is_remote_possible?: BoolFieldUpdateOperationsInput | boolean
    salary_currency?: StringFieldUpdateOperationsInput | string
    salary_min?: IntFieldUpdateOperationsInput | number
    salary_max?: IntFieldUpdateOperationsInput | number
    salary_period?: EnumsalaryPeriodFieldUpdateOperationsInput | $Enums.salaryPeriod
    visa_sponsorship?: EnumvisaSponsorshipFieldUpdateOperationsInput | $Enums.visaSponsorship
    experience_level?: EnumexpLevelFieldUpdateOperationsInput | $Enums.expLevel
    education_requirement?: StringFieldUpdateOperationsInput | string
    posted_by?: IntFieldUpdateOperationsInput | number
    status?: EnumjobStatusFieldUpdateOperationsInput | $Enums.jobStatus
    posted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    views_count?: IntFieldUpdateOperationsInput | number
    requirements?: job_requirementsUncheckedUpdateManyWithoutRequirementsNestedInput
    responsibilites?: job_responsibilitesUncheckedUpdateManyWithoutResponsibilitesNestedInput
    benefits?: job_benefitsUncheckedUpdateManyWithoutBenefitsNestedInput
    application?: applicationsUncheckedUpdateManyWithoutApplicationNestedInput
    contact?: contactsUncheckedUpdateManyWithoutContactNestedInput
    savedjob?: saved_jobsUncheckedUpdateManyWithoutSavedjobsNestedInput
  }

  export type jobsCreateManyInput = {
    id?: number
    company_id: number
    title: string
    description: string
    job_category: string
    job_type: $Enums.jobType
    location_country: string
    location_city: string
    is_relocation_assistance?: boolean
    is_remote_possible?: boolean
    salary_currency: string
    salary_min: number
    salary_max: number
    salary_period?: $Enums.salaryPeriod
    visa_sponsorship?: $Enums.visaSponsorship
    experience_level?: $Enums.expLevel
    education_requirement: string
    posted_by: number
    status: $Enums.jobStatus
    posted_at?: Date | string
    deadline: Date | string
    views_count?: number
  }

  export type jobsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    job_category?: StringFieldUpdateOperationsInput | string
    job_type?: EnumjobTypeFieldUpdateOperationsInput | $Enums.jobType
    location_country?: StringFieldUpdateOperationsInput | string
    location_city?: StringFieldUpdateOperationsInput | string
    is_relocation_assistance?: BoolFieldUpdateOperationsInput | boolean
    is_remote_possible?: BoolFieldUpdateOperationsInput | boolean
    salary_currency?: StringFieldUpdateOperationsInput | string
    salary_min?: IntFieldUpdateOperationsInput | number
    salary_max?: IntFieldUpdateOperationsInput | number
    salary_period?: EnumsalaryPeriodFieldUpdateOperationsInput | $Enums.salaryPeriod
    visa_sponsorship?: EnumvisaSponsorshipFieldUpdateOperationsInput | $Enums.visaSponsorship
    experience_level?: EnumexpLevelFieldUpdateOperationsInput | $Enums.expLevel
    education_requirement?: StringFieldUpdateOperationsInput | string
    posted_by?: IntFieldUpdateOperationsInput | number
    status?: EnumjobStatusFieldUpdateOperationsInput | $Enums.jobStatus
    posted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    views_count?: IntFieldUpdateOperationsInput | number
  }

  export type jobsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    job_category?: StringFieldUpdateOperationsInput | string
    job_type?: EnumjobTypeFieldUpdateOperationsInput | $Enums.jobType
    location_country?: StringFieldUpdateOperationsInput | string
    location_city?: StringFieldUpdateOperationsInput | string
    is_relocation_assistance?: BoolFieldUpdateOperationsInput | boolean
    is_remote_possible?: BoolFieldUpdateOperationsInput | boolean
    salary_currency?: StringFieldUpdateOperationsInput | string
    salary_min?: IntFieldUpdateOperationsInput | number
    salary_max?: IntFieldUpdateOperationsInput | number
    salary_period?: EnumsalaryPeriodFieldUpdateOperationsInput | $Enums.salaryPeriod
    visa_sponsorship?: EnumvisaSponsorshipFieldUpdateOperationsInput | $Enums.visaSponsorship
    experience_level?: EnumexpLevelFieldUpdateOperationsInput | $Enums.expLevel
    education_requirement?: StringFieldUpdateOperationsInput | string
    posted_by?: IntFieldUpdateOperationsInput | number
    status?: EnumjobStatusFieldUpdateOperationsInput | $Enums.jobStatus
    posted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    views_count?: IntFieldUpdateOperationsInput | number
  }

  export type job_requirementsCreateInput = {
    requirement_type: $Enums.jobRequirements
    requirement_text: string
    is_mandatory?: boolean
    priority?: number
    requirements: jobsCreateNestedOneWithoutRequirementsInput
  }

  export type job_requirementsUncheckedCreateInput = {
    id?: number
    job_id: number
    requirement_type: $Enums.jobRequirements
    requirement_text: string
    is_mandatory?: boolean
    priority?: number
  }

  export type job_requirementsUpdateInput = {
    requirement_type?: EnumjobRequirementsFieldUpdateOperationsInput | $Enums.jobRequirements
    requirement_text?: StringFieldUpdateOperationsInput | string
    is_mandatory?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    requirements?: jobsUpdateOneRequiredWithoutRequirementsNestedInput
  }

  export type job_requirementsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    job_id?: IntFieldUpdateOperationsInput | number
    requirement_type?: EnumjobRequirementsFieldUpdateOperationsInput | $Enums.jobRequirements
    requirement_text?: StringFieldUpdateOperationsInput | string
    is_mandatory?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type job_requirementsCreateManyInput = {
    id?: number
    job_id: number
    requirement_type: $Enums.jobRequirements
    requirement_text: string
    is_mandatory?: boolean
    priority?: number
  }

  export type job_requirementsUpdateManyMutationInput = {
    requirement_type?: EnumjobRequirementsFieldUpdateOperationsInput | $Enums.jobRequirements
    requirement_text?: StringFieldUpdateOperationsInput | string
    is_mandatory?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type job_requirementsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    job_id?: IntFieldUpdateOperationsInput | number
    requirement_type?: EnumjobRequirementsFieldUpdateOperationsInput | $Enums.jobRequirements
    requirement_text?: StringFieldUpdateOperationsInput | string
    is_mandatory?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type job_responsibilitesCreateInput = {
    responsibility_text: string
    priority?: number
    responsibilites: jobsCreateNestedOneWithoutResponsibilitesInput
  }

  export type job_responsibilitesUncheckedCreateInput = {
    id?: number
    job_id: number
    responsibility_text: string
    priority?: number
  }

  export type job_responsibilitesUpdateInput = {
    responsibility_text?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    responsibilites?: jobsUpdateOneRequiredWithoutResponsibilitesNestedInput
  }

  export type job_responsibilitesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    job_id?: IntFieldUpdateOperationsInput | number
    responsibility_text?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type job_responsibilitesCreateManyInput = {
    id?: number
    job_id: number
    responsibility_text: string
    priority?: number
  }

  export type job_responsibilitesUpdateManyMutationInput = {
    responsibility_text?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type job_responsibilitesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    job_id?: IntFieldUpdateOperationsInput | number
    responsibility_text?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type job_benefitsCreateInput = {
    benefit_type: $Enums.jobBenefit
    description: string
    benefits: jobsCreateNestedOneWithoutBenefitsInput
  }

  export type job_benefitsUncheckedCreateInput = {
    id?: number
    job_id: number
    benefit_type: $Enums.jobBenefit
    description: string
  }

  export type job_benefitsUpdateInput = {
    benefit_type?: EnumjobBenefitFieldUpdateOperationsInput | $Enums.jobBenefit
    description?: StringFieldUpdateOperationsInput | string
    benefits?: jobsUpdateOneRequiredWithoutBenefitsNestedInput
  }

  export type job_benefitsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    job_id?: IntFieldUpdateOperationsInput | number
    benefit_type?: EnumjobBenefitFieldUpdateOperationsInput | $Enums.jobBenefit
    description?: StringFieldUpdateOperationsInput | string
  }

  export type job_benefitsCreateManyInput = {
    id?: number
    job_id: number
    benefit_type: $Enums.jobBenefit
    description: string
  }

  export type job_benefitsUpdateManyMutationInput = {
    benefit_type?: EnumjobBenefitFieldUpdateOperationsInput | $Enums.jobBenefit
    description?: StringFieldUpdateOperationsInput | string
  }

  export type job_benefitsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    job_id?: IntFieldUpdateOperationsInput | number
    benefit_type?: EnumjobBenefitFieldUpdateOperationsInput | $Enums.jobBenefit
    description?: StringFieldUpdateOperationsInput | string
  }

  export type applicationsCreateInput = {
    cover_letter: string
    status: $Enums.applicationStatus
    applited_at?: Date | string
    updated_at?: Date | string
    notes: string
    application: jobsCreateNestedOneWithoutApplicationInput
    aplication: usersCreateNestedOneWithoutApplicationInput
    applications: resumesCreateNestedOneWithoutApplicationsInput
    document?: application_documentsCreateNestedManyWithoutDocumentInput
    interview?: interviewsCreateNestedManyWithoutInterviewInput
  }

  export type applicationsUncheckedCreateInput = {
    id?: number
    job_id: number
    user_id: number
    resume_id: number
    cover_letter: string
    status: $Enums.applicationStatus
    applited_at?: Date | string
    updated_at?: Date | string
    notes: string
    document?: application_documentsUncheckedCreateNestedManyWithoutDocumentInput
    interview?: interviewsUncheckedCreateNestedManyWithoutInterviewInput
  }

  export type applicationsUpdateInput = {
    cover_letter?: StringFieldUpdateOperationsInput | string
    status?: EnumapplicationStatusFieldUpdateOperationsInput | $Enums.applicationStatus
    applited_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    application?: jobsUpdateOneRequiredWithoutApplicationNestedInput
    aplication?: usersUpdateOneRequiredWithoutApplicationNestedInput
    applications?: resumesUpdateOneRequiredWithoutApplicationsNestedInput
    document?: application_documentsUpdateManyWithoutDocumentNestedInput
    interview?: interviewsUpdateManyWithoutInterviewNestedInput
  }

  export type applicationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    job_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    resume_id?: IntFieldUpdateOperationsInput | number
    cover_letter?: StringFieldUpdateOperationsInput | string
    status?: EnumapplicationStatusFieldUpdateOperationsInput | $Enums.applicationStatus
    applited_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    document?: application_documentsUncheckedUpdateManyWithoutDocumentNestedInput
    interview?: interviewsUncheckedUpdateManyWithoutInterviewNestedInput
  }

  export type applicationsCreateManyInput = {
    id?: number
    job_id: number
    user_id: number
    resume_id: number
    cover_letter: string
    status: $Enums.applicationStatus
    applited_at?: Date | string
    updated_at?: Date | string
    notes: string
  }

  export type applicationsUpdateManyMutationInput = {
    cover_letter?: StringFieldUpdateOperationsInput | string
    status?: EnumapplicationStatusFieldUpdateOperationsInput | $Enums.applicationStatus
    applited_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
  }

  export type applicationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    job_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    resume_id?: IntFieldUpdateOperationsInput | number
    cover_letter?: StringFieldUpdateOperationsInput | string
    status?: EnumapplicationStatusFieldUpdateOperationsInput | $Enums.applicationStatus
    applited_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
  }

  export type application_documentsCreateInput = {
    document_type: $Enums.appDocumentStatus
    file_url: string
    uploaded_at?: Date | string
    document: applicationsCreateNestedOneWithoutDocumentInput
  }

  export type application_documentsUncheckedCreateInput = {
    id?: number
    application_id: number
    document_type: $Enums.appDocumentStatus
    file_url: string
    uploaded_at?: Date | string
  }

  export type application_documentsUpdateInput = {
    document_type?: EnumappDocumentStatusFieldUpdateOperationsInput | $Enums.appDocumentStatus
    file_url?: StringFieldUpdateOperationsInput | string
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: applicationsUpdateOneRequiredWithoutDocumentNestedInput
  }

  export type application_documentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    application_id?: IntFieldUpdateOperationsInput | number
    document_type?: EnumappDocumentStatusFieldUpdateOperationsInput | $Enums.appDocumentStatus
    file_url?: StringFieldUpdateOperationsInput | string
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type application_documentsCreateManyInput = {
    id?: number
    application_id: number
    document_type: $Enums.appDocumentStatus
    file_url: string
    uploaded_at?: Date | string
  }

  export type application_documentsUpdateManyMutationInput = {
    document_type?: EnumappDocumentStatusFieldUpdateOperationsInput | $Enums.appDocumentStatus
    file_url?: StringFieldUpdateOperationsInput | string
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type application_documentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    application_id?: IntFieldUpdateOperationsInput | number
    document_type?: EnumappDocumentStatusFieldUpdateOperationsInput | $Enums.appDocumentStatus
    file_url?: StringFieldUpdateOperationsInput | string
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type interviewsCreateInput = {
    interview_type: $Enums.interviewType
    scheduled_time: Date | string
    timezone: string
    duration_minutes?: number
    location: string
    meeting_url: string
    interview_name: string
    interview_position: string
    status: $Enums.interviewStatus
    feedback: string
    rating: number
    notes: string
    created_at?: Date | string
    updated_at?: Date | string
    interview: applicationsCreateNestedOneWithoutInterviewInput
  }

  export type interviewsUncheckedCreateInput = {
    id?: number
    application_id: number
    interview_type: $Enums.interviewType
    scheduled_time: Date | string
    timezone: string
    duration_minutes?: number
    location: string
    meeting_url: string
    interview_name: string
    interview_position: string
    status: $Enums.interviewStatus
    feedback: string
    rating: number
    notes: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type interviewsUpdateInput = {
    interview_type?: EnuminterviewTypeFieldUpdateOperationsInput | $Enums.interviewType
    scheduled_time?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    duration_minutes?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    meeting_url?: StringFieldUpdateOperationsInput | string
    interview_name?: StringFieldUpdateOperationsInput | string
    interview_position?: StringFieldUpdateOperationsInput | string
    status?: EnuminterviewStatusFieldUpdateOperationsInput | $Enums.interviewStatus
    feedback?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    interview?: applicationsUpdateOneRequiredWithoutInterviewNestedInput
  }

  export type interviewsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    application_id?: IntFieldUpdateOperationsInput | number
    interview_type?: EnuminterviewTypeFieldUpdateOperationsInput | $Enums.interviewType
    scheduled_time?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    duration_minutes?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    meeting_url?: StringFieldUpdateOperationsInput | string
    interview_name?: StringFieldUpdateOperationsInput | string
    interview_position?: StringFieldUpdateOperationsInput | string
    status?: EnuminterviewStatusFieldUpdateOperationsInput | $Enums.interviewStatus
    feedback?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type interviewsCreateManyInput = {
    id?: number
    application_id: number
    interview_type: $Enums.interviewType
    scheduled_time: Date | string
    timezone: string
    duration_minutes?: number
    location: string
    meeting_url: string
    interview_name: string
    interview_position: string
    status: $Enums.interviewStatus
    feedback: string
    rating: number
    notes: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type interviewsUpdateManyMutationInput = {
    interview_type?: EnuminterviewTypeFieldUpdateOperationsInput | $Enums.interviewType
    scheduled_time?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    duration_minutes?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    meeting_url?: StringFieldUpdateOperationsInput | string
    interview_name?: StringFieldUpdateOperationsInput | string
    interview_position?: StringFieldUpdateOperationsInput | string
    status?: EnuminterviewStatusFieldUpdateOperationsInput | $Enums.interviewStatus
    feedback?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type interviewsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    application_id?: IntFieldUpdateOperationsInput | number
    interview_type?: EnuminterviewTypeFieldUpdateOperationsInput | $Enums.interviewType
    scheduled_time?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    duration_minutes?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    meeting_url?: StringFieldUpdateOperationsInput | string
    interview_name?: StringFieldUpdateOperationsInput | string
    interview_position?: StringFieldUpdateOperationsInput | string
    status?: EnuminterviewStatusFieldUpdateOperationsInput | $Enums.interviewStatus
    feedback?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type contactsCreateInput = {
    contact_type: $Enums.contactType
    start_date: Date | string
    end_date: Date | string
    probation_period_months?: number
    salary_amount: number
    salary_currency: string
    salary_payment_period?: $Enums.contactSalaryPaymentPeriod
    benefits_description: string
    visa_sponsorship_details: string
    relocation_assistance_details: string
    status?: $Enums.contactStatus
    signed_at: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    contact: jobsCreateNestedOneWithoutContactInput
    contacts: usersCreateNestedOneWithoutContactsInput
    contac: companiesCreateNestedOneWithoutContactsInput
  }

  export type contactsUncheckedCreateInput = {
    id?: number
    job_id: number
    user_id: number
    company_id: number
    contact_type: $Enums.contactType
    start_date: Date | string
    end_date: Date | string
    probation_period_months?: number
    salary_amount: number
    salary_currency: string
    salary_payment_period?: $Enums.contactSalaryPaymentPeriod
    benefits_description: string
    visa_sponsorship_details: string
    relocation_assistance_details: string
    status?: $Enums.contactStatus
    signed_at: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type contactsUpdateInput = {
    contact_type?: EnumcontactTypeFieldUpdateOperationsInput | $Enums.contactType
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    probation_period_months?: IntFieldUpdateOperationsInput | number
    salary_amount?: IntFieldUpdateOperationsInput | number
    salary_currency?: StringFieldUpdateOperationsInput | string
    salary_payment_period?: EnumcontactSalaryPaymentPeriodFieldUpdateOperationsInput | $Enums.contactSalaryPaymentPeriod
    benefits_description?: StringFieldUpdateOperationsInput | string
    visa_sponsorship_details?: StringFieldUpdateOperationsInput | string
    relocation_assistance_details?: StringFieldUpdateOperationsInput | string
    status?: EnumcontactStatusFieldUpdateOperationsInput | $Enums.contactStatus
    signed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: jobsUpdateOneRequiredWithoutContactNestedInput
    contacts?: usersUpdateOneRequiredWithoutContactsNestedInput
    contac?: companiesUpdateOneRequiredWithoutContactsNestedInput
  }

  export type contactsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    job_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    contact_type?: EnumcontactTypeFieldUpdateOperationsInput | $Enums.contactType
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    probation_period_months?: IntFieldUpdateOperationsInput | number
    salary_amount?: IntFieldUpdateOperationsInput | number
    salary_currency?: StringFieldUpdateOperationsInput | string
    salary_payment_period?: EnumcontactSalaryPaymentPeriodFieldUpdateOperationsInput | $Enums.contactSalaryPaymentPeriod
    benefits_description?: StringFieldUpdateOperationsInput | string
    visa_sponsorship_details?: StringFieldUpdateOperationsInput | string
    relocation_assistance_details?: StringFieldUpdateOperationsInput | string
    status?: EnumcontactStatusFieldUpdateOperationsInput | $Enums.contactStatus
    signed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type contactsCreateManyInput = {
    id?: number
    job_id: number
    user_id: number
    company_id: number
    contact_type: $Enums.contactType
    start_date: Date | string
    end_date: Date | string
    probation_period_months?: number
    salary_amount: number
    salary_currency: string
    salary_payment_period?: $Enums.contactSalaryPaymentPeriod
    benefits_description: string
    visa_sponsorship_details: string
    relocation_assistance_details: string
    status?: $Enums.contactStatus
    signed_at: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type contactsUpdateManyMutationInput = {
    contact_type?: EnumcontactTypeFieldUpdateOperationsInput | $Enums.contactType
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    probation_period_months?: IntFieldUpdateOperationsInput | number
    salary_amount?: IntFieldUpdateOperationsInput | number
    salary_currency?: StringFieldUpdateOperationsInput | string
    salary_payment_period?: EnumcontactSalaryPaymentPeriodFieldUpdateOperationsInput | $Enums.contactSalaryPaymentPeriod
    benefits_description?: StringFieldUpdateOperationsInput | string
    visa_sponsorship_details?: StringFieldUpdateOperationsInput | string
    relocation_assistance_details?: StringFieldUpdateOperationsInput | string
    status?: EnumcontactStatusFieldUpdateOperationsInput | $Enums.contactStatus
    signed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type contactsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    job_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    contact_type?: EnumcontactTypeFieldUpdateOperationsInput | $Enums.contactType
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    probation_period_months?: IntFieldUpdateOperationsInput | number
    salary_amount?: IntFieldUpdateOperationsInput | number
    salary_currency?: StringFieldUpdateOperationsInput | string
    salary_payment_period?: EnumcontactSalaryPaymentPeriodFieldUpdateOperationsInput | $Enums.contactSalaryPaymentPeriod
    benefits_description?: StringFieldUpdateOperationsInput | string
    visa_sponsorship_details?: StringFieldUpdateOperationsInput | string
    relocation_assistance_details?: StringFieldUpdateOperationsInput | string
    status?: EnumcontactStatusFieldUpdateOperationsInput | $Enums.contactStatus
    signed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsCreateInput = {
    notification_type: string
    title: string
    message: string
    is_read?: boolean
    related_entity_type: string
    related_entity_id: number
    created_at?: Date | string
    notification: usersCreateNestedOneWithoutNotificationInput
  }

  export type notificationsUncheckedCreateInput = {
    id?: number
    user_id: number
    notification_type: string
    title: string
    message: string
    is_read?: boolean
    related_entity_type: string
    related_entity_id: number
    created_at?: Date | string
  }

  export type notificationsUpdateInput = {
    notification_type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    related_entity_type?: StringFieldUpdateOperationsInput | string
    related_entity_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notification?: usersUpdateOneRequiredWithoutNotificationNestedInput
  }

  export type notificationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    notification_type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    related_entity_type?: StringFieldUpdateOperationsInput | string
    related_entity_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsCreateManyInput = {
    id?: number
    user_id: number
    notification_type: string
    title: string
    message: string
    is_read?: boolean
    related_entity_type: string
    related_entity_id: number
    created_at?: Date | string
  }

  export type notificationsUpdateManyMutationInput = {
    notification_type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    related_entity_type?: StringFieldUpdateOperationsInput | string
    related_entity_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    notification_type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    related_entity_type?: StringFieldUpdateOperationsInput | string
    related_entity_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type saved_jobsCreateInput = {
    saved_at?: Date | string
    notes: string
    savedjob: usersCreateNestedOneWithoutSavedjobInput
    savedjobs: jobsCreateNestedOneWithoutSavedjobInput
  }

  export type saved_jobsUncheckedCreateInput = {
    id?: number
    user_id: number
    job_id: number
    saved_at?: Date | string
    notes: string
  }

  export type saved_jobsUpdateInput = {
    saved_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    savedjob?: usersUpdateOneRequiredWithoutSavedjobNestedInput
    savedjobs?: jobsUpdateOneRequiredWithoutSavedjobNestedInput
  }

  export type saved_jobsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    job_id?: IntFieldUpdateOperationsInput | number
    saved_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
  }

  export type saved_jobsCreateManyInput = {
    id?: number
    user_id: number
    job_id: number
    saved_at?: Date | string
    notes: string
  }

  export type saved_jobsUpdateManyMutationInput = {
    saved_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
  }

  export type saved_jobsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    job_id?: IntFieldUpdateOperationsInput | number
    saved_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
  }

  export type job_searchesCreateInput = {
    search_query: string
    country: string
    city: string
    job_catregory: string
    experience_level: string
    job_type: string
    created_at?: Date | string
    searches: usersCreateNestedOneWithoutSearchesInput
  }

  export type job_searchesUncheckedCreateInput = {
    id?: number
    user_id: number
    search_query: string
    country: string
    city: string
    job_catregory: string
    experience_level: string
    job_type: string
    created_at?: Date | string
  }

  export type job_searchesUpdateInput = {
    search_query?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    job_catregory?: StringFieldUpdateOperationsInput | string
    experience_level?: StringFieldUpdateOperationsInput | string
    job_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    searches?: usersUpdateOneRequiredWithoutSearchesNestedInput
  }

  export type job_searchesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    search_query?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    job_catregory?: StringFieldUpdateOperationsInput | string
    experience_level?: StringFieldUpdateOperationsInput | string
    job_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_searchesCreateManyInput = {
    id?: number
    user_id: number
    search_query: string
    country: string
    city: string
    job_catregory: string
    experience_level: string
    job_type: string
    created_at?: Date | string
  }

  export type job_searchesUpdateManyMutationInput = {
    search_query?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    job_catregory?: StringFieldUpdateOperationsInput | string
    experience_level?: StringFieldUpdateOperationsInput | string
    job_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_searchesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    search_query?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    job_catregory?: StringFieldUpdateOperationsInput | string
    experience_level?: StringFieldUpdateOperationsInput | string
    job_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumuserstatusFilter<$PrismaModel = never> = {
    equals?: $Enums.userstatus | EnumuserstatusFieldRefInput<$PrismaModel>
    in?: $Enums.userstatus[] | ListEnumuserstatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.userstatus[] | ListEnumuserstatusFieldRefInput<$PrismaModel>
    not?: NestedEnumuserstatusFilter<$PrismaModel> | $Enums.userstatus
  }

  export type User_addressesListRelationFilter = {
    every?: user_addressesWhereInput
    some?: user_addressesWhereInput
    none?: user_addressesWhereInput
  }

  export type ResumesListRelationFilter = {
    every?: resumesWhereInput
    some?: resumesWhereInput
    none?: resumesWhereInput
  }

  export type EducationsListRelationFilter = {
    every?: educationsWhereInput
    some?: educationsWhereInput
    none?: educationsWhereInput
  }

  export type Work_experiencesListRelationFilter = {
    every?: work_experiencesWhereInput
    some?: work_experiencesWhereInput
    none?: work_experiencesWhereInput
  }

  export type SkillsListRelationFilter = {
    every?: skillsWhereInput
    some?: skillsWhereInput
    none?: skillsWhereInput
  }

  export type LanguagesListRelationFilter = {
    every?: languagesWhereInput
    some?: languagesWhereInput
    none?: languagesWhereInput
  }

  export type CertificationsListRelationFilter = {
    every?: certificationsWhereInput
    some?: certificationsWhereInput
    none?: certificationsWhereInput
  }

  export type Visa_informationListRelationFilter = {
    every?: visa_informationWhereInput
    some?: visa_informationWhereInput
    none?: visa_informationWhereInput
  }

  export type ApplicationsListRelationFilter = {
    every?: applicationsWhereInput
    some?: applicationsWhereInput
    none?: applicationsWhereInput
  }

  export type ContactsListRelationFilter = {
    every?: contactsWhereInput
    some?: contactsWhereInput
    none?: contactsWhereInput
  }

  export type NotificationsListRelationFilter = {
    every?: notificationsWhereInput
    some?: notificationsWhereInput
    none?: notificationsWhereInput
  }

  export type Saved_jobsListRelationFilter = {
    every?: saved_jobsWhereInput
    some?: saved_jobsWhereInput
    none?: saved_jobsWhereInput
  }

  export type Job_searchesListRelationFilter = {
    every?: job_searchesWhereInput
    some?: job_searchesWhereInput
    none?: job_searchesWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type user_addressesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type resumesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type educationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type work_experiencesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type skillsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type languagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type certificationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type visa_informationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type applicationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type contactsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type notificationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type saved_jobsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type job_searchesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    phone_number?: SortOrder
    country_code?: SortOrder
    date_of_birth?: SortOrder
    gender?: SortOrder
    profile_picture_url?: SortOrder
    bio?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    last_login_at?: SortOrder
    status?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    phone_number?: SortOrder
    country_code?: SortOrder
    date_of_birth?: SortOrder
    gender?: SortOrder
    profile_picture_url?: SortOrder
    bio?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    last_login_at?: SortOrder
    status?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    phone_number?: SortOrder
    country_code?: SortOrder
    date_of_birth?: SortOrder
    gender?: SortOrder
    profile_picture_url?: SortOrder
    bio?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    last_login_at?: SortOrder
    status?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumuserstatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.userstatus | EnumuserstatusFieldRefInput<$PrismaModel>
    in?: $Enums.userstatus[] | ListEnumuserstatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.userstatus[] | ListEnumuserstatusFieldRefInput<$PrismaModel>
    not?: NestedEnumuserstatusWithAggregatesFilter<$PrismaModel> | $Enums.userstatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumuserstatusFilter<$PrismaModel>
    _max?: NestedEnumuserstatusFilter<$PrismaModel>
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type UsersScalarRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type user_addressesCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    adress_line1?: SortOrder
    adress_line2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postal_code?: SortOrder
    country?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
  }

  export type user_addressesAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type user_addressesMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    adress_line1?: SortOrder
    adress_line2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postal_code?: SortOrder
    country?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
  }

  export type user_addressesMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    adress_line1?: SortOrder
    adress_line2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postal_code?: SortOrder
    country?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
  }

  export type user_addressesSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type resumesCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    file_url?: SortOrder
    is_default?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type resumesAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type resumesMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    file_url?: SortOrder
    is_default?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type resumesMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    file_url?: SortOrder
    is_default?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type resumesSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type educationsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    institution?: SortOrder
    degree?: SortOrder
    field_of_study?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    grade?: SortOrder
    description?: SortOrder
    is_foreign_education?: SortOrder
    country?: SortOrder
  }

  export type educationsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type educationsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    institution?: SortOrder
    degree?: SortOrder
    field_of_study?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    grade?: SortOrder
    description?: SortOrder
    is_foreign_education?: SortOrder
    country?: SortOrder
  }

  export type educationsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    institution?: SortOrder
    degree?: SortOrder
    field_of_study?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    grade?: SortOrder
    description?: SortOrder
    is_foreign_education?: SortOrder
    country?: SortOrder
  }

  export type educationsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type work_experiencesCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    company_name?: SortOrder
    position?: SortOrder
    location?: SortOrder
    country?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    is_current_job?: SortOrder
    description?: SortOrder
    is_foregin_experience?: SortOrder
  }

  export type work_experiencesAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type work_experiencesMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    company_name?: SortOrder
    position?: SortOrder
    location?: SortOrder
    country?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    is_current_job?: SortOrder
    description?: SortOrder
    is_foregin_experience?: SortOrder
  }

  export type work_experiencesMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    company_name?: SortOrder
    position?: SortOrder
    location?: SortOrder
    country?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    is_current_job?: SortOrder
    description?: SortOrder
    is_foregin_experience?: SortOrder
  }

  export type work_experiencesSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type EnumskillsstatusFilter<$PrismaModel = never> = {
    equals?: $Enums.skillsstatus | EnumskillsstatusFieldRefInput<$PrismaModel>
    in?: $Enums.skillsstatus[] | ListEnumskillsstatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.skillsstatus[] | ListEnumskillsstatusFieldRefInput<$PrismaModel>
    not?: NestedEnumskillsstatusFilter<$PrismaModel> | $Enums.skillsstatus
  }

  export type skillsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    skill_name?: SortOrder
    proficiency?: SortOrder
    year_of_experience?: SortOrder
    is_certifield?: SortOrder
  }

  export type skillsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    year_of_experience?: SortOrder
  }

  export type skillsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    skill_name?: SortOrder
    proficiency?: SortOrder
    year_of_experience?: SortOrder
    is_certifield?: SortOrder
  }

  export type skillsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    skill_name?: SortOrder
    proficiency?: SortOrder
    year_of_experience?: SortOrder
    is_certifield?: SortOrder
  }

  export type skillsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    year_of_experience?: SortOrder
  }

  export type EnumskillsstatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.skillsstatus | EnumskillsstatusFieldRefInput<$PrismaModel>
    in?: $Enums.skillsstatus[] | ListEnumskillsstatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.skillsstatus[] | ListEnumskillsstatusFieldRefInput<$PrismaModel>
    not?: NestedEnumskillsstatusWithAggregatesFilter<$PrismaModel> | $Enums.skillsstatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumskillsstatusFilter<$PrismaModel>
    _max?: NestedEnumskillsstatusFilter<$PrismaModel>
  }

  export type EnumproficiencylanguagesFilter<$PrismaModel = never> = {
    equals?: $Enums.proficiencylanguages | EnumproficiencylanguagesFieldRefInput<$PrismaModel>
    in?: $Enums.proficiencylanguages[] | ListEnumproficiencylanguagesFieldRefInput<$PrismaModel>
    notIn?: $Enums.proficiencylanguages[] | ListEnumproficiencylanguagesFieldRefInput<$PrismaModel>
    not?: NestedEnumproficiencylanguagesFilter<$PrismaModel> | $Enums.proficiencylanguages
  }

  export type languagesCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    languages?: SortOrder
    proficiency?: SortOrder
    is_primary?: SortOrder
  }

  export type languagesAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type languagesMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    languages?: SortOrder
    proficiency?: SortOrder
    is_primary?: SortOrder
  }

  export type languagesMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    languages?: SortOrder
    proficiency?: SortOrder
    is_primary?: SortOrder
  }

  export type languagesSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type EnumproficiencylanguagesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.proficiencylanguages | EnumproficiencylanguagesFieldRefInput<$PrismaModel>
    in?: $Enums.proficiencylanguages[] | ListEnumproficiencylanguagesFieldRefInput<$PrismaModel>
    notIn?: $Enums.proficiencylanguages[] | ListEnumproficiencylanguagesFieldRefInput<$PrismaModel>
    not?: NestedEnumproficiencylanguagesWithAggregatesFilter<$PrismaModel> | $Enums.proficiencylanguages
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumproficiencylanguagesFilter<$PrismaModel>
    _max?: NestedEnumproficiencylanguagesFilter<$PrismaModel>
  }

  export type certificationsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    issuing_organization?: SortOrder
    issue_date?: SortOrder
    expiration_date?: SortOrder
    credential_id?: SortOrder
    credential_url?: SortOrder
    is_foreign_certification?: SortOrder
  }

  export type certificationsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type certificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    issuing_organization?: SortOrder
    issue_date?: SortOrder
    expiration_date?: SortOrder
    credential_id?: SortOrder
    credential_url?: SortOrder
    is_foreign_certification?: SortOrder
  }

  export type certificationsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    issuing_organization?: SortOrder
    issue_date?: SortOrder
    expiration_date?: SortOrder
    credential_id?: SortOrder
    credential_url?: SortOrder
    is_foreign_certification?: SortOrder
  }

  export type certificationsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type visa_informationCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    visa_type?: SortOrder
    country?: SortOrder
    status?: SortOrder
    expiry__date?: SortOrder
    is_multiple_entry?: SortOrder
    notes?: SortOrder
  }

  export type visa_informationAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type visa_informationMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    visa_type?: SortOrder
    country?: SortOrder
    status?: SortOrder
    expiry__date?: SortOrder
    is_multiple_entry?: SortOrder
    notes?: SortOrder
  }

  export type visa_informationMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    visa_type?: SortOrder
    country?: SortOrder
    status?: SortOrder
    expiry__date?: SortOrder
    is_multiple_entry?: SortOrder
    notes?: SortOrder
  }

  export type visa_informationSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type EnumcompanySizeFilter<$PrismaModel = never> = {
    equals?: $Enums.companySize | EnumcompanySizeFieldRefInput<$PrismaModel>
    in?: $Enums.companySize[] | ListEnumcompanySizeFieldRefInput<$PrismaModel>
    notIn?: $Enums.companySize[] | ListEnumcompanySizeFieldRefInput<$PrismaModel>
    not?: NestedEnumcompanySizeFilter<$PrismaModel> | $Enums.companySize
  }

  export type Company_locationsListRelationFilter = {
    every?: company_locationsWhereInput
    some?: company_locationsWhereInput
    none?: company_locationsWhereInput
  }

  export type JobsListRelationFilter = {
    every?: jobsWhereInput
    some?: jobsWhereInput
    none?: jobsWhereInput
  }

  export type company_locationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type jobsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type companiesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    industry?: SortOrder
    founded_year?: SortOrder
    website_url?: SortOrder
    logo_url?: SortOrder
    headquarters_country?: SortOrder
    company_siz?: SortOrder
    is_verified?: SortOrder
    created_at?: SortOrder
  }

  export type companiesAvgOrderByAggregateInput = {
    id?: SortOrder
    founded_year?: SortOrder
  }

  export type companiesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    industry?: SortOrder
    founded_year?: SortOrder
    website_url?: SortOrder
    logo_url?: SortOrder
    headquarters_country?: SortOrder
    company_siz?: SortOrder
    is_verified?: SortOrder
    created_at?: SortOrder
  }

  export type companiesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    industry?: SortOrder
    founded_year?: SortOrder
    website_url?: SortOrder
    logo_url?: SortOrder
    headquarters_country?: SortOrder
    company_siz?: SortOrder
    is_verified?: SortOrder
    created_at?: SortOrder
  }

  export type companiesSumOrderByAggregateInput = {
    id?: SortOrder
    founded_year?: SortOrder
  }

  export type EnumcompanySizeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.companySize | EnumcompanySizeFieldRefInput<$PrismaModel>
    in?: $Enums.companySize[] | ListEnumcompanySizeFieldRefInput<$PrismaModel>
    notIn?: $Enums.companySize[] | ListEnumcompanySizeFieldRefInput<$PrismaModel>
    not?: NestedEnumcompanySizeWithAggregatesFilter<$PrismaModel> | $Enums.companySize
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumcompanySizeFilter<$PrismaModel>
    _max?: NestedEnumcompanySizeFilter<$PrismaModel>
  }

  export type CompaniesScalarRelationFilter = {
    is?: companiesWhereInput
    isNot?: companiesWhereInput
  }

  export type company_locationsCountOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    country?: SortOrder
    city?: SortOrder
    address?: SortOrder
    is_headquarters?: SortOrder
    phone_number?: SortOrder
  }

  export type company_locationsAvgOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
  }

  export type company_locationsMaxOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    country?: SortOrder
    city?: SortOrder
    address?: SortOrder
    is_headquarters?: SortOrder
    phone_number?: SortOrder
  }

  export type company_locationsMinOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    country?: SortOrder
    city?: SortOrder
    address?: SortOrder
    is_headquarters?: SortOrder
    phone_number?: SortOrder
  }

  export type company_locationsSumOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
  }

  export type EnumjobTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.jobType | EnumjobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.jobType[] | ListEnumjobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.jobType[] | ListEnumjobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumjobTypeFilter<$PrismaModel> | $Enums.jobType
  }

  export type EnumsalaryPeriodFilter<$PrismaModel = never> = {
    equals?: $Enums.salaryPeriod | EnumsalaryPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.salaryPeriod[] | ListEnumsalaryPeriodFieldRefInput<$PrismaModel>
    notIn?: $Enums.salaryPeriod[] | ListEnumsalaryPeriodFieldRefInput<$PrismaModel>
    not?: NestedEnumsalaryPeriodFilter<$PrismaModel> | $Enums.salaryPeriod
  }

  export type EnumvisaSponsorshipFilter<$PrismaModel = never> = {
    equals?: $Enums.visaSponsorship | EnumvisaSponsorshipFieldRefInput<$PrismaModel>
    in?: $Enums.visaSponsorship[] | ListEnumvisaSponsorshipFieldRefInput<$PrismaModel>
    notIn?: $Enums.visaSponsorship[] | ListEnumvisaSponsorshipFieldRefInput<$PrismaModel>
    not?: NestedEnumvisaSponsorshipFilter<$PrismaModel> | $Enums.visaSponsorship
  }

  export type EnumexpLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.expLevel | EnumexpLevelFieldRefInput<$PrismaModel>
    in?: $Enums.expLevel[] | ListEnumexpLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.expLevel[] | ListEnumexpLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumexpLevelFilter<$PrismaModel> | $Enums.expLevel
  }

  export type EnumjobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.jobStatus | EnumjobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.jobStatus[] | ListEnumjobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.jobStatus[] | ListEnumjobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumjobStatusFilter<$PrismaModel> | $Enums.jobStatus
  }

  export type Job_requirementsListRelationFilter = {
    every?: job_requirementsWhereInput
    some?: job_requirementsWhereInput
    none?: job_requirementsWhereInput
  }

  export type Job_responsibilitesListRelationFilter = {
    every?: job_responsibilitesWhereInput
    some?: job_responsibilitesWhereInput
    none?: job_responsibilitesWhereInput
  }

  export type Job_benefitsListRelationFilter = {
    every?: job_benefitsWhereInput
    some?: job_benefitsWhereInput
    none?: job_benefitsWhereInput
  }

  export type job_requirementsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type job_responsibilitesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type job_benefitsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type jobsCountOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    job_category?: SortOrder
    job_type?: SortOrder
    location_country?: SortOrder
    location_city?: SortOrder
    is_relocation_assistance?: SortOrder
    is_remote_possible?: SortOrder
    salary_currency?: SortOrder
    salary_min?: SortOrder
    salary_max?: SortOrder
    salary_period?: SortOrder
    visa_sponsorship?: SortOrder
    experience_level?: SortOrder
    education_requirement?: SortOrder
    posted_by?: SortOrder
    status?: SortOrder
    posted_at?: SortOrder
    deadline?: SortOrder
    views_count?: SortOrder
  }

  export type jobsAvgOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    salary_min?: SortOrder
    salary_max?: SortOrder
    posted_by?: SortOrder
    views_count?: SortOrder
  }

  export type jobsMaxOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    job_category?: SortOrder
    job_type?: SortOrder
    location_country?: SortOrder
    location_city?: SortOrder
    is_relocation_assistance?: SortOrder
    is_remote_possible?: SortOrder
    salary_currency?: SortOrder
    salary_min?: SortOrder
    salary_max?: SortOrder
    salary_period?: SortOrder
    visa_sponsorship?: SortOrder
    experience_level?: SortOrder
    education_requirement?: SortOrder
    posted_by?: SortOrder
    status?: SortOrder
    posted_at?: SortOrder
    deadline?: SortOrder
    views_count?: SortOrder
  }

  export type jobsMinOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    job_category?: SortOrder
    job_type?: SortOrder
    location_country?: SortOrder
    location_city?: SortOrder
    is_relocation_assistance?: SortOrder
    is_remote_possible?: SortOrder
    salary_currency?: SortOrder
    salary_min?: SortOrder
    salary_max?: SortOrder
    salary_period?: SortOrder
    visa_sponsorship?: SortOrder
    experience_level?: SortOrder
    education_requirement?: SortOrder
    posted_by?: SortOrder
    status?: SortOrder
    posted_at?: SortOrder
    deadline?: SortOrder
    views_count?: SortOrder
  }

  export type jobsSumOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    salary_min?: SortOrder
    salary_max?: SortOrder
    posted_by?: SortOrder
    views_count?: SortOrder
  }

  export type EnumjobTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.jobType | EnumjobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.jobType[] | ListEnumjobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.jobType[] | ListEnumjobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumjobTypeWithAggregatesFilter<$PrismaModel> | $Enums.jobType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumjobTypeFilter<$PrismaModel>
    _max?: NestedEnumjobTypeFilter<$PrismaModel>
  }

  export type EnumsalaryPeriodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.salaryPeriod | EnumsalaryPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.salaryPeriod[] | ListEnumsalaryPeriodFieldRefInput<$PrismaModel>
    notIn?: $Enums.salaryPeriod[] | ListEnumsalaryPeriodFieldRefInput<$PrismaModel>
    not?: NestedEnumsalaryPeriodWithAggregatesFilter<$PrismaModel> | $Enums.salaryPeriod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumsalaryPeriodFilter<$PrismaModel>
    _max?: NestedEnumsalaryPeriodFilter<$PrismaModel>
  }

  export type EnumvisaSponsorshipWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.visaSponsorship | EnumvisaSponsorshipFieldRefInput<$PrismaModel>
    in?: $Enums.visaSponsorship[] | ListEnumvisaSponsorshipFieldRefInput<$PrismaModel>
    notIn?: $Enums.visaSponsorship[] | ListEnumvisaSponsorshipFieldRefInput<$PrismaModel>
    not?: NestedEnumvisaSponsorshipWithAggregatesFilter<$PrismaModel> | $Enums.visaSponsorship
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumvisaSponsorshipFilter<$PrismaModel>
    _max?: NestedEnumvisaSponsorshipFilter<$PrismaModel>
  }

  export type EnumexpLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.expLevel | EnumexpLevelFieldRefInput<$PrismaModel>
    in?: $Enums.expLevel[] | ListEnumexpLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.expLevel[] | ListEnumexpLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumexpLevelWithAggregatesFilter<$PrismaModel> | $Enums.expLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumexpLevelFilter<$PrismaModel>
    _max?: NestedEnumexpLevelFilter<$PrismaModel>
  }

  export type EnumjobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.jobStatus | EnumjobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.jobStatus[] | ListEnumjobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.jobStatus[] | ListEnumjobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumjobStatusWithAggregatesFilter<$PrismaModel> | $Enums.jobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumjobStatusFilter<$PrismaModel>
    _max?: NestedEnumjobStatusFilter<$PrismaModel>
  }

  export type EnumjobRequirementsFilter<$PrismaModel = never> = {
    equals?: $Enums.jobRequirements | EnumjobRequirementsFieldRefInput<$PrismaModel>
    in?: $Enums.jobRequirements[] | ListEnumjobRequirementsFieldRefInput<$PrismaModel>
    notIn?: $Enums.jobRequirements[] | ListEnumjobRequirementsFieldRefInput<$PrismaModel>
    not?: NestedEnumjobRequirementsFilter<$PrismaModel> | $Enums.jobRequirements
  }

  export type JobsScalarRelationFilter = {
    is?: jobsWhereInput
    isNot?: jobsWhereInput
  }

  export type job_requirementsCountOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
    requirement_type?: SortOrder
    requirement_text?: SortOrder
    is_mandatory?: SortOrder
    priority?: SortOrder
  }

  export type job_requirementsAvgOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
    priority?: SortOrder
  }

  export type job_requirementsMaxOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
    requirement_type?: SortOrder
    requirement_text?: SortOrder
    is_mandatory?: SortOrder
    priority?: SortOrder
  }

  export type job_requirementsMinOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
    requirement_type?: SortOrder
    requirement_text?: SortOrder
    is_mandatory?: SortOrder
    priority?: SortOrder
  }

  export type job_requirementsSumOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
    priority?: SortOrder
  }

  export type EnumjobRequirementsWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.jobRequirements | EnumjobRequirementsFieldRefInput<$PrismaModel>
    in?: $Enums.jobRequirements[] | ListEnumjobRequirementsFieldRefInput<$PrismaModel>
    notIn?: $Enums.jobRequirements[] | ListEnumjobRequirementsFieldRefInput<$PrismaModel>
    not?: NestedEnumjobRequirementsWithAggregatesFilter<$PrismaModel> | $Enums.jobRequirements
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumjobRequirementsFilter<$PrismaModel>
    _max?: NestedEnumjobRequirementsFilter<$PrismaModel>
  }

  export type job_responsibilitesCountOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
    responsibility_text?: SortOrder
    priority?: SortOrder
  }

  export type job_responsibilitesAvgOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
    priority?: SortOrder
  }

  export type job_responsibilitesMaxOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
    responsibility_text?: SortOrder
    priority?: SortOrder
  }

  export type job_responsibilitesMinOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
    responsibility_text?: SortOrder
    priority?: SortOrder
  }

  export type job_responsibilitesSumOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
    priority?: SortOrder
  }

  export type EnumjobBenefitFilter<$PrismaModel = never> = {
    equals?: $Enums.jobBenefit | EnumjobBenefitFieldRefInput<$PrismaModel>
    in?: $Enums.jobBenefit[] | ListEnumjobBenefitFieldRefInput<$PrismaModel>
    notIn?: $Enums.jobBenefit[] | ListEnumjobBenefitFieldRefInput<$PrismaModel>
    not?: NestedEnumjobBenefitFilter<$PrismaModel> | $Enums.jobBenefit
  }

  export type job_benefitsCountOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
    benefit_type?: SortOrder
    description?: SortOrder
  }

  export type job_benefitsAvgOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
  }

  export type job_benefitsMaxOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
    benefit_type?: SortOrder
    description?: SortOrder
  }

  export type job_benefitsMinOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
    benefit_type?: SortOrder
    description?: SortOrder
  }

  export type job_benefitsSumOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
  }

  export type EnumjobBenefitWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.jobBenefit | EnumjobBenefitFieldRefInput<$PrismaModel>
    in?: $Enums.jobBenefit[] | ListEnumjobBenefitFieldRefInput<$PrismaModel>
    notIn?: $Enums.jobBenefit[] | ListEnumjobBenefitFieldRefInput<$PrismaModel>
    not?: NestedEnumjobBenefitWithAggregatesFilter<$PrismaModel> | $Enums.jobBenefit
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumjobBenefitFilter<$PrismaModel>
    _max?: NestedEnumjobBenefitFilter<$PrismaModel>
  }

  export type EnumapplicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.applicationStatus | EnumapplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.applicationStatus[] | ListEnumapplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.applicationStatus[] | ListEnumapplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumapplicationStatusFilter<$PrismaModel> | $Enums.applicationStatus
  }

  export type ResumesScalarRelationFilter = {
    is?: resumesWhereInput
    isNot?: resumesWhereInput
  }

  export type Application_documentsListRelationFilter = {
    every?: application_documentsWhereInput
    some?: application_documentsWhereInput
    none?: application_documentsWhereInput
  }

  export type InterviewsListRelationFilter = {
    every?: interviewsWhereInput
    some?: interviewsWhereInput
    none?: interviewsWhereInput
  }

  export type application_documentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type interviewsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type applicationsCountOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
    user_id?: SortOrder
    resume_id?: SortOrder
    cover_letter?: SortOrder
    status?: SortOrder
    applited_at?: SortOrder
    updated_at?: SortOrder
    notes?: SortOrder
  }

  export type applicationsAvgOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
    user_id?: SortOrder
    resume_id?: SortOrder
  }

  export type applicationsMaxOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
    user_id?: SortOrder
    resume_id?: SortOrder
    cover_letter?: SortOrder
    status?: SortOrder
    applited_at?: SortOrder
    updated_at?: SortOrder
    notes?: SortOrder
  }

  export type applicationsMinOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
    user_id?: SortOrder
    resume_id?: SortOrder
    cover_letter?: SortOrder
    status?: SortOrder
    applited_at?: SortOrder
    updated_at?: SortOrder
    notes?: SortOrder
  }

  export type applicationsSumOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
    user_id?: SortOrder
    resume_id?: SortOrder
  }

  export type EnumapplicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.applicationStatus | EnumapplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.applicationStatus[] | ListEnumapplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.applicationStatus[] | ListEnumapplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumapplicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.applicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumapplicationStatusFilter<$PrismaModel>
    _max?: NestedEnumapplicationStatusFilter<$PrismaModel>
  }

  export type EnumappDocumentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.appDocumentStatus | EnumappDocumentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.appDocumentStatus[] | ListEnumappDocumentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.appDocumentStatus[] | ListEnumappDocumentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumappDocumentStatusFilter<$PrismaModel> | $Enums.appDocumentStatus
  }

  export type ApplicationsScalarRelationFilter = {
    is?: applicationsWhereInput
    isNot?: applicationsWhereInput
  }

  export type application_documentsCountOrderByAggregateInput = {
    id?: SortOrder
    application_id?: SortOrder
    document_type?: SortOrder
    file_url?: SortOrder
    uploaded_at?: SortOrder
  }

  export type application_documentsAvgOrderByAggregateInput = {
    id?: SortOrder
    application_id?: SortOrder
  }

  export type application_documentsMaxOrderByAggregateInput = {
    id?: SortOrder
    application_id?: SortOrder
    document_type?: SortOrder
    file_url?: SortOrder
    uploaded_at?: SortOrder
  }

  export type application_documentsMinOrderByAggregateInput = {
    id?: SortOrder
    application_id?: SortOrder
    document_type?: SortOrder
    file_url?: SortOrder
    uploaded_at?: SortOrder
  }

  export type application_documentsSumOrderByAggregateInput = {
    id?: SortOrder
    application_id?: SortOrder
  }

  export type EnumappDocumentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.appDocumentStatus | EnumappDocumentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.appDocumentStatus[] | ListEnumappDocumentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.appDocumentStatus[] | ListEnumappDocumentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumappDocumentStatusWithAggregatesFilter<$PrismaModel> | $Enums.appDocumentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumappDocumentStatusFilter<$PrismaModel>
    _max?: NestedEnumappDocumentStatusFilter<$PrismaModel>
  }

  export type EnuminterviewTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.interviewType | EnuminterviewTypeFieldRefInput<$PrismaModel>
    in?: $Enums.interviewType[] | ListEnuminterviewTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.interviewType[] | ListEnuminterviewTypeFieldRefInput<$PrismaModel>
    not?: NestedEnuminterviewTypeFilter<$PrismaModel> | $Enums.interviewType
  }

  export type EnuminterviewStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.interviewStatus | EnuminterviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.interviewStatus[] | ListEnuminterviewStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.interviewStatus[] | ListEnuminterviewStatusFieldRefInput<$PrismaModel>
    not?: NestedEnuminterviewStatusFilter<$PrismaModel> | $Enums.interviewStatus
  }

  export type interviewsCountOrderByAggregateInput = {
    id?: SortOrder
    application_id?: SortOrder
    interview_type?: SortOrder
    scheduled_time?: SortOrder
    timezone?: SortOrder
    duration_minutes?: SortOrder
    location?: SortOrder
    meeting_url?: SortOrder
    interview_name?: SortOrder
    interview_position?: SortOrder
    status?: SortOrder
    feedback?: SortOrder
    rating?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type interviewsAvgOrderByAggregateInput = {
    id?: SortOrder
    application_id?: SortOrder
    duration_minutes?: SortOrder
    rating?: SortOrder
  }

  export type interviewsMaxOrderByAggregateInput = {
    id?: SortOrder
    application_id?: SortOrder
    interview_type?: SortOrder
    scheduled_time?: SortOrder
    timezone?: SortOrder
    duration_minutes?: SortOrder
    location?: SortOrder
    meeting_url?: SortOrder
    interview_name?: SortOrder
    interview_position?: SortOrder
    status?: SortOrder
    feedback?: SortOrder
    rating?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type interviewsMinOrderByAggregateInput = {
    id?: SortOrder
    application_id?: SortOrder
    interview_type?: SortOrder
    scheduled_time?: SortOrder
    timezone?: SortOrder
    duration_minutes?: SortOrder
    location?: SortOrder
    meeting_url?: SortOrder
    interview_name?: SortOrder
    interview_position?: SortOrder
    status?: SortOrder
    feedback?: SortOrder
    rating?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type interviewsSumOrderByAggregateInput = {
    id?: SortOrder
    application_id?: SortOrder
    duration_minutes?: SortOrder
    rating?: SortOrder
  }

  export type EnuminterviewTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.interviewType | EnuminterviewTypeFieldRefInput<$PrismaModel>
    in?: $Enums.interviewType[] | ListEnuminterviewTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.interviewType[] | ListEnuminterviewTypeFieldRefInput<$PrismaModel>
    not?: NestedEnuminterviewTypeWithAggregatesFilter<$PrismaModel> | $Enums.interviewType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnuminterviewTypeFilter<$PrismaModel>
    _max?: NestedEnuminterviewTypeFilter<$PrismaModel>
  }

  export type EnuminterviewStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.interviewStatus | EnuminterviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.interviewStatus[] | ListEnuminterviewStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.interviewStatus[] | ListEnuminterviewStatusFieldRefInput<$PrismaModel>
    not?: NestedEnuminterviewStatusWithAggregatesFilter<$PrismaModel> | $Enums.interviewStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnuminterviewStatusFilter<$PrismaModel>
    _max?: NestedEnuminterviewStatusFilter<$PrismaModel>
  }

  export type EnumcontactTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.contactType | EnumcontactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.contactType[] | ListEnumcontactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.contactType[] | ListEnumcontactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumcontactTypeFilter<$PrismaModel> | $Enums.contactType
  }

  export type EnumcontactSalaryPaymentPeriodFilter<$PrismaModel = never> = {
    equals?: $Enums.contactSalaryPaymentPeriod | EnumcontactSalaryPaymentPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.contactSalaryPaymentPeriod[] | ListEnumcontactSalaryPaymentPeriodFieldRefInput<$PrismaModel>
    notIn?: $Enums.contactSalaryPaymentPeriod[] | ListEnumcontactSalaryPaymentPeriodFieldRefInput<$PrismaModel>
    not?: NestedEnumcontactSalaryPaymentPeriodFilter<$PrismaModel> | $Enums.contactSalaryPaymentPeriod
  }

  export type EnumcontactStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.contactStatus | EnumcontactStatusFieldRefInput<$PrismaModel>
    in?: $Enums.contactStatus[] | ListEnumcontactStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.contactStatus[] | ListEnumcontactStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumcontactStatusFilter<$PrismaModel> | $Enums.contactStatus
  }

  export type contactsCountOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
    user_id?: SortOrder
    company_id?: SortOrder
    contact_type?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    probation_period_months?: SortOrder
    salary_amount?: SortOrder
    salary_currency?: SortOrder
    salary_payment_period?: SortOrder
    benefits_description?: SortOrder
    visa_sponsorship_details?: SortOrder
    relocation_assistance_details?: SortOrder
    status?: SortOrder
    signed_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type contactsAvgOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
    user_id?: SortOrder
    company_id?: SortOrder
    probation_period_months?: SortOrder
    salary_amount?: SortOrder
  }

  export type contactsMaxOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
    user_id?: SortOrder
    company_id?: SortOrder
    contact_type?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    probation_period_months?: SortOrder
    salary_amount?: SortOrder
    salary_currency?: SortOrder
    salary_payment_period?: SortOrder
    benefits_description?: SortOrder
    visa_sponsorship_details?: SortOrder
    relocation_assistance_details?: SortOrder
    status?: SortOrder
    signed_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type contactsMinOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
    user_id?: SortOrder
    company_id?: SortOrder
    contact_type?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    probation_period_months?: SortOrder
    salary_amount?: SortOrder
    salary_currency?: SortOrder
    salary_payment_period?: SortOrder
    benefits_description?: SortOrder
    visa_sponsorship_details?: SortOrder
    relocation_assistance_details?: SortOrder
    status?: SortOrder
    signed_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type contactsSumOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
    user_id?: SortOrder
    company_id?: SortOrder
    probation_period_months?: SortOrder
    salary_amount?: SortOrder
  }

  export type EnumcontactTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.contactType | EnumcontactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.contactType[] | ListEnumcontactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.contactType[] | ListEnumcontactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumcontactTypeWithAggregatesFilter<$PrismaModel> | $Enums.contactType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumcontactTypeFilter<$PrismaModel>
    _max?: NestedEnumcontactTypeFilter<$PrismaModel>
  }

  export type EnumcontactSalaryPaymentPeriodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.contactSalaryPaymentPeriod | EnumcontactSalaryPaymentPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.contactSalaryPaymentPeriod[] | ListEnumcontactSalaryPaymentPeriodFieldRefInput<$PrismaModel>
    notIn?: $Enums.contactSalaryPaymentPeriod[] | ListEnumcontactSalaryPaymentPeriodFieldRefInput<$PrismaModel>
    not?: NestedEnumcontactSalaryPaymentPeriodWithAggregatesFilter<$PrismaModel> | $Enums.contactSalaryPaymentPeriod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumcontactSalaryPaymentPeriodFilter<$PrismaModel>
    _max?: NestedEnumcontactSalaryPaymentPeriodFilter<$PrismaModel>
  }

  export type EnumcontactStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.contactStatus | EnumcontactStatusFieldRefInput<$PrismaModel>
    in?: $Enums.contactStatus[] | ListEnumcontactStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.contactStatus[] | ListEnumcontactStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumcontactStatusWithAggregatesFilter<$PrismaModel> | $Enums.contactStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumcontactStatusFilter<$PrismaModel>
    _max?: NestedEnumcontactStatusFilter<$PrismaModel>
  }

  export type notificationsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    notification_type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    is_read?: SortOrder
    related_entity_type?: SortOrder
    related_entity_id?: SortOrder
    created_at?: SortOrder
  }

  export type notificationsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    related_entity_id?: SortOrder
  }

  export type notificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    notification_type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    is_read?: SortOrder
    related_entity_type?: SortOrder
    related_entity_id?: SortOrder
    created_at?: SortOrder
  }

  export type notificationsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    notification_type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    is_read?: SortOrder
    related_entity_type?: SortOrder
    related_entity_id?: SortOrder
    created_at?: SortOrder
  }

  export type notificationsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    related_entity_id?: SortOrder
  }

  export type saved_jobsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    job_id?: SortOrder
    saved_at?: SortOrder
    notes?: SortOrder
  }

  export type saved_jobsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    job_id?: SortOrder
  }

  export type saved_jobsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    job_id?: SortOrder
    saved_at?: SortOrder
    notes?: SortOrder
  }

  export type saved_jobsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    job_id?: SortOrder
    saved_at?: SortOrder
    notes?: SortOrder
  }

  export type saved_jobsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    job_id?: SortOrder
  }

  export type job_searchesCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    search_query?: SortOrder
    country?: SortOrder
    city?: SortOrder
    job_catregory?: SortOrder
    experience_level?: SortOrder
    job_type?: SortOrder
    created_at?: SortOrder
  }

  export type job_searchesAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type job_searchesMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    search_query?: SortOrder
    country?: SortOrder
    city?: SortOrder
    job_catregory?: SortOrder
    experience_level?: SortOrder
    job_type?: SortOrder
    created_at?: SortOrder
  }

  export type job_searchesMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    search_query?: SortOrder
    country?: SortOrder
    city?: SortOrder
    job_catregory?: SortOrder
    experience_level?: SortOrder
    job_type?: SortOrder
    created_at?: SortOrder
  }

  export type job_searchesSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type user_addressesCreateNestedManyWithoutUserInput = {
    create?: XOR<user_addressesCreateWithoutUserInput, user_addressesUncheckedCreateWithoutUserInput> | user_addressesCreateWithoutUserInput[] | user_addressesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_addressesCreateOrConnectWithoutUserInput | user_addressesCreateOrConnectWithoutUserInput[]
    createMany?: user_addressesCreateManyUserInputEnvelope
    connect?: user_addressesWhereUniqueInput | user_addressesWhereUniqueInput[]
  }

  export type resumesCreateNestedManyWithoutUserInput = {
    create?: XOR<resumesCreateWithoutUserInput, resumesUncheckedCreateWithoutUserInput> | resumesCreateWithoutUserInput[] | resumesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: resumesCreateOrConnectWithoutUserInput | resumesCreateOrConnectWithoutUserInput[]
    createMany?: resumesCreateManyUserInputEnvelope
    connect?: resumesWhereUniqueInput | resumesWhereUniqueInput[]
  }

  export type educationsCreateNestedManyWithoutUserInput = {
    create?: XOR<educationsCreateWithoutUserInput, educationsUncheckedCreateWithoutUserInput> | educationsCreateWithoutUserInput[] | educationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: educationsCreateOrConnectWithoutUserInput | educationsCreateOrConnectWithoutUserInput[]
    createMany?: educationsCreateManyUserInputEnvelope
    connect?: educationsWhereUniqueInput | educationsWhereUniqueInput[]
  }

  export type work_experiencesCreateNestedManyWithoutUserInput = {
    create?: XOR<work_experiencesCreateWithoutUserInput, work_experiencesUncheckedCreateWithoutUserInput> | work_experiencesCreateWithoutUserInput[] | work_experiencesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: work_experiencesCreateOrConnectWithoutUserInput | work_experiencesCreateOrConnectWithoutUserInput[]
    createMany?: work_experiencesCreateManyUserInputEnvelope
    connect?: work_experiencesWhereUniqueInput | work_experiencesWhereUniqueInput[]
  }

  export type skillsCreateNestedManyWithoutUserInput = {
    create?: XOR<skillsCreateWithoutUserInput, skillsUncheckedCreateWithoutUserInput> | skillsCreateWithoutUserInput[] | skillsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: skillsCreateOrConnectWithoutUserInput | skillsCreateOrConnectWithoutUserInput[]
    createMany?: skillsCreateManyUserInputEnvelope
    connect?: skillsWhereUniqueInput | skillsWhereUniqueInput[]
  }

  export type languagesCreateNestedManyWithoutUserInput = {
    create?: XOR<languagesCreateWithoutUserInput, languagesUncheckedCreateWithoutUserInput> | languagesCreateWithoutUserInput[] | languagesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: languagesCreateOrConnectWithoutUserInput | languagesCreateOrConnectWithoutUserInput[]
    createMany?: languagesCreateManyUserInputEnvelope
    connect?: languagesWhereUniqueInput | languagesWhereUniqueInput[]
  }

  export type certificationsCreateNestedManyWithoutUserInput = {
    create?: XOR<certificationsCreateWithoutUserInput, certificationsUncheckedCreateWithoutUserInput> | certificationsCreateWithoutUserInput[] | certificationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: certificationsCreateOrConnectWithoutUserInput | certificationsCreateOrConnectWithoutUserInput[]
    createMany?: certificationsCreateManyUserInputEnvelope
    connect?: certificationsWhereUniqueInput | certificationsWhereUniqueInput[]
  }

  export type visa_informationCreateNestedManyWithoutVisaInput = {
    create?: XOR<visa_informationCreateWithoutVisaInput, visa_informationUncheckedCreateWithoutVisaInput> | visa_informationCreateWithoutVisaInput[] | visa_informationUncheckedCreateWithoutVisaInput[]
    connectOrCreate?: visa_informationCreateOrConnectWithoutVisaInput | visa_informationCreateOrConnectWithoutVisaInput[]
    createMany?: visa_informationCreateManyVisaInputEnvelope
    connect?: visa_informationWhereUniqueInput | visa_informationWhereUniqueInput[]
  }

  export type applicationsCreateNestedManyWithoutAplicationInput = {
    create?: XOR<applicationsCreateWithoutAplicationInput, applicationsUncheckedCreateWithoutAplicationInput> | applicationsCreateWithoutAplicationInput[] | applicationsUncheckedCreateWithoutAplicationInput[]
    connectOrCreate?: applicationsCreateOrConnectWithoutAplicationInput | applicationsCreateOrConnectWithoutAplicationInput[]
    createMany?: applicationsCreateManyAplicationInputEnvelope
    connect?: applicationsWhereUniqueInput | applicationsWhereUniqueInput[]
  }

  export type contactsCreateNestedManyWithoutContactsInput = {
    create?: XOR<contactsCreateWithoutContactsInput, contactsUncheckedCreateWithoutContactsInput> | contactsCreateWithoutContactsInput[] | contactsUncheckedCreateWithoutContactsInput[]
    connectOrCreate?: contactsCreateOrConnectWithoutContactsInput | contactsCreateOrConnectWithoutContactsInput[]
    createMany?: contactsCreateManyContactsInputEnvelope
    connect?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
  }

  export type notificationsCreateNestedManyWithoutNotificationInput = {
    create?: XOR<notificationsCreateWithoutNotificationInput, notificationsUncheckedCreateWithoutNotificationInput> | notificationsCreateWithoutNotificationInput[] | notificationsUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutNotificationInput | notificationsCreateOrConnectWithoutNotificationInput[]
    createMany?: notificationsCreateManyNotificationInputEnvelope
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
  }

  export type saved_jobsCreateNestedManyWithoutSavedjobInput = {
    create?: XOR<saved_jobsCreateWithoutSavedjobInput, saved_jobsUncheckedCreateWithoutSavedjobInput> | saved_jobsCreateWithoutSavedjobInput[] | saved_jobsUncheckedCreateWithoutSavedjobInput[]
    connectOrCreate?: saved_jobsCreateOrConnectWithoutSavedjobInput | saved_jobsCreateOrConnectWithoutSavedjobInput[]
    createMany?: saved_jobsCreateManySavedjobInputEnvelope
    connect?: saved_jobsWhereUniqueInput | saved_jobsWhereUniqueInput[]
  }

  export type job_searchesCreateNestedManyWithoutSearchesInput = {
    create?: XOR<job_searchesCreateWithoutSearchesInput, job_searchesUncheckedCreateWithoutSearchesInput> | job_searchesCreateWithoutSearchesInput[] | job_searchesUncheckedCreateWithoutSearchesInput[]
    connectOrCreate?: job_searchesCreateOrConnectWithoutSearchesInput | job_searchesCreateOrConnectWithoutSearchesInput[]
    createMany?: job_searchesCreateManySearchesInputEnvelope
    connect?: job_searchesWhereUniqueInput | job_searchesWhereUniqueInput[]
  }

  export type user_addressesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<user_addressesCreateWithoutUserInput, user_addressesUncheckedCreateWithoutUserInput> | user_addressesCreateWithoutUserInput[] | user_addressesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_addressesCreateOrConnectWithoutUserInput | user_addressesCreateOrConnectWithoutUserInput[]
    createMany?: user_addressesCreateManyUserInputEnvelope
    connect?: user_addressesWhereUniqueInput | user_addressesWhereUniqueInput[]
  }

  export type resumesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<resumesCreateWithoutUserInput, resumesUncheckedCreateWithoutUserInput> | resumesCreateWithoutUserInput[] | resumesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: resumesCreateOrConnectWithoutUserInput | resumesCreateOrConnectWithoutUserInput[]
    createMany?: resumesCreateManyUserInputEnvelope
    connect?: resumesWhereUniqueInput | resumesWhereUniqueInput[]
  }

  export type educationsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<educationsCreateWithoutUserInput, educationsUncheckedCreateWithoutUserInput> | educationsCreateWithoutUserInput[] | educationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: educationsCreateOrConnectWithoutUserInput | educationsCreateOrConnectWithoutUserInput[]
    createMany?: educationsCreateManyUserInputEnvelope
    connect?: educationsWhereUniqueInput | educationsWhereUniqueInput[]
  }

  export type work_experiencesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<work_experiencesCreateWithoutUserInput, work_experiencesUncheckedCreateWithoutUserInput> | work_experiencesCreateWithoutUserInput[] | work_experiencesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: work_experiencesCreateOrConnectWithoutUserInput | work_experiencesCreateOrConnectWithoutUserInput[]
    createMany?: work_experiencesCreateManyUserInputEnvelope
    connect?: work_experiencesWhereUniqueInput | work_experiencesWhereUniqueInput[]
  }

  export type skillsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<skillsCreateWithoutUserInput, skillsUncheckedCreateWithoutUserInput> | skillsCreateWithoutUserInput[] | skillsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: skillsCreateOrConnectWithoutUserInput | skillsCreateOrConnectWithoutUserInput[]
    createMany?: skillsCreateManyUserInputEnvelope
    connect?: skillsWhereUniqueInput | skillsWhereUniqueInput[]
  }

  export type languagesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<languagesCreateWithoutUserInput, languagesUncheckedCreateWithoutUserInput> | languagesCreateWithoutUserInput[] | languagesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: languagesCreateOrConnectWithoutUserInput | languagesCreateOrConnectWithoutUserInput[]
    createMany?: languagesCreateManyUserInputEnvelope
    connect?: languagesWhereUniqueInput | languagesWhereUniqueInput[]
  }

  export type certificationsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<certificationsCreateWithoutUserInput, certificationsUncheckedCreateWithoutUserInput> | certificationsCreateWithoutUserInput[] | certificationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: certificationsCreateOrConnectWithoutUserInput | certificationsCreateOrConnectWithoutUserInput[]
    createMany?: certificationsCreateManyUserInputEnvelope
    connect?: certificationsWhereUniqueInput | certificationsWhereUniqueInput[]
  }

  export type visa_informationUncheckedCreateNestedManyWithoutVisaInput = {
    create?: XOR<visa_informationCreateWithoutVisaInput, visa_informationUncheckedCreateWithoutVisaInput> | visa_informationCreateWithoutVisaInput[] | visa_informationUncheckedCreateWithoutVisaInput[]
    connectOrCreate?: visa_informationCreateOrConnectWithoutVisaInput | visa_informationCreateOrConnectWithoutVisaInput[]
    createMany?: visa_informationCreateManyVisaInputEnvelope
    connect?: visa_informationWhereUniqueInput | visa_informationWhereUniqueInput[]
  }

  export type applicationsUncheckedCreateNestedManyWithoutAplicationInput = {
    create?: XOR<applicationsCreateWithoutAplicationInput, applicationsUncheckedCreateWithoutAplicationInput> | applicationsCreateWithoutAplicationInput[] | applicationsUncheckedCreateWithoutAplicationInput[]
    connectOrCreate?: applicationsCreateOrConnectWithoutAplicationInput | applicationsCreateOrConnectWithoutAplicationInput[]
    createMany?: applicationsCreateManyAplicationInputEnvelope
    connect?: applicationsWhereUniqueInput | applicationsWhereUniqueInput[]
  }

  export type contactsUncheckedCreateNestedManyWithoutContactsInput = {
    create?: XOR<contactsCreateWithoutContactsInput, contactsUncheckedCreateWithoutContactsInput> | contactsCreateWithoutContactsInput[] | contactsUncheckedCreateWithoutContactsInput[]
    connectOrCreate?: contactsCreateOrConnectWithoutContactsInput | contactsCreateOrConnectWithoutContactsInput[]
    createMany?: contactsCreateManyContactsInputEnvelope
    connect?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
  }

  export type notificationsUncheckedCreateNestedManyWithoutNotificationInput = {
    create?: XOR<notificationsCreateWithoutNotificationInput, notificationsUncheckedCreateWithoutNotificationInput> | notificationsCreateWithoutNotificationInput[] | notificationsUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutNotificationInput | notificationsCreateOrConnectWithoutNotificationInput[]
    createMany?: notificationsCreateManyNotificationInputEnvelope
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
  }

  export type saved_jobsUncheckedCreateNestedManyWithoutSavedjobInput = {
    create?: XOR<saved_jobsCreateWithoutSavedjobInput, saved_jobsUncheckedCreateWithoutSavedjobInput> | saved_jobsCreateWithoutSavedjobInput[] | saved_jobsUncheckedCreateWithoutSavedjobInput[]
    connectOrCreate?: saved_jobsCreateOrConnectWithoutSavedjobInput | saved_jobsCreateOrConnectWithoutSavedjobInput[]
    createMany?: saved_jobsCreateManySavedjobInputEnvelope
    connect?: saved_jobsWhereUniqueInput | saved_jobsWhereUniqueInput[]
  }

  export type job_searchesUncheckedCreateNestedManyWithoutSearchesInput = {
    create?: XOR<job_searchesCreateWithoutSearchesInput, job_searchesUncheckedCreateWithoutSearchesInput> | job_searchesCreateWithoutSearchesInput[] | job_searchesUncheckedCreateWithoutSearchesInput[]
    connectOrCreate?: job_searchesCreateOrConnectWithoutSearchesInput | job_searchesCreateOrConnectWithoutSearchesInput[]
    createMany?: job_searchesCreateManySearchesInputEnvelope
    connect?: job_searchesWhereUniqueInput | job_searchesWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EnumuserstatusFieldUpdateOperationsInput = {
    set?: $Enums.userstatus
  }

  export type user_addressesUpdateManyWithoutUserNestedInput = {
    create?: XOR<user_addressesCreateWithoutUserInput, user_addressesUncheckedCreateWithoutUserInput> | user_addressesCreateWithoutUserInput[] | user_addressesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_addressesCreateOrConnectWithoutUserInput | user_addressesCreateOrConnectWithoutUserInput[]
    upsert?: user_addressesUpsertWithWhereUniqueWithoutUserInput | user_addressesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: user_addressesCreateManyUserInputEnvelope
    set?: user_addressesWhereUniqueInput | user_addressesWhereUniqueInput[]
    disconnect?: user_addressesWhereUniqueInput | user_addressesWhereUniqueInput[]
    delete?: user_addressesWhereUniqueInput | user_addressesWhereUniqueInput[]
    connect?: user_addressesWhereUniqueInput | user_addressesWhereUniqueInput[]
    update?: user_addressesUpdateWithWhereUniqueWithoutUserInput | user_addressesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: user_addressesUpdateManyWithWhereWithoutUserInput | user_addressesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: user_addressesScalarWhereInput | user_addressesScalarWhereInput[]
  }

  export type resumesUpdateManyWithoutUserNestedInput = {
    create?: XOR<resumesCreateWithoutUserInput, resumesUncheckedCreateWithoutUserInput> | resumesCreateWithoutUserInput[] | resumesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: resumesCreateOrConnectWithoutUserInput | resumesCreateOrConnectWithoutUserInput[]
    upsert?: resumesUpsertWithWhereUniqueWithoutUserInput | resumesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: resumesCreateManyUserInputEnvelope
    set?: resumesWhereUniqueInput | resumesWhereUniqueInput[]
    disconnect?: resumesWhereUniqueInput | resumesWhereUniqueInput[]
    delete?: resumesWhereUniqueInput | resumesWhereUniqueInput[]
    connect?: resumesWhereUniqueInput | resumesWhereUniqueInput[]
    update?: resumesUpdateWithWhereUniqueWithoutUserInput | resumesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: resumesUpdateManyWithWhereWithoutUserInput | resumesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: resumesScalarWhereInput | resumesScalarWhereInput[]
  }

  export type educationsUpdateManyWithoutUserNestedInput = {
    create?: XOR<educationsCreateWithoutUserInput, educationsUncheckedCreateWithoutUserInput> | educationsCreateWithoutUserInput[] | educationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: educationsCreateOrConnectWithoutUserInput | educationsCreateOrConnectWithoutUserInput[]
    upsert?: educationsUpsertWithWhereUniqueWithoutUserInput | educationsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: educationsCreateManyUserInputEnvelope
    set?: educationsWhereUniqueInput | educationsWhereUniqueInput[]
    disconnect?: educationsWhereUniqueInput | educationsWhereUniqueInput[]
    delete?: educationsWhereUniqueInput | educationsWhereUniqueInput[]
    connect?: educationsWhereUniqueInput | educationsWhereUniqueInput[]
    update?: educationsUpdateWithWhereUniqueWithoutUserInput | educationsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: educationsUpdateManyWithWhereWithoutUserInput | educationsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: educationsScalarWhereInput | educationsScalarWhereInput[]
  }

  export type work_experiencesUpdateManyWithoutUserNestedInput = {
    create?: XOR<work_experiencesCreateWithoutUserInput, work_experiencesUncheckedCreateWithoutUserInput> | work_experiencesCreateWithoutUserInput[] | work_experiencesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: work_experiencesCreateOrConnectWithoutUserInput | work_experiencesCreateOrConnectWithoutUserInput[]
    upsert?: work_experiencesUpsertWithWhereUniqueWithoutUserInput | work_experiencesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: work_experiencesCreateManyUserInputEnvelope
    set?: work_experiencesWhereUniqueInput | work_experiencesWhereUniqueInput[]
    disconnect?: work_experiencesWhereUniqueInput | work_experiencesWhereUniqueInput[]
    delete?: work_experiencesWhereUniqueInput | work_experiencesWhereUniqueInput[]
    connect?: work_experiencesWhereUniqueInput | work_experiencesWhereUniqueInput[]
    update?: work_experiencesUpdateWithWhereUniqueWithoutUserInput | work_experiencesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: work_experiencesUpdateManyWithWhereWithoutUserInput | work_experiencesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: work_experiencesScalarWhereInput | work_experiencesScalarWhereInput[]
  }

  export type skillsUpdateManyWithoutUserNestedInput = {
    create?: XOR<skillsCreateWithoutUserInput, skillsUncheckedCreateWithoutUserInput> | skillsCreateWithoutUserInput[] | skillsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: skillsCreateOrConnectWithoutUserInput | skillsCreateOrConnectWithoutUserInput[]
    upsert?: skillsUpsertWithWhereUniqueWithoutUserInput | skillsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: skillsCreateManyUserInputEnvelope
    set?: skillsWhereUniqueInput | skillsWhereUniqueInput[]
    disconnect?: skillsWhereUniqueInput | skillsWhereUniqueInput[]
    delete?: skillsWhereUniqueInput | skillsWhereUniqueInput[]
    connect?: skillsWhereUniqueInput | skillsWhereUniqueInput[]
    update?: skillsUpdateWithWhereUniqueWithoutUserInput | skillsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: skillsUpdateManyWithWhereWithoutUserInput | skillsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: skillsScalarWhereInput | skillsScalarWhereInput[]
  }

  export type languagesUpdateManyWithoutUserNestedInput = {
    create?: XOR<languagesCreateWithoutUserInput, languagesUncheckedCreateWithoutUserInput> | languagesCreateWithoutUserInput[] | languagesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: languagesCreateOrConnectWithoutUserInput | languagesCreateOrConnectWithoutUserInput[]
    upsert?: languagesUpsertWithWhereUniqueWithoutUserInput | languagesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: languagesCreateManyUserInputEnvelope
    set?: languagesWhereUniqueInput | languagesWhereUniqueInput[]
    disconnect?: languagesWhereUniqueInput | languagesWhereUniqueInput[]
    delete?: languagesWhereUniqueInput | languagesWhereUniqueInput[]
    connect?: languagesWhereUniqueInput | languagesWhereUniqueInput[]
    update?: languagesUpdateWithWhereUniqueWithoutUserInput | languagesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: languagesUpdateManyWithWhereWithoutUserInput | languagesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: languagesScalarWhereInput | languagesScalarWhereInput[]
  }

  export type certificationsUpdateManyWithoutUserNestedInput = {
    create?: XOR<certificationsCreateWithoutUserInput, certificationsUncheckedCreateWithoutUserInput> | certificationsCreateWithoutUserInput[] | certificationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: certificationsCreateOrConnectWithoutUserInput | certificationsCreateOrConnectWithoutUserInput[]
    upsert?: certificationsUpsertWithWhereUniqueWithoutUserInput | certificationsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: certificationsCreateManyUserInputEnvelope
    set?: certificationsWhereUniqueInput | certificationsWhereUniqueInput[]
    disconnect?: certificationsWhereUniqueInput | certificationsWhereUniqueInput[]
    delete?: certificationsWhereUniqueInput | certificationsWhereUniqueInput[]
    connect?: certificationsWhereUniqueInput | certificationsWhereUniqueInput[]
    update?: certificationsUpdateWithWhereUniqueWithoutUserInput | certificationsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: certificationsUpdateManyWithWhereWithoutUserInput | certificationsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: certificationsScalarWhereInput | certificationsScalarWhereInput[]
  }

  export type visa_informationUpdateManyWithoutVisaNestedInput = {
    create?: XOR<visa_informationCreateWithoutVisaInput, visa_informationUncheckedCreateWithoutVisaInput> | visa_informationCreateWithoutVisaInput[] | visa_informationUncheckedCreateWithoutVisaInput[]
    connectOrCreate?: visa_informationCreateOrConnectWithoutVisaInput | visa_informationCreateOrConnectWithoutVisaInput[]
    upsert?: visa_informationUpsertWithWhereUniqueWithoutVisaInput | visa_informationUpsertWithWhereUniqueWithoutVisaInput[]
    createMany?: visa_informationCreateManyVisaInputEnvelope
    set?: visa_informationWhereUniqueInput | visa_informationWhereUniqueInput[]
    disconnect?: visa_informationWhereUniqueInput | visa_informationWhereUniqueInput[]
    delete?: visa_informationWhereUniqueInput | visa_informationWhereUniqueInput[]
    connect?: visa_informationWhereUniqueInput | visa_informationWhereUniqueInput[]
    update?: visa_informationUpdateWithWhereUniqueWithoutVisaInput | visa_informationUpdateWithWhereUniqueWithoutVisaInput[]
    updateMany?: visa_informationUpdateManyWithWhereWithoutVisaInput | visa_informationUpdateManyWithWhereWithoutVisaInput[]
    deleteMany?: visa_informationScalarWhereInput | visa_informationScalarWhereInput[]
  }

  export type applicationsUpdateManyWithoutAplicationNestedInput = {
    create?: XOR<applicationsCreateWithoutAplicationInput, applicationsUncheckedCreateWithoutAplicationInput> | applicationsCreateWithoutAplicationInput[] | applicationsUncheckedCreateWithoutAplicationInput[]
    connectOrCreate?: applicationsCreateOrConnectWithoutAplicationInput | applicationsCreateOrConnectWithoutAplicationInput[]
    upsert?: applicationsUpsertWithWhereUniqueWithoutAplicationInput | applicationsUpsertWithWhereUniqueWithoutAplicationInput[]
    createMany?: applicationsCreateManyAplicationInputEnvelope
    set?: applicationsWhereUniqueInput | applicationsWhereUniqueInput[]
    disconnect?: applicationsWhereUniqueInput | applicationsWhereUniqueInput[]
    delete?: applicationsWhereUniqueInput | applicationsWhereUniqueInput[]
    connect?: applicationsWhereUniqueInput | applicationsWhereUniqueInput[]
    update?: applicationsUpdateWithWhereUniqueWithoutAplicationInput | applicationsUpdateWithWhereUniqueWithoutAplicationInput[]
    updateMany?: applicationsUpdateManyWithWhereWithoutAplicationInput | applicationsUpdateManyWithWhereWithoutAplicationInput[]
    deleteMany?: applicationsScalarWhereInput | applicationsScalarWhereInput[]
  }

  export type contactsUpdateManyWithoutContactsNestedInput = {
    create?: XOR<contactsCreateWithoutContactsInput, contactsUncheckedCreateWithoutContactsInput> | contactsCreateWithoutContactsInput[] | contactsUncheckedCreateWithoutContactsInput[]
    connectOrCreate?: contactsCreateOrConnectWithoutContactsInput | contactsCreateOrConnectWithoutContactsInput[]
    upsert?: contactsUpsertWithWhereUniqueWithoutContactsInput | contactsUpsertWithWhereUniqueWithoutContactsInput[]
    createMany?: contactsCreateManyContactsInputEnvelope
    set?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    disconnect?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    delete?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    connect?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    update?: contactsUpdateWithWhereUniqueWithoutContactsInput | contactsUpdateWithWhereUniqueWithoutContactsInput[]
    updateMany?: contactsUpdateManyWithWhereWithoutContactsInput | contactsUpdateManyWithWhereWithoutContactsInput[]
    deleteMany?: contactsScalarWhereInput | contactsScalarWhereInput[]
  }

  export type notificationsUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<notificationsCreateWithoutNotificationInput, notificationsUncheckedCreateWithoutNotificationInput> | notificationsCreateWithoutNotificationInput[] | notificationsUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutNotificationInput | notificationsCreateOrConnectWithoutNotificationInput[]
    upsert?: notificationsUpsertWithWhereUniqueWithoutNotificationInput | notificationsUpsertWithWhereUniqueWithoutNotificationInput[]
    createMany?: notificationsCreateManyNotificationInputEnvelope
    set?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    disconnect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    delete?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    update?: notificationsUpdateWithWhereUniqueWithoutNotificationInput | notificationsUpdateWithWhereUniqueWithoutNotificationInput[]
    updateMany?: notificationsUpdateManyWithWhereWithoutNotificationInput | notificationsUpdateManyWithWhereWithoutNotificationInput[]
    deleteMany?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
  }

  export type saved_jobsUpdateManyWithoutSavedjobNestedInput = {
    create?: XOR<saved_jobsCreateWithoutSavedjobInput, saved_jobsUncheckedCreateWithoutSavedjobInput> | saved_jobsCreateWithoutSavedjobInput[] | saved_jobsUncheckedCreateWithoutSavedjobInput[]
    connectOrCreate?: saved_jobsCreateOrConnectWithoutSavedjobInput | saved_jobsCreateOrConnectWithoutSavedjobInput[]
    upsert?: saved_jobsUpsertWithWhereUniqueWithoutSavedjobInput | saved_jobsUpsertWithWhereUniqueWithoutSavedjobInput[]
    createMany?: saved_jobsCreateManySavedjobInputEnvelope
    set?: saved_jobsWhereUniqueInput | saved_jobsWhereUniqueInput[]
    disconnect?: saved_jobsWhereUniqueInput | saved_jobsWhereUniqueInput[]
    delete?: saved_jobsWhereUniqueInput | saved_jobsWhereUniqueInput[]
    connect?: saved_jobsWhereUniqueInput | saved_jobsWhereUniqueInput[]
    update?: saved_jobsUpdateWithWhereUniqueWithoutSavedjobInput | saved_jobsUpdateWithWhereUniqueWithoutSavedjobInput[]
    updateMany?: saved_jobsUpdateManyWithWhereWithoutSavedjobInput | saved_jobsUpdateManyWithWhereWithoutSavedjobInput[]
    deleteMany?: saved_jobsScalarWhereInput | saved_jobsScalarWhereInput[]
  }

  export type job_searchesUpdateManyWithoutSearchesNestedInput = {
    create?: XOR<job_searchesCreateWithoutSearchesInput, job_searchesUncheckedCreateWithoutSearchesInput> | job_searchesCreateWithoutSearchesInput[] | job_searchesUncheckedCreateWithoutSearchesInput[]
    connectOrCreate?: job_searchesCreateOrConnectWithoutSearchesInput | job_searchesCreateOrConnectWithoutSearchesInput[]
    upsert?: job_searchesUpsertWithWhereUniqueWithoutSearchesInput | job_searchesUpsertWithWhereUniqueWithoutSearchesInput[]
    createMany?: job_searchesCreateManySearchesInputEnvelope
    set?: job_searchesWhereUniqueInput | job_searchesWhereUniqueInput[]
    disconnect?: job_searchesWhereUniqueInput | job_searchesWhereUniqueInput[]
    delete?: job_searchesWhereUniqueInput | job_searchesWhereUniqueInput[]
    connect?: job_searchesWhereUniqueInput | job_searchesWhereUniqueInput[]
    update?: job_searchesUpdateWithWhereUniqueWithoutSearchesInput | job_searchesUpdateWithWhereUniqueWithoutSearchesInput[]
    updateMany?: job_searchesUpdateManyWithWhereWithoutSearchesInput | job_searchesUpdateManyWithWhereWithoutSearchesInput[]
    deleteMany?: job_searchesScalarWhereInput | job_searchesScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type user_addressesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<user_addressesCreateWithoutUserInput, user_addressesUncheckedCreateWithoutUserInput> | user_addressesCreateWithoutUserInput[] | user_addressesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_addressesCreateOrConnectWithoutUserInput | user_addressesCreateOrConnectWithoutUserInput[]
    upsert?: user_addressesUpsertWithWhereUniqueWithoutUserInput | user_addressesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: user_addressesCreateManyUserInputEnvelope
    set?: user_addressesWhereUniqueInput | user_addressesWhereUniqueInput[]
    disconnect?: user_addressesWhereUniqueInput | user_addressesWhereUniqueInput[]
    delete?: user_addressesWhereUniqueInput | user_addressesWhereUniqueInput[]
    connect?: user_addressesWhereUniqueInput | user_addressesWhereUniqueInput[]
    update?: user_addressesUpdateWithWhereUniqueWithoutUserInput | user_addressesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: user_addressesUpdateManyWithWhereWithoutUserInput | user_addressesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: user_addressesScalarWhereInput | user_addressesScalarWhereInput[]
  }

  export type resumesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<resumesCreateWithoutUserInput, resumesUncheckedCreateWithoutUserInput> | resumesCreateWithoutUserInput[] | resumesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: resumesCreateOrConnectWithoutUserInput | resumesCreateOrConnectWithoutUserInput[]
    upsert?: resumesUpsertWithWhereUniqueWithoutUserInput | resumesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: resumesCreateManyUserInputEnvelope
    set?: resumesWhereUniqueInput | resumesWhereUniqueInput[]
    disconnect?: resumesWhereUniqueInput | resumesWhereUniqueInput[]
    delete?: resumesWhereUniqueInput | resumesWhereUniqueInput[]
    connect?: resumesWhereUniqueInput | resumesWhereUniqueInput[]
    update?: resumesUpdateWithWhereUniqueWithoutUserInput | resumesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: resumesUpdateManyWithWhereWithoutUserInput | resumesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: resumesScalarWhereInput | resumesScalarWhereInput[]
  }

  export type educationsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<educationsCreateWithoutUserInput, educationsUncheckedCreateWithoutUserInput> | educationsCreateWithoutUserInput[] | educationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: educationsCreateOrConnectWithoutUserInput | educationsCreateOrConnectWithoutUserInput[]
    upsert?: educationsUpsertWithWhereUniqueWithoutUserInput | educationsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: educationsCreateManyUserInputEnvelope
    set?: educationsWhereUniqueInput | educationsWhereUniqueInput[]
    disconnect?: educationsWhereUniqueInput | educationsWhereUniqueInput[]
    delete?: educationsWhereUniqueInput | educationsWhereUniqueInput[]
    connect?: educationsWhereUniqueInput | educationsWhereUniqueInput[]
    update?: educationsUpdateWithWhereUniqueWithoutUserInput | educationsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: educationsUpdateManyWithWhereWithoutUserInput | educationsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: educationsScalarWhereInput | educationsScalarWhereInput[]
  }

  export type work_experiencesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<work_experiencesCreateWithoutUserInput, work_experiencesUncheckedCreateWithoutUserInput> | work_experiencesCreateWithoutUserInput[] | work_experiencesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: work_experiencesCreateOrConnectWithoutUserInput | work_experiencesCreateOrConnectWithoutUserInput[]
    upsert?: work_experiencesUpsertWithWhereUniqueWithoutUserInput | work_experiencesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: work_experiencesCreateManyUserInputEnvelope
    set?: work_experiencesWhereUniqueInput | work_experiencesWhereUniqueInput[]
    disconnect?: work_experiencesWhereUniqueInput | work_experiencesWhereUniqueInput[]
    delete?: work_experiencesWhereUniqueInput | work_experiencesWhereUniqueInput[]
    connect?: work_experiencesWhereUniqueInput | work_experiencesWhereUniqueInput[]
    update?: work_experiencesUpdateWithWhereUniqueWithoutUserInput | work_experiencesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: work_experiencesUpdateManyWithWhereWithoutUserInput | work_experiencesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: work_experiencesScalarWhereInput | work_experiencesScalarWhereInput[]
  }

  export type skillsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<skillsCreateWithoutUserInput, skillsUncheckedCreateWithoutUserInput> | skillsCreateWithoutUserInput[] | skillsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: skillsCreateOrConnectWithoutUserInput | skillsCreateOrConnectWithoutUserInput[]
    upsert?: skillsUpsertWithWhereUniqueWithoutUserInput | skillsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: skillsCreateManyUserInputEnvelope
    set?: skillsWhereUniqueInput | skillsWhereUniqueInput[]
    disconnect?: skillsWhereUniqueInput | skillsWhereUniqueInput[]
    delete?: skillsWhereUniqueInput | skillsWhereUniqueInput[]
    connect?: skillsWhereUniqueInput | skillsWhereUniqueInput[]
    update?: skillsUpdateWithWhereUniqueWithoutUserInput | skillsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: skillsUpdateManyWithWhereWithoutUserInput | skillsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: skillsScalarWhereInput | skillsScalarWhereInput[]
  }

  export type languagesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<languagesCreateWithoutUserInput, languagesUncheckedCreateWithoutUserInput> | languagesCreateWithoutUserInput[] | languagesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: languagesCreateOrConnectWithoutUserInput | languagesCreateOrConnectWithoutUserInput[]
    upsert?: languagesUpsertWithWhereUniqueWithoutUserInput | languagesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: languagesCreateManyUserInputEnvelope
    set?: languagesWhereUniqueInput | languagesWhereUniqueInput[]
    disconnect?: languagesWhereUniqueInput | languagesWhereUniqueInput[]
    delete?: languagesWhereUniqueInput | languagesWhereUniqueInput[]
    connect?: languagesWhereUniqueInput | languagesWhereUniqueInput[]
    update?: languagesUpdateWithWhereUniqueWithoutUserInput | languagesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: languagesUpdateManyWithWhereWithoutUserInput | languagesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: languagesScalarWhereInput | languagesScalarWhereInput[]
  }

  export type certificationsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<certificationsCreateWithoutUserInput, certificationsUncheckedCreateWithoutUserInput> | certificationsCreateWithoutUserInput[] | certificationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: certificationsCreateOrConnectWithoutUserInput | certificationsCreateOrConnectWithoutUserInput[]
    upsert?: certificationsUpsertWithWhereUniqueWithoutUserInput | certificationsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: certificationsCreateManyUserInputEnvelope
    set?: certificationsWhereUniqueInput | certificationsWhereUniqueInput[]
    disconnect?: certificationsWhereUniqueInput | certificationsWhereUniqueInput[]
    delete?: certificationsWhereUniqueInput | certificationsWhereUniqueInput[]
    connect?: certificationsWhereUniqueInput | certificationsWhereUniqueInput[]
    update?: certificationsUpdateWithWhereUniqueWithoutUserInput | certificationsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: certificationsUpdateManyWithWhereWithoutUserInput | certificationsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: certificationsScalarWhereInput | certificationsScalarWhereInput[]
  }

  export type visa_informationUncheckedUpdateManyWithoutVisaNestedInput = {
    create?: XOR<visa_informationCreateWithoutVisaInput, visa_informationUncheckedCreateWithoutVisaInput> | visa_informationCreateWithoutVisaInput[] | visa_informationUncheckedCreateWithoutVisaInput[]
    connectOrCreate?: visa_informationCreateOrConnectWithoutVisaInput | visa_informationCreateOrConnectWithoutVisaInput[]
    upsert?: visa_informationUpsertWithWhereUniqueWithoutVisaInput | visa_informationUpsertWithWhereUniqueWithoutVisaInput[]
    createMany?: visa_informationCreateManyVisaInputEnvelope
    set?: visa_informationWhereUniqueInput | visa_informationWhereUniqueInput[]
    disconnect?: visa_informationWhereUniqueInput | visa_informationWhereUniqueInput[]
    delete?: visa_informationWhereUniqueInput | visa_informationWhereUniqueInput[]
    connect?: visa_informationWhereUniqueInput | visa_informationWhereUniqueInput[]
    update?: visa_informationUpdateWithWhereUniqueWithoutVisaInput | visa_informationUpdateWithWhereUniqueWithoutVisaInput[]
    updateMany?: visa_informationUpdateManyWithWhereWithoutVisaInput | visa_informationUpdateManyWithWhereWithoutVisaInput[]
    deleteMany?: visa_informationScalarWhereInput | visa_informationScalarWhereInput[]
  }

  export type applicationsUncheckedUpdateManyWithoutAplicationNestedInput = {
    create?: XOR<applicationsCreateWithoutAplicationInput, applicationsUncheckedCreateWithoutAplicationInput> | applicationsCreateWithoutAplicationInput[] | applicationsUncheckedCreateWithoutAplicationInput[]
    connectOrCreate?: applicationsCreateOrConnectWithoutAplicationInput | applicationsCreateOrConnectWithoutAplicationInput[]
    upsert?: applicationsUpsertWithWhereUniqueWithoutAplicationInput | applicationsUpsertWithWhereUniqueWithoutAplicationInput[]
    createMany?: applicationsCreateManyAplicationInputEnvelope
    set?: applicationsWhereUniqueInput | applicationsWhereUniqueInput[]
    disconnect?: applicationsWhereUniqueInput | applicationsWhereUniqueInput[]
    delete?: applicationsWhereUniqueInput | applicationsWhereUniqueInput[]
    connect?: applicationsWhereUniqueInput | applicationsWhereUniqueInput[]
    update?: applicationsUpdateWithWhereUniqueWithoutAplicationInput | applicationsUpdateWithWhereUniqueWithoutAplicationInput[]
    updateMany?: applicationsUpdateManyWithWhereWithoutAplicationInput | applicationsUpdateManyWithWhereWithoutAplicationInput[]
    deleteMany?: applicationsScalarWhereInput | applicationsScalarWhereInput[]
  }

  export type contactsUncheckedUpdateManyWithoutContactsNestedInput = {
    create?: XOR<contactsCreateWithoutContactsInput, contactsUncheckedCreateWithoutContactsInput> | contactsCreateWithoutContactsInput[] | contactsUncheckedCreateWithoutContactsInput[]
    connectOrCreate?: contactsCreateOrConnectWithoutContactsInput | contactsCreateOrConnectWithoutContactsInput[]
    upsert?: contactsUpsertWithWhereUniqueWithoutContactsInput | contactsUpsertWithWhereUniqueWithoutContactsInput[]
    createMany?: contactsCreateManyContactsInputEnvelope
    set?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    disconnect?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    delete?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    connect?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    update?: contactsUpdateWithWhereUniqueWithoutContactsInput | contactsUpdateWithWhereUniqueWithoutContactsInput[]
    updateMany?: contactsUpdateManyWithWhereWithoutContactsInput | contactsUpdateManyWithWhereWithoutContactsInput[]
    deleteMany?: contactsScalarWhereInput | contactsScalarWhereInput[]
  }

  export type notificationsUncheckedUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<notificationsCreateWithoutNotificationInput, notificationsUncheckedCreateWithoutNotificationInput> | notificationsCreateWithoutNotificationInput[] | notificationsUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutNotificationInput | notificationsCreateOrConnectWithoutNotificationInput[]
    upsert?: notificationsUpsertWithWhereUniqueWithoutNotificationInput | notificationsUpsertWithWhereUniqueWithoutNotificationInput[]
    createMany?: notificationsCreateManyNotificationInputEnvelope
    set?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    disconnect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    delete?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    update?: notificationsUpdateWithWhereUniqueWithoutNotificationInput | notificationsUpdateWithWhereUniqueWithoutNotificationInput[]
    updateMany?: notificationsUpdateManyWithWhereWithoutNotificationInput | notificationsUpdateManyWithWhereWithoutNotificationInput[]
    deleteMany?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
  }

  export type saved_jobsUncheckedUpdateManyWithoutSavedjobNestedInput = {
    create?: XOR<saved_jobsCreateWithoutSavedjobInput, saved_jobsUncheckedCreateWithoutSavedjobInput> | saved_jobsCreateWithoutSavedjobInput[] | saved_jobsUncheckedCreateWithoutSavedjobInput[]
    connectOrCreate?: saved_jobsCreateOrConnectWithoutSavedjobInput | saved_jobsCreateOrConnectWithoutSavedjobInput[]
    upsert?: saved_jobsUpsertWithWhereUniqueWithoutSavedjobInput | saved_jobsUpsertWithWhereUniqueWithoutSavedjobInput[]
    createMany?: saved_jobsCreateManySavedjobInputEnvelope
    set?: saved_jobsWhereUniqueInput | saved_jobsWhereUniqueInput[]
    disconnect?: saved_jobsWhereUniqueInput | saved_jobsWhereUniqueInput[]
    delete?: saved_jobsWhereUniqueInput | saved_jobsWhereUniqueInput[]
    connect?: saved_jobsWhereUniqueInput | saved_jobsWhereUniqueInput[]
    update?: saved_jobsUpdateWithWhereUniqueWithoutSavedjobInput | saved_jobsUpdateWithWhereUniqueWithoutSavedjobInput[]
    updateMany?: saved_jobsUpdateManyWithWhereWithoutSavedjobInput | saved_jobsUpdateManyWithWhereWithoutSavedjobInput[]
    deleteMany?: saved_jobsScalarWhereInput | saved_jobsScalarWhereInput[]
  }

  export type job_searchesUncheckedUpdateManyWithoutSearchesNestedInput = {
    create?: XOR<job_searchesCreateWithoutSearchesInput, job_searchesUncheckedCreateWithoutSearchesInput> | job_searchesCreateWithoutSearchesInput[] | job_searchesUncheckedCreateWithoutSearchesInput[]
    connectOrCreate?: job_searchesCreateOrConnectWithoutSearchesInput | job_searchesCreateOrConnectWithoutSearchesInput[]
    upsert?: job_searchesUpsertWithWhereUniqueWithoutSearchesInput | job_searchesUpsertWithWhereUniqueWithoutSearchesInput[]
    createMany?: job_searchesCreateManySearchesInputEnvelope
    set?: job_searchesWhereUniqueInput | job_searchesWhereUniqueInput[]
    disconnect?: job_searchesWhereUniqueInput | job_searchesWhereUniqueInput[]
    delete?: job_searchesWhereUniqueInput | job_searchesWhereUniqueInput[]
    connect?: job_searchesWhereUniqueInput | job_searchesWhereUniqueInput[]
    update?: job_searchesUpdateWithWhereUniqueWithoutSearchesInput | job_searchesUpdateWithWhereUniqueWithoutSearchesInput[]
    updateMany?: job_searchesUpdateManyWithWhereWithoutSearchesInput | job_searchesUpdateManyWithWhereWithoutSearchesInput[]
    deleteMany?: job_searchesScalarWhereInput | job_searchesScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutAddressesInput = {
    create?: XOR<usersCreateWithoutAddressesInput, usersUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: usersCreateOrConnectWithoutAddressesInput
    connect?: usersWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type usersUpdateOneRequiredWithoutAddressesNestedInput = {
    create?: XOR<usersCreateWithoutAddressesInput, usersUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: usersCreateOrConnectWithoutAddressesInput
    upsert?: usersUpsertWithoutAddressesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutAddressesInput, usersUpdateWithoutAddressesInput>, usersUncheckedUpdateWithoutAddressesInput>
  }

  export type applicationsCreateNestedManyWithoutApplicationsInput = {
    create?: XOR<applicationsCreateWithoutApplicationsInput, applicationsUncheckedCreateWithoutApplicationsInput> | applicationsCreateWithoutApplicationsInput[] | applicationsUncheckedCreateWithoutApplicationsInput[]
    connectOrCreate?: applicationsCreateOrConnectWithoutApplicationsInput | applicationsCreateOrConnectWithoutApplicationsInput[]
    createMany?: applicationsCreateManyApplicationsInputEnvelope
    connect?: applicationsWhereUniqueInput | applicationsWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutResumesInput = {
    create?: XOR<usersCreateWithoutResumesInput, usersUncheckedCreateWithoutResumesInput>
    connectOrCreate?: usersCreateOrConnectWithoutResumesInput
    connect?: usersWhereUniqueInput
  }

  export type applicationsUncheckedCreateNestedManyWithoutApplicationsInput = {
    create?: XOR<applicationsCreateWithoutApplicationsInput, applicationsUncheckedCreateWithoutApplicationsInput> | applicationsCreateWithoutApplicationsInput[] | applicationsUncheckedCreateWithoutApplicationsInput[]
    connectOrCreate?: applicationsCreateOrConnectWithoutApplicationsInput | applicationsCreateOrConnectWithoutApplicationsInput[]
    createMany?: applicationsCreateManyApplicationsInputEnvelope
    connect?: applicationsWhereUniqueInput | applicationsWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type applicationsUpdateManyWithoutApplicationsNestedInput = {
    create?: XOR<applicationsCreateWithoutApplicationsInput, applicationsUncheckedCreateWithoutApplicationsInput> | applicationsCreateWithoutApplicationsInput[] | applicationsUncheckedCreateWithoutApplicationsInput[]
    connectOrCreate?: applicationsCreateOrConnectWithoutApplicationsInput | applicationsCreateOrConnectWithoutApplicationsInput[]
    upsert?: applicationsUpsertWithWhereUniqueWithoutApplicationsInput | applicationsUpsertWithWhereUniqueWithoutApplicationsInput[]
    createMany?: applicationsCreateManyApplicationsInputEnvelope
    set?: applicationsWhereUniqueInput | applicationsWhereUniqueInput[]
    disconnect?: applicationsWhereUniqueInput | applicationsWhereUniqueInput[]
    delete?: applicationsWhereUniqueInput | applicationsWhereUniqueInput[]
    connect?: applicationsWhereUniqueInput | applicationsWhereUniqueInput[]
    update?: applicationsUpdateWithWhereUniqueWithoutApplicationsInput | applicationsUpdateWithWhereUniqueWithoutApplicationsInput[]
    updateMany?: applicationsUpdateManyWithWhereWithoutApplicationsInput | applicationsUpdateManyWithWhereWithoutApplicationsInput[]
    deleteMany?: applicationsScalarWhereInput | applicationsScalarWhereInput[]
  }

  export type usersUpdateOneRequiredWithoutResumesNestedInput = {
    create?: XOR<usersCreateWithoutResumesInput, usersUncheckedCreateWithoutResumesInput>
    connectOrCreate?: usersCreateOrConnectWithoutResumesInput
    upsert?: usersUpsertWithoutResumesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutResumesInput, usersUpdateWithoutResumesInput>, usersUncheckedUpdateWithoutResumesInput>
  }

  export type applicationsUncheckedUpdateManyWithoutApplicationsNestedInput = {
    create?: XOR<applicationsCreateWithoutApplicationsInput, applicationsUncheckedCreateWithoutApplicationsInput> | applicationsCreateWithoutApplicationsInput[] | applicationsUncheckedCreateWithoutApplicationsInput[]
    connectOrCreate?: applicationsCreateOrConnectWithoutApplicationsInput | applicationsCreateOrConnectWithoutApplicationsInput[]
    upsert?: applicationsUpsertWithWhereUniqueWithoutApplicationsInput | applicationsUpsertWithWhereUniqueWithoutApplicationsInput[]
    createMany?: applicationsCreateManyApplicationsInputEnvelope
    set?: applicationsWhereUniqueInput | applicationsWhereUniqueInput[]
    disconnect?: applicationsWhereUniqueInput | applicationsWhereUniqueInput[]
    delete?: applicationsWhereUniqueInput | applicationsWhereUniqueInput[]
    connect?: applicationsWhereUniqueInput | applicationsWhereUniqueInput[]
    update?: applicationsUpdateWithWhereUniqueWithoutApplicationsInput | applicationsUpdateWithWhereUniqueWithoutApplicationsInput[]
    updateMany?: applicationsUpdateManyWithWhereWithoutApplicationsInput | applicationsUpdateManyWithWhereWithoutApplicationsInput[]
    deleteMany?: applicationsScalarWhereInput | applicationsScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutEducationsInput = {
    create?: XOR<usersCreateWithoutEducationsInput, usersUncheckedCreateWithoutEducationsInput>
    connectOrCreate?: usersCreateOrConnectWithoutEducationsInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutEducationsNestedInput = {
    create?: XOR<usersCreateWithoutEducationsInput, usersUncheckedCreateWithoutEducationsInput>
    connectOrCreate?: usersCreateOrConnectWithoutEducationsInput
    upsert?: usersUpsertWithoutEducationsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutEducationsInput, usersUpdateWithoutEducationsInput>, usersUncheckedUpdateWithoutEducationsInput>
  }

  export type usersCreateNestedOneWithoutExperiencesInput = {
    create?: XOR<usersCreateWithoutExperiencesInput, usersUncheckedCreateWithoutExperiencesInput>
    connectOrCreate?: usersCreateOrConnectWithoutExperiencesInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutExperiencesNestedInput = {
    create?: XOR<usersCreateWithoutExperiencesInput, usersUncheckedCreateWithoutExperiencesInput>
    connectOrCreate?: usersCreateOrConnectWithoutExperiencesInput
    upsert?: usersUpsertWithoutExperiencesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutExperiencesInput, usersUpdateWithoutExperiencesInput>, usersUncheckedUpdateWithoutExperiencesInput>
  }

  export type usersCreateNestedOneWithoutSkillsInput = {
    create?: XOR<usersCreateWithoutSkillsInput, usersUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: usersCreateOrConnectWithoutSkillsInput
    connect?: usersWhereUniqueInput
  }

  export type EnumskillsstatusFieldUpdateOperationsInput = {
    set?: $Enums.skillsstatus
  }

  export type usersUpdateOneRequiredWithoutSkillsNestedInput = {
    create?: XOR<usersCreateWithoutSkillsInput, usersUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: usersCreateOrConnectWithoutSkillsInput
    upsert?: usersUpsertWithoutSkillsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutSkillsInput, usersUpdateWithoutSkillsInput>, usersUncheckedUpdateWithoutSkillsInput>
  }

  export type usersCreateNestedOneWithoutLanguagesInput = {
    create?: XOR<usersCreateWithoutLanguagesInput, usersUncheckedCreateWithoutLanguagesInput>
    connectOrCreate?: usersCreateOrConnectWithoutLanguagesInput
    connect?: usersWhereUniqueInput
  }

  export type EnumproficiencylanguagesFieldUpdateOperationsInput = {
    set?: $Enums.proficiencylanguages
  }

  export type usersUpdateOneRequiredWithoutLanguagesNestedInput = {
    create?: XOR<usersCreateWithoutLanguagesInput, usersUncheckedCreateWithoutLanguagesInput>
    connectOrCreate?: usersCreateOrConnectWithoutLanguagesInput
    upsert?: usersUpsertWithoutLanguagesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutLanguagesInput, usersUpdateWithoutLanguagesInput>, usersUncheckedUpdateWithoutLanguagesInput>
  }

  export type usersCreateNestedOneWithoutCertificationsInput = {
    create?: XOR<usersCreateWithoutCertificationsInput, usersUncheckedCreateWithoutCertificationsInput>
    connectOrCreate?: usersCreateOrConnectWithoutCertificationsInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutCertificationsNestedInput = {
    create?: XOR<usersCreateWithoutCertificationsInput, usersUncheckedCreateWithoutCertificationsInput>
    connectOrCreate?: usersCreateOrConnectWithoutCertificationsInput
    upsert?: usersUpsertWithoutCertificationsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutCertificationsInput, usersUpdateWithoutCertificationsInput>, usersUncheckedUpdateWithoutCertificationsInput>
  }

  export type usersCreateNestedOneWithoutVisaInput = {
    create?: XOR<usersCreateWithoutVisaInput, usersUncheckedCreateWithoutVisaInput>
    connectOrCreate?: usersCreateOrConnectWithoutVisaInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutVisaNestedInput = {
    create?: XOR<usersCreateWithoutVisaInput, usersUncheckedCreateWithoutVisaInput>
    connectOrCreate?: usersCreateOrConnectWithoutVisaInput
    upsert?: usersUpsertWithoutVisaInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutVisaInput, usersUpdateWithoutVisaInput>, usersUncheckedUpdateWithoutVisaInput>
  }

  export type company_locationsCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<company_locationsCreateWithoutCompaniesInput, company_locationsUncheckedCreateWithoutCompaniesInput> | company_locationsCreateWithoutCompaniesInput[] | company_locationsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: company_locationsCreateOrConnectWithoutCompaniesInput | company_locationsCreateOrConnectWithoutCompaniesInput[]
    createMany?: company_locationsCreateManyCompaniesInputEnvelope
    connect?: company_locationsWhereUniqueInput | company_locationsWhereUniqueInput[]
  }

  export type jobsCreateNestedManyWithoutJobInput = {
    create?: XOR<jobsCreateWithoutJobInput, jobsUncheckedCreateWithoutJobInput> | jobsCreateWithoutJobInput[] | jobsUncheckedCreateWithoutJobInput[]
    connectOrCreate?: jobsCreateOrConnectWithoutJobInput | jobsCreateOrConnectWithoutJobInput[]
    createMany?: jobsCreateManyJobInputEnvelope
    connect?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
  }

  export type contactsCreateNestedManyWithoutContacInput = {
    create?: XOR<contactsCreateWithoutContacInput, contactsUncheckedCreateWithoutContacInput> | contactsCreateWithoutContacInput[] | contactsUncheckedCreateWithoutContacInput[]
    connectOrCreate?: contactsCreateOrConnectWithoutContacInput | contactsCreateOrConnectWithoutContacInput[]
    createMany?: contactsCreateManyContacInputEnvelope
    connect?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
  }

  export type company_locationsUncheckedCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<company_locationsCreateWithoutCompaniesInput, company_locationsUncheckedCreateWithoutCompaniesInput> | company_locationsCreateWithoutCompaniesInput[] | company_locationsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: company_locationsCreateOrConnectWithoutCompaniesInput | company_locationsCreateOrConnectWithoutCompaniesInput[]
    createMany?: company_locationsCreateManyCompaniesInputEnvelope
    connect?: company_locationsWhereUniqueInput | company_locationsWhereUniqueInput[]
  }

  export type jobsUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<jobsCreateWithoutJobInput, jobsUncheckedCreateWithoutJobInput> | jobsCreateWithoutJobInput[] | jobsUncheckedCreateWithoutJobInput[]
    connectOrCreate?: jobsCreateOrConnectWithoutJobInput | jobsCreateOrConnectWithoutJobInput[]
    createMany?: jobsCreateManyJobInputEnvelope
    connect?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
  }

  export type contactsUncheckedCreateNestedManyWithoutContacInput = {
    create?: XOR<contactsCreateWithoutContacInput, contactsUncheckedCreateWithoutContacInput> | contactsCreateWithoutContacInput[] | contactsUncheckedCreateWithoutContacInput[]
    connectOrCreate?: contactsCreateOrConnectWithoutContacInput | contactsCreateOrConnectWithoutContacInput[]
    createMany?: contactsCreateManyContacInputEnvelope
    connect?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
  }

  export type EnumcompanySizeFieldUpdateOperationsInput = {
    set?: $Enums.companySize
  }

  export type company_locationsUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<company_locationsCreateWithoutCompaniesInput, company_locationsUncheckedCreateWithoutCompaniesInput> | company_locationsCreateWithoutCompaniesInput[] | company_locationsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: company_locationsCreateOrConnectWithoutCompaniesInput | company_locationsCreateOrConnectWithoutCompaniesInput[]
    upsert?: company_locationsUpsertWithWhereUniqueWithoutCompaniesInput | company_locationsUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: company_locationsCreateManyCompaniesInputEnvelope
    set?: company_locationsWhereUniqueInput | company_locationsWhereUniqueInput[]
    disconnect?: company_locationsWhereUniqueInput | company_locationsWhereUniqueInput[]
    delete?: company_locationsWhereUniqueInput | company_locationsWhereUniqueInput[]
    connect?: company_locationsWhereUniqueInput | company_locationsWhereUniqueInput[]
    update?: company_locationsUpdateWithWhereUniqueWithoutCompaniesInput | company_locationsUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: company_locationsUpdateManyWithWhereWithoutCompaniesInput | company_locationsUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: company_locationsScalarWhereInput | company_locationsScalarWhereInput[]
  }

  export type jobsUpdateManyWithoutJobNestedInput = {
    create?: XOR<jobsCreateWithoutJobInput, jobsUncheckedCreateWithoutJobInput> | jobsCreateWithoutJobInput[] | jobsUncheckedCreateWithoutJobInput[]
    connectOrCreate?: jobsCreateOrConnectWithoutJobInput | jobsCreateOrConnectWithoutJobInput[]
    upsert?: jobsUpsertWithWhereUniqueWithoutJobInput | jobsUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: jobsCreateManyJobInputEnvelope
    set?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    disconnect?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    delete?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    connect?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    update?: jobsUpdateWithWhereUniqueWithoutJobInput | jobsUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: jobsUpdateManyWithWhereWithoutJobInput | jobsUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: jobsScalarWhereInput | jobsScalarWhereInput[]
  }

  export type contactsUpdateManyWithoutContacNestedInput = {
    create?: XOR<contactsCreateWithoutContacInput, contactsUncheckedCreateWithoutContacInput> | contactsCreateWithoutContacInput[] | contactsUncheckedCreateWithoutContacInput[]
    connectOrCreate?: contactsCreateOrConnectWithoutContacInput | contactsCreateOrConnectWithoutContacInput[]
    upsert?: contactsUpsertWithWhereUniqueWithoutContacInput | contactsUpsertWithWhereUniqueWithoutContacInput[]
    createMany?: contactsCreateManyContacInputEnvelope
    set?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    disconnect?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    delete?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    connect?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    update?: contactsUpdateWithWhereUniqueWithoutContacInput | contactsUpdateWithWhereUniqueWithoutContacInput[]
    updateMany?: contactsUpdateManyWithWhereWithoutContacInput | contactsUpdateManyWithWhereWithoutContacInput[]
    deleteMany?: contactsScalarWhereInput | contactsScalarWhereInput[]
  }

  export type company_locationsUncheckedUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<company_locationsCreateWithoutCompaniesInput, company_locationsUncheckedCreateWithoutCompaniesInput> | company_locationsCreateWithoutCompaniesInput[] | company_locationsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: company_locationsCreateOrConnectWithoutCompaniesInput | company_locationsCreateOrConnectWithoutCompaniesInput[]
    upsert?: company_locationsUpsertWithWhereUniqueWithoutCompaniesInput | company_locationsUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: company_locationsCreateManyCompaniesInputEnvelope
    set?: company_locationsWhereUniqueInput | company_locationsWhereUniqueInput[]
    disconnect?: company_locationsWhereUniqueInput | company_locationsWhereUniqueInput[]
    delete?: company_locationsWhereUniqueInput | company_locationsWhereUniqueInput[]
    connect?: company_locationsWhereUniqueInput | company_locationsWhereUniqueInput[]
    update?: company_locationsUpdateWithWhereUniqueWithoutCompaniesInput | company_locationsUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: company_locationsUpdateManyWithWhereWithoutCompaniesInput | company_locationsUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: company_locationsScalarWhereInput | company_locationsScalarWhereInput[]
  }

  export type jobsUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<jobsCreateWithoutJobInput, jobsUncheckedCreateWithoutJobInput> | jobsCreateWithoutJobInput[] | jobsUncheckedCreateWithoutJobInput[]
    connectOrCreate?: jobsCreateOrConnectWithoutJobInput | jobsCreateOrConnectWithoutJobInput[]
    upsert?: jobsUpsertWithWhereUniqueWithoutJobInput | jobsUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: jobsCreateManyJobInputEnvelope
    set?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    disconnect?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    delete?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    connect?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    update?: jobsUpdateWithWhereUniqueWithoutJobInput | jobsUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: jobsUpdateManyWithWhereWithoutJobInput | jobsUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: jobsScalarWhereInput | jobsScalarWhereInput[]
  }

  export type contactsUncheckedUpdateManyWithoutContacNestedInput = {
    create?: XOR<contactsCreateWithoutContacInput, contactsUncheckedCreateWithoutContacInput> | contactsCreateWithoutContacInput[] | contactsUncheckedCreateWithoutContacInput[]
    connectOrCreate?: contactsCreateOrConnectWithoutContacInput | contactsCreateOrConnectWithoutContacInput[]
    upsert?: contactsUpsertWithWhereUniqueWithoutContacInput | contactsUpsertWithWhereUniqueWithoutContacInput[]
    createMany?: contactsCreateManyContacInputEnvelope
    set?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    disconnect?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    delete?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    connect?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    update?: contactsUpdateWithWhereUniqueWithoutContacInput | contactsUpdateWithWhereUniqueWithoutContacInput[]
    updateMany?: contactsUpdateManyWithWhereWithoutContacInput | contactsUpdateManyWithWhereWithoutContacInput[]
    deleteMany?: contactsScalarWhereInput | contactsScalarWhereInput[]
  }

  export type companiesCreateNestedOneWithoutCompaniesInput = {
    create?: XOR<companiesCreateWithoutCompaniesInput, companiesUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: companiesCreateOrConnectWithoutCompaniesInput
    connect?: companiesWhereUniqueInput
  }

  export type companiesUpdateOneRequiredWithoutCompaniesNestedInput = {
    create?: XOR<companiesCreateWithoutCompaniesInput, companiesUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: companiesCreateOrConnectWithoutCompaniesInput
    upsert?: companiesUpsertWithoutCompaniesInput
    connect?: companiesWhereUniqueInput
    update?: XOR<XOR<companiesUpdateToOneWithWhereWithoutCompaniesInput, companiesUpdateWithoutCompaniesInput>, companiesUncheckedUpdateWithoutCompaniesInput>
  }

  export type companiesCreateNestedOneWithoutJobInput = {
    create?: XOR<companiesCreateWithoutJobInput, companiesUncheckedCreateWithoutJobInput>
    connectOrCreate?: companiesCreateOrConnectWithoutJobInput
    connect?: companiesWhereUniqueInput
  }

  export type job_requirementsCreateNestedManyWithoutRequirementsInput = {
    create?: XOR<job_requirementsCreateWithoutRequirementsInput, job_requirementsUncheckedCreateWithoutRequirementsInput> | job_requirementsCreateWithoutRequirementsInput[] | job_requirementsUncheckedCreateWithoutRequirementsInput[]
    connectOrCreate?: job_requirementsCreateOrConnectWithoutRequirementsInput | job_requirementsCreateOrConnectWithoutRequirementsInput[]
    createMany?: job_requirementsCreateManyRequirementsInputEnvelope
    connect?: job_requirementsWhereUniqueInput | job_requirementsWhereUniqueInput[]
  }

  export type job_responsibilitesCreateNestedManyWithoutResponsibilitesInput = {
    create?: XOR<job_responsibilitesCreateWithoutResponsibilitesInput, job_responsibilitesUncheckedCreateWithoutResponsibilitesInput> | job_responsibilitesCreateWithoutResponsibilitesInput[] | job_responsibilitesUncheckedCreateWithoutResponsibilitesInput[]
    connectOrCreate?: job_responsibilitesCreateOrConnectWithoutResponsibilitesInput | job_responsibilitesCreateOrConnectWithoutResponsibilitesInput[]
    createMany?: job_responsibilitesCreateManyResponsibilitesInputEnvelope
    connect?: job_responsibilitesWhereUniqueInput | job_responsibilitesWhereUniqueInput[]
  }

  export type job_benefitsCreateNestedManyWithoutBenefitsInput = {
    create?: XOR<job_benefitsCreateWithoutBenefitsInput, job_benefitsUncheckedCreateWithoutBenefitsInput> | job_benefitsCreateWithoutBenefitsInput[] | job_benefitsUncheckedCreateWithoutBenefitsInput[]
    connectOrCreate?: job_benefitsCreateOrConnectWithoutBenefitsInput | job_benefitsCreateOrConnectWithoutBenefitsInput[]
    createMany?: job_benefitsCreateManyBenefitsInputEnvelope
    connect?: job_benefitsWhereUniqueInput | job_benefitsWhereUniqueInput[]
  }

  export type applicationsCreateNestedManyWithoutApplicationInput = {
    create?: XOR<applicationsCreateWithoutApplicationInput, applicationsUncheckedCreateWithoutApplicationInput> | applicationsCreateWithoutApplicationInput[] | applicationsUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: applicationsCreateOrConnectWithoutApplicationInput | applicationsCreateOrConnectWithoutApplicationInput[]
    createMany?: applicationsCreateManyApplicationInputEnvelope
    connect?: applicationsWhereUniqueInput | applicationsWhereUniqueInput[]
  }

  export type contactsCreateNestedManyWithoutContactInput = {
    create?: XOR<contactsCreateWithoutContactInput, contactsUncheckedCreateWithoutContactInput> | contactsCreateWithoutContactInput[] | contactsUncheckedCreateWithoutContactInput[]
    connectOrCreate?: contactsCreateOrConnectWithoutContactInput | contactsCreateOrConnectWithoutContactInput[]
    createMany?: contactsCreateManyContactInputEnvelope
    connect?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
  }

  export type saved_jobsCreateNestedManyWithoutSavedjobsInput = {
    create?: XOR<saved_jobsCreateWithoutSavedjobsInput, saved_jobsUncheckedCreateWithoutSavedjobsInput> | saved_jobsCreateWithoutSavedjobsInput[] | saved_jobsUncheckedCreateWithoutSavedjobsInput[]
    connectOrCreate?: saved_jobsCreateOrConnectWithoutSavedjobsInput | saved_jobsCreateOrConnectWithoutSavedjobsInput[]
    createMany?: saved_jobsCreateManySavedjobsInputEnvelope
    connect?: saved_jobsWhereUniqueInput | saved_jobsWhereUniqueInput[]
  }

  export type job_requirementsUncheckedCreateNestedManyWithoutRequirementsInput = {
    create?: XOR<job_requirementsCreateWithoutRequirementsInput, job_requirementsUncheckedCreateWithoutRequirementsInput> | job_requirementsCreateWithoutRequirementsInput[] | job_requirementsUncheckedCreateWithoutRequirementsInput[]
    connectOrCreate?: job_requirementsCreateOrConnectWithoutRequirementsInput | job_requirementsCreateOrConnectWithoutRequirementsInput[]
    createMany?: job_requirementsCreateManyRequirementsInputEnvelope
    connect?: job_requirementsWhereUniqueInput | job_requirementsWhereUniqueInput[]
  }

  export type job_responsibilitesUncheckedCreateNestedManyWithoutResponsibilitesInput = {
    create?: XOR<job_responsibilitesCreateWithoutResponsibilitesInput, job_responsibilitesUncheckedCreateWithoutResponsibilitesInput> | job_responsibilitesCreateWithoutResponsibilitesInput[] | job_responsibilitesUncheckedCreateWithoutResponsibilitesInput[]
    connectOrCreate?: job_responsibilitesCreateOrConnectWithoutResponsibilitesInput | job_responsibilitesCreateOrConnectWithoutResponsibilitesInput[]
    createMany?: job_responsibilitesCreateManyResponsibilitesInputEnvelope
    connect?: job_responsibilitesWhereUniqueInput | job_responsibilitesWhereUniqueInput[]
  }

  export type job_benefitsUncheckedCreateNestedManyWithoutBenefitsInput = {
    create?: XOR<job_benefitsCreateWithoutBenefitsInput, job_benefitsUncheckedCreateWithoutBenefitsInput> | job_benefitsCreateWithoutBenefitsInput[] | job_benefitsUncheckedCreateWithoutBenefitsInput[]
    connectOrCreate?: job_benefitsCreateOrConnectWithoutBenefitsInput | job_benefitsCreateOrConnectWithoutBenefitsInput[]
    createMany?: job_benefitsCreateManyBenefitsInputEnvelope
    connect?: job_benefitsWhereUniqueInput | job_benefitsWhereUniqueInput[]
  }

  export type applicationsUncheckedCreateNestedManyWithoutApplicationInput = {
    create?: XOR<applicationsCreateWithoutApplicationInput, applicationsUncheckedCreateWithoutApplicationInput> | applicationsCreateWithoutApplicationInput[] | applicationsUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: applicationsCreateOrConnectWithoutApplicationInput | applicationsCreateOrConnectWithoutApplicationInput[]
    createMany?: applicationsCreateManyApplicationInputEnvelope
    connect?: applicationsWhereUniqueInput | applicationsWhereUniqueInput[]
  }

  export type contactsUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<contactsCreateWithoutContactInput, contactsUncheckedCreateWithoutContactInput> | contactsCreateWithoutContactInput[] | contactsUncheckedCreateWithoutContactInput[]
    connectOrCreate?: contactsCreateOrConnectWithoutContactInput | contactsCreateOrConnectWithoutContactInput[]
    createMany?: contactsCreateManyContactInputEnvelope
    connect?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
  }

  export type saved_jobsUncheckedCreateNestedManyWithoutSavedjobsInput = {
    create?: XOR<saved_jobsCreateWithoutSavedjobsInput, saved_jobsUncheckedCreateWithoutSavedjobsInput> | saved_jobsCreateWithoutSavedjobsInput[] | saved_jobsUncheckedCreateWithoutSavedjobsInput[]
    connectOrCreate?: saved_jobsCreateOrConnectWithoutSavedjobsInput | saved_jobsCreateOrConnectWithoutSavedjobsInput[]
    createMany?: saved_jobsCreateManySavedjobsInputEnvelope
    connect?: saved_jobsWhereUniqueInput | saved_jobsWhereUniqueInput[]
  }

  export type EnumjobTypeFieldUpdateOperationsInput = {
    set?: $Enums.jobType
  }

  export type EnumsalaryPeriodFieldUpdateOperationsInput = {
    set?: $Enums.salaryPeriod
  }

  export type EnumvisaSponsorshipFieldUpdateOperationsInput = {
    set?: $Enums.visaSponsorship
  }

  export type EnumexpLevelFieldUpdateOperationsInput = {
    set?: $Enums.expLevel
  }

  export type EnumjobStatusFieldUpdateOperationsInput = {
    set?: $Enums.jobStatus
  }

  export type companiesUpdateOneRequiredWithoutJobNestedInput = {
    create?: XOR<companiesCreateWithoutJobInput, companiesUncheckedCreateWithoutJobInput>
    connectOrCreate?: companiesCreateOrConnectWithoutJobInput
    upsert?: companiesUpsertWithoutJobInput
    connect?: companiesWhereUniqueInput
    update?: XOR<XOR<companiesUpdateToOneWithWhereWithoutJobInput, companiesUpdateWithoutJobInput>, companiesUncheckedUpdateWithoutJobInput>
  }

  export type job_requirementsUpdateManyWithoutRequirementsNestedInput = {
    create?: XOR<job_requirementsCreateWithoutRequirementsInput, job_requirementsUncheckedCreateWithoutRequirementsInput> | job_requirementsCreateWithoutRequirementsInput[] | job_requirementsUncheckedCreateWithoutRequirementsInput[]
    connectOrCreate?: job_requirementsCreateOrConnectWithoutRequirementsInput | job_requirementsCreateOrConnectWithoutRequirementsInput[]
    upsert?: job_requirementsUpsertWithWhereUniqueWithoutRequirementsInput | job_requirementsUpsertWithWhereUniqueWithoutRequirementsInput[]
    createMany?: job_requirementsCreateManyRequirementsInputEnvelope
    set?: job_requirementsWhereUniqueInput | job_requirementsWhereUniqueInput[]
    disconnect?: job_requirementsWhereUniqueInput | job_requirementsWhereUniqueInput[]
    delete?: job_requirementsWhereUniqueInput | job_requirementsWhereUniqueInput[]
    connect?: job_requirementsWhereUniqueInput | job_requirementsWhereUniqueInput[]
    update?: job_requirementsUpdateWithWhereUniqueWithoutRequirementsInput | job_requirementsUpdateWithWhereUniqueWithoutRequirementsInput[]
    updateMany?: job_requirementsUpdateManyWithWhereWithoutRequirementsInput | job_requirementsUpdateManyWithWhereWithoutRequirementsInput[]
    deleteMany?: job_requirementsScalarWhereInput | job_requirementsScalarWhereInput[]
  }

  export type job_responsibilitesUpdateManyWithoutResponsibilitesNestedInput = {
    create?: XOR<job_responsibilitesCreateWithoutResponsibilitesInput, job_responsibilitesUncheckedCreateWithoutResponsibilitesInput> | job_responsibilitesCreateWithoutResponsibilitesInput[] | job_responsibilitesUncheckedCreateWithoutResponsibilitesInput[]
    connectOrCreate?: job_responsibilitesCreateOrConnectWithoutResponsibilitesInput | job_responsibilitesCreateOrConnectWithoutResponsibilitesInput[]
    upsert?: job_responsibilitesUpsertWithWhereUniqueWithoutResponsibilitesInput | job_responsibilitesUpsertWithWhereUniqueWithoutResponsibilitesInput[]
    createMany?: job_responsibilitesCreateManyResponsibilitesInputEnvelope
    set?: job_responsibilitesWhereUniqueInput | job_responsibilitesWhereUniqueInput[]
    disconnect?: job_responsibilitesWhereUniqueInput | job_responsibilitesWhereUniqueInput[]
    delete?: job_responsibilitesWhereUniqueInput | job_responsibilitesWhereUniqueInput[]
    connect?: job_responsibilitesWhereUniqueInput | job_responsibilitesWhereUniqueInput[]
    update?: job_responsibilitesUpdateWithWhereUniqueWithoutResponsibilitesInput | job_responsibilitesUpdateWithWhereUniqueWithoutResponsibilitesInput[]
    updateMany?: job_responsibilitesUpdateManyWithWhereWithoutResponsibilitesInput | job_responsibilitesUpdateManyWithWhereWithoutResponsibilitesInput[]
    deleteMany?: job_responsibilitesScalarWhereInput | job_responsibilitesScalarWhereInput[]
  }

  export type job_benefitsUpdateManyWithoutBenefitsNestedInput = {
    create?: XOR<job_benefitsCreateWithoutBenefitsInput, job_benefitsUncheckedCreateWithoutBenefitsInput> | job_benefitsCreateWithoutBenefitsInput[] | job_benefitsUncheckedCreateWithoutBenefitsInput[]
    connectOrCreate?: job_benefitsCreateOrConnectWithoutBenefitsInput | job_benefitsCreateOrConnectWithoutBenefitsInput[]
    upsert?: job_benefitsUpsertWithWhereUniqueWithoutBenefitsInput | job_benefitsUpsertWithWhereUniqueWithoutBenefitsInput[]
    createMany?: job_benefitsCreateManyBenefitsInputEnvelope
    set?: job_benefitsWhereUniqueInput | job_benefitsWhereUniqueInput[]
    disconnect?: job_benefitsWhereUniqueInput | job_benefitsWhereUniqueInput[]
    delete?: job_benefitsWhereUniqueInput | job_benefitsWhereUniqueInput[]
    connect?: job_benefitsWhereUniqueInput | job_benefitsWhereUniqueInput[]
    update?: job_benefitsUpdateWithWhereUniqueWithoutBenefitsInput | job_benefitsUpdateWithWhereUniqueWithoutBenefitsInput[]
    updateMany?: job_benefitsUpdateManyWithWhereWithoutBenefitsInput | job_benefitsUpdateManyWithWhereWithoutBenefitsInput[]
    deleteMany?: job_benefitsScalarWhereInput | job_benefitsScalarWhereInput[]
  }

  export type applicationsUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<applicationsCreateWithoutApplicationInput, applicationsUncheckedCreateWithoutApplicationInput> | applicationsCreateWithoutApplicationInput[] | applicationsUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: applicationsCreateOrConnectWithoutApplicationInput | applicationsCreateOrConnectWithoutApplicationInput[]
    upsert?: applicationsUpsertWithWhereUniqueWithoutApplicationInput | applicationsUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: applicationsCreateManyApplicationInputEnvelope
    set?: applicationsWhereUniqueInput | applicationsWhereUniqueInput[]
    disconnect?: applicationsWhereUniqueInput | applicationsWhereUniqueInput[]
    delete?: applicationsWhereUniqueInput | applicationsWhereUniqueInput[]
    connect?: applicationsWhereUniqueInput | applicationsWhereUniqueInput[]
    update?: applicationsUpdateWithWhereUniqueWithoutApplicationInput | applicationsUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: applicationsUpdateManyWithWhereWithoutApplicationInput | applicationsUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: applicationsScalarWhereInput | applicationsScalarWhereInput[]
  }

  export type contactsUpdateManyWithoutContactNestedInput = {
    create?: XOR<contactsCreateWithoutContactInput, contactsUncheckedCreateWithoutContactInput> | contactsCreateWithoutContactInput[] | contactsUncheckedCreateWithoutContactInput[]
    connectOrCreate?: contactsCreateOrConnectWithoutContactInput | contactsCreateOrConnectWithoutContactInput[]
    upsert?: contactsUpsertWithWhereUniqueWithoutContactInput | contactsUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: contactsCreateManyContactInputEnvelope
    set?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    disconnect?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    delete?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    connect?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    update?: contactsUpdateWithWhereUniqueWithoutContactInput | contactsUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: contactsUpdateManyWithWhereWithoutContactInput | contactsUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: contactsScalarWhereInput | contactsScalarWhereInput[]
  }

  export type saved_jobsUpdateManyWithoutSavedjobsNestedInput = {
    create?: XOR<saved_jobsCreateWithoutSavedjobsInput, saved_jobsUncheckedCreateWithoutSavedjobsInput> | saved_jobsCreateWithoutSavedjobsInput[] | saved_jobsUncheckedCreateWithoutSavedjobsInput[]
    connectOrCreate?: saved_jobsCreateOrConnectWithoutSavedjobsInput | saved_jobsCreateOrConnectWithoutSavedjobsInput[]
    upsert?: saved_jobsUpsertWithWhereUniqueWithoutSavedjobsInput | saved_jobsUpsertWithWhereUniqueWithoutSavedjobsInput[]
    createMany?: saved_jobsCreateManySavedjobsInputEnvelope
    set?: saved_jobsWhereUniqueInput | saved_jobsWhereUniqueInput[]
    disconnect?: saved_jobsWhereUniqueInput | saved_jobsWhereUniqueInput[]
    delete?: saved_jobsWhereUniqueInput | saved_jobsWhereUniqueInput[]
    connect?: saved_jobsWhereUniqueInput | saved_jobsWhereUniqueInput[]
    update?: saved_jobsUpdateWithWhereUniqueWithoutSavedjobsInput | saved_jobsUpdateWithWhereUniqueWithoutSavedjobsInput[]
    updateMany?: saved_jobsUpdateManyWithWhereWithoutSavedjobsInput | saved_jobsUpdateManyWithWhereWithoutSavedjobsInput[]
    deleteMany?: saved_jobsScalarWhereInput | saved_jobsScalarWhereInput[]
  }

  export type job_requirementsUncheckedUpdateManyWithoutRequirementsNestedInput = {
    create?: XOR<job_requirementsCreateWithoutRequirementsInput, job_requirementsUncheckedCreateWithoutRequirementsInput> | job_requirementsCreateWithoutRequirementsInput[] | job_requirementsUncheckedCreateWithoutRequirementsInput[]
    connectOrCreate?: job_requirementsCreateOrConnectWithoutRequirementsInput | job_requirementsCreateOrConnectWithoutRequirementsInput[]
    upsert?: job_requirementsUpsertWithWhereUniqueWithoutRequirementsInput | job_requirementsUpsertWithWhereUniqueWithoutRequirementsInput[]
    createMany?: job_requirementsCreateManyRequirementsInputEnvelope
    set?: job_requirementsWhereUniqueInput | job_requirementsWhereUniqueInput[]
    disconnect?: job_requirementsWhereUniqueInput | job_requirementsWhereUniqueInput[]
    delete?: job_requirementsWhereUniqueInput | job_requirementsWhereUniqueInput[]
    connect?: job_requirementsWhereUniqueInput | job_requirementsWhereUniqueInput[]
    update?: job_requirementsUpdateWithWhereUniqueWithoutRequirementsInput | job_requirementsUpdateWithWhereUniqueWithoutRequirementsInput[]
    updateMany?: job_requirementsUpdateManyWithWhereWithoutRequirementsInput | job_requirementsUpdateManyWithWhereWithoutRequirementsInput[]
    deleteMany?: job_requirementsScalarWhereInput | job_requirementsScalarWhereInput[]
  }

  export type job_responsibilitesUncheckedUpdateManyWithoutResponsibilitesNestedInput = {
    create?: XOR<job_responsibilitesCreateWithoutResponsibilitesInput, job_responsibilitesUncheckedCreateWithoutResponsibilitesInput> | job_responsibilitesCreateWithoutResponsibilitesInput[] | job_responsibilitesUncheckedCreateWithoutResponsibilitesInput[]
    connectOrCreate?: job_responsibilitesCreateOrConnectWithoutResponsibilitesInput | job_responsibilitesCreateOrConnectWithoutResponsibilitesInput[]
    upsert?: job_responsibilitesUpsertWithWhereUniqueWithoutResponsibilitesInput | job_responsibilitesUpsertWithWhereUniqueWithoutResponsibilitesInput[]
    createMany?: job_responsibilitesCreateManyResponsibilitesInputEnvelope
    set?: job_responsibilitesWhereUniqueInput | job_responsibilitesWhereUniqueInput[]
    disconnect?: job_responsibilitesWhereUniqueInput | job_responsibilitesWhereUniqueInput[]
    delete?: job_responsibilitesWhereUniqueInput | job_responsibilitesWhereUniqueInput[]
    connect?: job_responsibilitesWhereUniqueInput | job_responsibilitesWhereUniqueInput[]
    update?: job_responsibilitesUpdateWithWhereUniqueWithoutResponsibilitesInput | job_responsibilitesUpdateWithWhereUniqueWithoutResponsibilitesInput[]
    updateMany?: job_responsibilitesUpdateManyWithWhereWithoutResponsibilitesInput | job_responsibilitesUpdateManyWithWhereWithoutResponsibilitesInput[]
    deleteMany?: job_responsibilitesScalarWhereInput | job_responsibilitesScalarWhereInput[]
  }

  export type job_benefitsUncheckedUpdateManyWithoutBenefitsNestedInput = {
    create?: XOR<job_benefitsCreateWithoutBenefitsInput, job_benefitsUncheckedCreateWithoutBenefitsInput> | job_benefitsCreateWithoutBenefitsInput[] | job_benefitsUncheckedCreateWithoutBenefitsInput[]
    connectOrCreate?: job_benefitsCreateOrConnectWithoutBenefitsInput | job_benefitsCreateOrConnectWithoutBenefitsInput[]
    upsert?: job_benefitsUpsertWithWhereUniqueWithoutBenefitsInput | job_benefitsUpsertWithWhereUniqueWithoutBenefitsInput[]
    createMany?: job_benefitsCreateManyBenefitsInputEnvelope
    set?: job_benefitsWhereUniqueInput | job_benefitsWhereUniqueInput[]
    disconnect?: job_benefitsWhereUniqueInput | job_benefitsWhereUniqueInput[]
    delete?: job_benefitsWhereUniqueInput | job_benefitsWhereUniqueInput[]
    connect?: job_benefitsWhereUniqueInput | job_benefitsWhereUniqueInput[]
    update?: job_benefitsUpdateWithWhereUniqueWithoutBenefitsInput | job_benefitsUpdateWithWhereUniqueWithoutBenefitsInput[]
    updateMany?: job_benefitsUpdateManyWithWhereWithoutBenefitsInput | job_benefitsUpdateManyWithWhereWithoutBenefitsInput[]
    deleteMany?: job_benefitsScalarWhereInput | job_benefitsScalarWhereInput[]
  }

  export type applicationsUncheckedUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<applicationsCreateWithoutApplicationInput, applicationsUncheckedCreateWithoutApplicationInput> | applicationsCreateWithoutApplicationInput[] | applicationsUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: applicationsCreateOrConnectWithoutApplicationInput | applicationsCreateOrConnectWithoutApplicationInput[]
    upsert?: applicationsUpsertWithWhereUniqueWithoutApplicationInput | applicationsUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: applicationsCreateManyApplicationInputEnvelope
    set?: applicationsWhereUniqueInput | applicationsWhereUniqueInput[]
    disconnect?: applicationsWhereUniqueInput | applicationsWhereUniqueInput[]
    delete?: applicationsWhereUniqueInput | applicationsWhereUniqueInput[]
    connect?: applicationsWhereUniqueInput | applicationsWhereUniqueInput[]
    update?: applicationsUpdateWithWhereUniqueWithoutApplicationInput | applicationsUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: applicationsUpdateManyWithWhereWithoutApplicationInput | applicationsUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: applicationsScalarWhereInput | applicationsScalarWhereInput[]
  }

  export type contactsUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<contactsCreateWithoutContactInput, contactsUncheckedCreateWithoutContactInput> | contactsCreateWithoutContactInput[] | contactsUncheckedCreateWithoutContactInput[]
    connectOrCreate?: contactsCreateOrConnectWithoutContactInput | contactsCreateOrConnectWithoutContactInput[]
    upsert?: contactsUpsertWithWhereUniqueWithoutContactInput | contactsUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: contactsCreateManyContactInputEnvelope
    set?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    disconnect?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    delete?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    connect?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    update?: contactsUpdateWithWhereUniqueWithoutContactInput | contactsUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: contactsUpdateManyWithWhereWithoutContactInput | contactsUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: contactsScalarWhereInput | contactsScalarWhereInput[]
  }

  export type saved_jobsUncheckedUpdateManyWithoutSavedjobsNestedInput = {
    create?: XOR<saved_jobsCreateWithoutSavedjobsInput, saved_jobsUncheckedCreateWithoutSavedjobsInput> | saved_jobsCreateWithoutSavedjobsInput[] | saved_jobsUncheckedCreateWithoutSavedjobsInput[]
    connectOrCreate?: saved_jobsCreateOrConnectWithoutSavedjobsInput | saved_jobsCreateOrConnectWithoutSavedjobsInput[]
    upsert?: saved_jobsUpsertWithWhereUniqueWithoutSavedjobsInput | saved_jobsUpsertWithWhereUniqueWithoutSavedjobsInput[]
    createMany?: saved_jobsCreateManySavedjobsInputEnvelope
    set?: saved_jobsWhereUniqueInput | saved_jobsWhereUniqueInput[]
    disconnect?: saved_jobsWhereUniqueInput | saved_jobsWhereUniqueInput[]
    delete?: saved_jobsWhereUniqueInput | saved_jobsWhereUniqueInput[]
    connect?: saved_jobsWhereUniqueInput | saved_jobsWhereUniqueInput[]
    update?: saved_jobsUpdateWithWhereUniqueWithoutSavedjobsInput | saved_jobsUpdateWithWhereUniqueWithoutSavedjobsInput[]
    updateMany?: saved_jobsUpdateManyWithWhereWithoutSavedjobsInput | saved_jobsUpdateManyWithWhereWithoutSavedjobsInput[]
    deleteMany?: saved_jobsScalarWhereInput | saved_jobsScalarWhereInput[]
  }

  export type jobsCreateNestedOneWithoutRequirementsInput = {
    create?: XOR<jobsCreateWithoutRequirementsInput, jobsUncheckedCreateWithoutRequirementsInput>
    connectOrCreate?: jobsCreateOrConnectWithoutRequirementsInput
    connect?: jobsWhereUniqueInput
  }

  export type EnumjobRequirementsFieldUpdateOperationsInput = {
    set?: $Enums.jobRequirements
  }

  export type jobsUpdateOneRequiredWithoutRequirementsNestedInput = {
    create?: XOR<jobsCreateWithoutRequirementsInput, jobsUncheckedCreateWithoutRequirementsInput>
    connectOrCreate?: jobsCreateOrConnectWithoutRequirementsInput
    upsert?: jobsUpsertWithoutRequirementsInput
    connect?: jobsWhereUniqueInput
    update?: XOR<XOR<jobsUpdateToOneWithWhereWithoutRequirementsInput, jobsUpdateWithoutRequirementsInput>, jobsUncheckedUpdateWithoutRequirementsInput>
  }

  export type jobsCreateNestedOneWithoutResponsibilitesInput = {
    create?: XOR<jobsCreateWithoutResponsibilitesInput, jobsUncheckedCreateWithoutResponsibilitesInput>
    connectOrCreate?: jobsCreateOrConnectWithoutResponsibilitesInput
    connect?: jobsWhereUniqueInput
  }

  export type jobsUpdateOneRequiredWithoutResponsibilitesNestedInput = {
    create?: XOR<jobsCreateWithoutResponsibilitesInput, jobsUncheckedCreateWithoutResponsibilitesInput>
    connectOrCreate?: jobsCreateOrConnectWithoutResponsibilitesInput
    upsert?: jobsUpsertWithoutResponsibilitesInput
    connect?: jobsWhereUniqueInput
    update?: XOR<XOR<jobsUpdateToOneWithWhereWithoutResponsibilitesInput, jobsUpdateWithoutResponsibilitesInput>, jobsUncheckedUpdateWithoutResponsibilitesInput>
  }

  export type jobsCreateNestedOneWithoutBenefitsInput = {
    create?: XOR<jobsCreateWithoutBenefitsInput, jobsUncheckedCreateWithoutBenefitsInput>
    connectOrCreate?: jobsCreateOrConnectWithoutBenefitsInput
    connect?: jobsWhereUniqueInput
  }

  export type EnumjobBenefitFieldUpdateOperationsInput = {
    set?: $Enums.jobBenefit
  }

  export type jobsUpdateOneRequiredWithoutBenefitsNestedInput = {
    create?: XOR<jobsCreateWithoutBenefitsInput, jobsUncheckedCreateWithoutBenefitsInput>
    connectOrCreate?: jobsCreateOrConnectWithoutBenefitsInput
    upsert?: jobsUpsertWithoutBenefitsInput
    connect?: jobsWhereUniqueInput
    update?: XOR<XOR<jobsUpdateToOneWithWhereWithoutBenefitsInput, jobsUpdateWithoutBenefitsInput>, jobsUncheckedUpdateWithoutBenefitsInput>
  }

  export type jobsCreateNestedOneWithoutApplicationInput = {
    create?: XOR<jobsCreateWithoutApplicationInput, jobsUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: jobsCreateOrConnectWithoutApplicationInput
    connect?: jobsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutApplicationInput = {
    create?: XOR<usersCreateWithoutApplicationInput, usersUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: usersCreateOrConnectWithoutApplicationInput
    connect?: usersWhereUniqueInput
  }

  export type resumesCreateNestedOneWithoutApplicationsInput = {
    create?: XOR<resumesCreateWithoutApplicationsInput, resumesUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: resumesCreateOrConnectWithoutApplicationsInput
    connect?: resumesWhereUniqueInput
  }

  export type application_documentsCreateNestedManyWithoutDocumentInput = {
    create?: XOR<application_documentsCreateWithoutDocumentInput, application_documentsUncheckedCreateWithoutDocumentInput> | application_documentsCreateWithoutDocumentInput[] | application_documentsUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: application_documentsCreateOrConnectWithoutDocumentInput | application_documentsCreateOrConnectWithoutDocumentInput[]
    createMany?: application_documentsCreateManyDocumentInputEnvelope
    connect?: application_documentsWhereUniqueInput | application_documentsWhereUniqueInput[]
  }

  export type interviewsCreateNestedManyWithoutInterviewInput = {
    create?: XOR<interviewsCreateWithoutInterviewInput, interviewsUncheckedCreateWithoutInterviewInput> | interviewsCreateWithoutInterviewInput[] | interviewsUncheckedCreateWithoutInterviewInput[]
    connectOrCreate?: interviewsCreateOrConnectWithoutInterviewInput | interviewsCreateOrConnectWithoutInterviewInput[]
    createMany?: interviewsCreateManyInterviewInputEnvelope
    connect?: interviewsWhereUniqueInput | interviewsWhereUniqueInput[]
  }

  export type application_documentsUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<application_documentsCreateWithoutDocumentInput, application_documentsUncheckedCreateWithoutDocumentInput> | application_documentsCreateWithoutDocumentInput[] | application_documentsUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: application_documentsCreateOrConnectWithoutDocumentInput | application_documentsCreateOrConnectWithoutDocumentInput[]
    createMany?: application_documentsCreateManyDocumentInputEnvelope
    connect?: application_documentsWhereUniqueInput | application_documentsWhereUniqueInput[]
  }

  export type interviewsUncheckedCreateNestedManyWithoutInterviewInput = {
    create?: XOR<interviewsCreateWithoutInterviewInput, interviewsUncheckedCreateWithoutInterviewInput> | interviewsCreateWithoutInterviewInput[] | interviewsUncheckedCreateWithoutInterviewInput[]
    connectOrCreate?: interviewsCreateOrConnectWithoutInterviewInput | interviewsCreateOrConnectWithoutInterviewInput[]
    createMany?: interviewsCreateManyInterviewInputEnvelope
    connect?: interviewsWhereUniqueInput | interviewsWhereUniqueInput[]
  }

  export type EnumapplicationStatusFieldUpdateOperationsInput = {
    set?: $Enums.applicationStatus
  }

  export type jobsUpdateOneRequiredWithoutApplicationNestedInput = {
    create?: XOR<jobsCreateWithoutApplicationInput, jobsUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: jobsCreateOrConnectWithoutApplicationInput
    upsert?: jobsUpsertWithoutApplicationInput
    connect?: jobsWhereUniqueInput
    update?: XOR<XOR<jobsUpdateToOneWithWhereWithoutApplicationInput, jobsUpdateWithoutApplicationInput>, jobsUncheckedUpdateWithoutApplicationInput>
  }

  export type usersUpdateOneRequiredWithoutApplicationNestedInput = {
    create?: XOR<usersCreateWithoutApplicationInput, usersUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: usersCreateOrConnectWithoutApplicationInput
    upsert?: usersUpsertWithoutApplicationInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutApplicationInput, usersUpdateWithoutApplicationInput>, usersUncheckedUpdateWithoutApplicationInput>
  }

  export type resumesUpdateOneRequiredWithoutApplicationsNestedInput = {
    create?: XOR<resumesCreateWithoutApplicationsInput, resumesUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: resumesCreateOrConnectWithoutApplicationsInput
    upsert?: resumesUpsertWithoutApplicationsInput
    connect?: resumesWhereUniqueInput
    update?: XOR<XOR<resumesUpdateToOneWithWhereWithoutApplicationsInput, resumesUpdateWithoutApplicationsInput>, resumesUncheckedUpdateWithoutApplicationsInput>
  }

  export type application_documentsUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<application_documentsCreateWithoutDocumentInput, application_documentsUncheckedCreateWithoutDocumentInput> | application_documentsCreateWithoutDocumentInput[] | application_documentsUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: application_documentsCreateOrConnectWithoutDocumentInput | application_documentsCreateOrConnectWithoutDocumentInput[]
    upsert?: application_documentsUpsertWithWhereUniqueWithoutDocumentInput | application_documentsUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: application_documentsCreateManyDocumentInputEnvelope
    set?: application_documentsWhereUniqueInput | application_documentsWhereUniqueInput[]
    disconnect?: application_documentsWhereUniqueInput | application_documentsWhereUniqueInput[]
    delete?: application_documentsWhereUniqueInput | application_documentsWhereUniqueInput[]
    connect?: application_documentsWhereUniqueInput | application_documentsWhereUniqueInput[]
    update?: application_documentsUpdateWithWhereUniqueWithoutDocumentInput | application_documentsUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: application_documentsUpdateManyWithWhereWithoutDocumentInput | application_documentsUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: application_documentsScalarWhereInput | application_documentsScalarWhereInput[]
  }

  export type interviewsUpdateManyWithoutInterviewNestedInput = {
    create?: XOR<interviewsCreateWithoutInterviewInput, interviewsUncheckedCreateWithoutInterviewInput> | interviewsCreateWithoutInterviewInput[] | interviewsUncheckedCreateWithoutInterviewInput[]
    connectOrCreate?: interviewsCreateOrConnectWithoutInterviewInput | interviewsCreateOrConnectWithoutInterviewInput[]
    upsert?: interviewsUpsertWithWhereUniqueWithoutInterviewInput | interviewsUpsertWithWhereUniqueWithoutInterviewInput[]
    createMany?: interviewsCreateManyInterviewInputEnvelope
    set?: interviewsWhereUniqueInput | interviewsWhereUniqueInput[]
    disconnect?: interviewsWhereUniqueInput | interviewsWhereUniqueInput[]
    delete?: interviewsWhereUniqueInput | interviewsWhereUniqueInput[]
    connect?: interviewsWhereUniqueInput | interviewsWhereUniqueInput[]
    update?: interviewsUpdateWithWhereUniqueWithoutInterviewInput | interviewsUpdateWithWhereUniqueWithoutInterviewInput[]
    updateMany?: interviewsUpdateManyWithWhereWithoutInterviewInput | interviewsUpdateManyWithWhereWithoutInterviewInput[]
    deleteMany?: interviewsScalarWhereInput | interviewsScalarWhereInput[]
  }

  export type application_documentsUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<application_documentsCreateWithoutDocumentInput, application_documentsUncheckedCreateWithoutDocumentInput> | application_documentsCreateWithoutDocumentInput[] | application_documentsUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: application_documentsCreateOrConnectWithoutDocumentInput | application_documentsCreateOrConnectWithoutDocumentInput[]
    upsert?: application_documentsUpsertWithWhereUniqueWithoutDocumentInput | application_documentsUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: application_documentsCreateManyDocumentInputEnvelope
    set?: application_documentsWhereUniqueInput | application_documentsWhereUniqueInput[]
    disconnect?: application_documentsWhereUniqueInput | application_documentsWhereUniqueInput[]
    delete?: application_documentsWhereUniqueInput | application_documentsWhereUniqueInput[]
    connect?: application_documentsWhereUniqueInput | application_documentsWhereUniqueInput[]
    update?: application_documentsUpdateWithWhereUniqueWithoutDocumentInput | application_documentsUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: application_documentsUpdateManyWithWhereWithoutDocumentInput | application_documentsUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: application_documentsScalarWhereInput | application_documentsScalarWhereInput[]
  }

  export type interviewsUncheckedUpdateManyWithoutInterviewNestedInput = {
    create?: XOR<interviewsCreateWithoutInterviewInput, interviewsUncheckedCreateWithoutInterviewInput> | interviewsCreateWithoutInterviewInput[] | interviewsUncheckedCreateWithoutInterviewInput[]
    connectOrCreate?: interviewsCreateOrConnectWithoutInterviewInput | interviewsCreateOrConnectWithoutInterviewInput[]
    upsert?: interviewsUpsertWithWhereUniqueWithoutInterviewInput | interviewsUpsertWithWhereUniqueWithoutInterviewInput[]
    createMany?: interviewsCreateManyInterviewInputEnvelope
    set?: interviewsWhereUniqueInput | interviewsWhereUniqueInput[]
    disconnect?: interviewsWhereUniqueInput | interviewsWhereUniqueInput[]
    delete?: interviewsWhereUniqueInput | interviewsWhereUniqueInput[]
    connect?: interviewsWhereUniqueInput | interviewsWhereUniqueInput[]
    update?: interviewsUpdateWithWhereUniqueWithoutInterviewInput | interviewsUpdateWithWhereUniqueWithoutInterviewInput[]
    updateMany?: interviewsUpdateManyWithWhereWithoutInterviewInput | interviewsUpdateManyWithWhereWithoutInterviewInput[]
    deleteMany?: interviewsScalarWhereInput | interviewsScalarWhereInput[]
  }

  export type applicationsCreateNestedOneWithoutDocumentInput = {
    create?: XOR<applicationsCreateWithoutDocumentInput, applicationsUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: applicationsCreateOrConnectWithoutDocumentInput
    connect?: applicationsWhereUniqueInput
  }

  export type EnumappDocumentStatusFieldUpdateOperationsInput = {
    set?: $Enums.appDocumentStatus
  }

  export type applicationsUpdateOneRequiredWithoutDocumentNestedInput = {
    create?: XOR<applicationsCreateWithoutDocumentInput, applicationsUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: applicationsCreateOrConnectWithoutDocumentInput
    upsert?: applicationsUpsertWithoutDocumentInput
    connect?: applicationsWhereUniqueInput
    update?: XOR<XOR<applicationsUpdateToOneWithWhereWithoutDocumentInput, applicationsUpdateWithoutDocumentInput>, applicationsUncheckedUpdateWithoutDocumentInput>
  }

  export type applicationsCreateNestedOneWithoutInterviewInput = {
    create?: XOR<applicationsCreateWithoutInterviewInput, applicationsUncheckedCreateWithoutInterviewInput>
    connectOrCreate?: applicationsCreateOrConnectWithoutInterviewInput
    connect?: applicationsWhereUniqueInput
  }

  export type EnuminterviewTypeFieldUpdateOperationsInput = {
    set?: $Enums.interviewType
  }

  export type EnuminterviewStatusFieldUpdateOperationsInput = {
    set?: $Enums.interviewStatus
  }

  export type applicationsUpdateOneRequiredWithoutInterviewNestedInput = {
    create?: XOR<applicationsCreateWithoutInterviewInput, applicationsUncheckedCreateWithoutInterviewInput>
    connectOrCreate?: applicationsCreateOrConnectWithoutInterviewInput
    upsert?: applicationsUpsertWithoutInterviewInput
    connect?: applicationsWhereUniqueInput
    update?: XOR<XOR<applicationsUpdateToOneWithWhereWithoutInterviewInput, applicationsUpdateWithoutInterviewInput>, applicationsUncheckedUpdateWithoutInterviewInput>
  }

  export type jobsCreateNestedOneWithoutContactInput = {
    create?: XOR<jobsCreateWithoutContactInput, jobsUncheckedCreateWithoutContactInput>
    connectOrCreate?: jobsCreateOrConnectWithoutContactInput
    connect?: jobsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutContactsInput = {
    create?: XOR<usersCreateWithoutContactsInput, usersUncheckedCreateWithoutContactsInput>
    connectOrCreate?: usersCreateOrConnectWithoutContactsInput
    connect?: usersWhereUniqueInput
  }

  export type companiesCreateNestedOneWithoutContactsInput = {
    create?: XOR<companiesCreateWithoutContactsInput, companiesUncheckedCreateWithoutContactsInput>
    connectOrCreate?: companiesCreateOrConnectWithoutContactsInput
    connect?: companiesWhereUniqueInput
  }

  export type EnumcontactTypeFieldUpdateOperationsInput = {
    set?: $Enums.contactType
  }

  export type EnumcontactSalaryPaymentPeriodFieldUpdateOperationsInput = {
    set?: $Enums.contactSalaryPaymentPeriod
  }

  export type EnumcontactStatusFieldUpdateOperationsInput = {
    set?: $Enums.contactStatus
  }

  export type jobsUpdateOneRequiredWithoutContactNestedInput = {
    create?: XOR<jobsCreateWithoutContactInput, jobsUncheckedCreateWithoutContactInput>
    connectOrCreate?: jobsCreateOrConnectWithoutContactInput
    upsert?: jobsUpsertWithoutContactInput
    connect?: jobsWhereUniqueInput
    update?: XOR<XOR<jobsUpdateToOneWithWhereWithoutContactInput, jobsUpdateWithoutContactInput>, jobsUncheckedUpdateWithoutContactInput>
  }

  export type usersUpdateOneRequiredWithoutContactsNestedInput = {
    create?: XOR<usersCreateWithoutContactsInput, usersUncheckedCreateWithoutContactsInput>
    connectOrCreate?: usersCreateOrConnectWithoutContactsInput
    upsert?: usersUpsertWithoutContactsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutContactsInput, usersUpdateWithoutContactsInput>, usersUncheckedUpdateWithoutContactsInput>
  }

  export type companiesUpdateOneRequiredWithoutContactsNestedInput = {
    create?: XOR<companiesCreateWithoutContactsInput, companiesUncheckedCreateWithoutContactsInput>
    connectOrCreate?: companiesCreateOrConnectWithoutContactsInput
    upsert?: companiesUpsertWithoutContactsInput
    connect?: companiesWhereUniqueInput
    update?: XOR<XOR<companiesUpdateToOneWithWhereWithoutContactsInput, companiesUpdateWithoutContactsInput>, companiesUncheckedUpdateWithoutContactsInput>
  }

  export type usersCreateNestedOneWithoutNotificationInput = {
    create?: XOR<usersCreateWithoutNotificationInput, usersUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: usersCreateOrConnectWithoutNotificationInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutNotificationNestedInput = {
    create?: XOR<usersCreateWithoutNotificationInput, usersUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: usersCreateOrConnectWithoutNotificationInput
    upsert?: usersUpsertWithoutNotificationInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutNotificationInput, usersUpdateWithoutNotificationInput>, usersUncheckedUpdateWithoutNotificationInput>
  }

  export type usersCreateNestedOneWithoutSavedjobInput = {
    create?: XOR<usersCreateWithoutSavedjobInput, usersUncheckedCreateWithoutSavedjobInput>
    connectOrCreate?: usersCreateOrConnectWithoutSavedjobInput
    connect?: usersWhereUniqueInput
  }

  export type jobsCreateNestedOneWithoutSavedjobInput = {
    create?: XOR<jobsCreateWithoutSavedjobInput, jobsUncheckedCreateWithoutSavedjobInput>
    connectOrCreate?: jobsCreateOrConnectWithoutSavedjobInput
    connect?: jobsWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutSavedjobNestedInput = {
    create?: XOR<usersCreateWithoutSavedjobInput, usersUncheckedCreateWithoutSavedjobInput>
    connectOrCreate?: usersCreateOrConnectWithoutSavedjobInput
    upsert?: usersUpsertWithoutSavedjobInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutSavedjobInput, usersUpdateWithoutSavedjobInput>, usersUncheckedUpdateWithoutSavedjobInput>
  }

  export type jobsUpdateOneRequiredWithoutSavedjobNestedInput = {
    create?: XOR<jobsCreateWithoutSavedjobInput, jobsUncheckedCreateWithoutSavedjobInput>
    connectOrCreate?: jobsCreateOrConnectWithoutSavedjobInput
    upsert?: jobsUpsertWithoutSavedjobInput
    connect?: jobsWhereUniqueInput
    update?: XOR<XOR<jobsUpdateToOneWithWhereWithoutSavedjobInput, jobsUpdateWithoutSavedjobInput>, jobsUncheckedUpdateWithoutSavedjobInput>
  }

  export type usersCreateNestedOneWithoutSearchesInput = {
    create?: XOR<usersCreateWithoutSearchesInput, usersUncheckedCreateWithoutSearchesInput>
    connectOrCreate?: usersCreateOrConnectWithoutSearchesInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutSearchesNestedInput = {
    create?: XOR<usersCreateWithoutSearchesInput, usersUncheckedCreateWithoutSearchesInput>
    connectOrCreate?: usersCreateOrConnectWithoutSearchesInput
    upsert?: usersUpsertWithoutSearchesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutSearchesInput, usersUpdateWithoutSearchesInput>, usersUncheckedUpdateWithoutSearchesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumuserstatusFilter<$PrismaModel = never> = {
    equals?: $Enums.userstatus | EnumuserstatusFieldRefInput<$PrismaModel>
    in?: $Enums.userstatus[] | ListEnumuserstatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.userstatus[] | ListEnumuserstatusFieldRefInput<$PrismaModel>
    not?: NestedEnumuserstatusFilter<$PrismaModel> | $Enums.userstatus
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumuserstatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.userstatus | EnumuserstatusFieldRefInput<$PrismaModel>
    in?: $Enums.userstatus[] | ListEnumuserstatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.userstatus[] | ListEnumuserstatusFieldRefInput<$PrismaModel>
    not?: NestedEnumuserstatusWithAggregatesFilter<$PrismaModel> | $Enums.userstatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumuserstatusFilter<$PrismaModel>
    _max?: NestedEnumuserstatusFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumskillsstatusFilter<$PrismaModel = never> = {
    equals?: $Enums.skillsstatus | EnumskillsstatusFieldRefInput<$PrismaModel>
    in?: $Enums.skillsstatus[] | ListEnumskillsstatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.skillsstatus[] | ListEnumskillsstatusFieldRefInput<$PrismaModel>
    not?: NestedEnumskillsstatusFilter<$PrismaModel> | $Enums.skillsstatus
  }

  export type NestedEnumskillsstatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.skillsstatus | EnumskillsstatusFieldRefInput<$PrismaModel>
    in?: $Enums.skillsstatus[] | ListEnumskillsstatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.skillsstatus[] | ListEnumskillsstatusFieldRefInput<$PrismaModel>
    not?: NestedEnumskillsstatusWithAggregatesFilter<$PrismaModel> | $Enums.skillsstatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumskillsstatusFilter<$PrismaModel>
    _max?: NestedEnumskillsstatusFilter<$PrismaModel>
  }

  export type NestedEnumproficiencylanguagesFilter<$PrismaModel = never> = {
    equals?: $Enums.proficiencylanguages | EnumproficiencylanguagesFieldRefInput<$PrismaModel>
    in?: $Enums.proficiencylanguages[] | ListEnumproficiencylanguagesFieldRefInput<$PrismaModel>
    notIn?: $Enums.proficiencylanguages[] | ListEnumproficiencylanguagesFieldRefInput<$PrismaModel>
    not?: NestedEnumproficiencylanguagesFilter<$PrismaModel> | $Enums.proficiencylanguages
  }

  export type NestedEnumproficiencylanguagesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.proficiencylanguages | EnumproficiencylanguagesFieldRefInput<$PrismaModel>
    in?: $Enums.proficiencylanguages[] | ListEnumproficiencylanguagesFieldRefInput<$PrismaModel>
    notIn?: $Enums.proficiencylanguages[] | ListEnumproficiencylanguagesFieldRefInput<$PrismaModel>
    not?: NestedEnumproficiencylanguagesWithAggregatesFilter<$PrismaModel> | $Enums.proficiencylanguages
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumproficiencylanguagesFilter<$PrismaModel>
    _max?: NestedEnumproficiencylanguagesFilter<$PrismaModel>
  }

  export type NestedEnumcompanySizeFilter<$PrismaModel = never> = {
    equals?: $Enums.companySize | EnumcompanySizeFieldRefInput<$PrismaModel>
    in?: $Enums.companySize[] | ListEnumcompanySizeFieldRefInput<$PrismaModel>
    notIn?: $Enums.companySize[] | ListEnumcompanySizeFieldRefInput<$PrismaModel>
    not?: NestedEnumcompanySizeFilter<$PrismaModel> | $Enums.companySize
  }

  export type NestedEnumcompanySizeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.companySize | EnumcompanySizeFieldRefInput<$PrismaModel>
    in?: $Enums.companySize[] | ListEnumcompanySizeFieldRefInput<$PrismaModel>
    notIn?: $Enums.companySize[] | ListEnumcompanySizeFieldRefInput<$PrismaModel>
    not?: NestedEnumcompanySizeWithAggregatesFilter<$PrismaModel> | $Enums.companySize
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumcompanySizeFilter<$PrismaModel>
    _max?: NestedEnumcompanySizeFilter<$PrismaModel>
  }

  export type NestedEnumjobTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.jobType | EnumjobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.jobType[] | ListEnumjobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.jobType[] | ListEnumjobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumjobTypeFilter<$PrismaModel> | $Enums.jobType
  }

  export type NestedEnumsalaryPeriodFilter<$PrismaModel = never> = {
    equals?: $Enums.salaryPeriod | EnumsalaryPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.salaryPeriod[] | ListEnumsalaryPeriodFieldRefInput<$PrismaModel>
    notIn?: $Enums.salaryPeriod[] | ListEnumsalaryPeriodFieldRefInput<$PrismaModel>
    not?: NestedEnumsalaryPeriodFilter<$PrismaModel> | $Enums.salaryPeriod
  }

  export type NestedEnumvisaSponsorshipFilter<$PrismaModel = never> = {
    equals?: $Enums.visaSponsorship | EnumvisaSponsorshipFieldRefInput<$PrismaModel>
    in?: $Enums.visaSponsorship[] | ListEnumvisaSponsorshipFieldRefInput<$PrismaModel>
    notIn?: $Enums.visaSponsorship[] | ListEnumvisaSponsorshipFieldRefInput<$PrismaModel>
    not?: NestedEnumvisaSponsorshipFilter<$PrismaModel> | $Enums.visaSponsorship
  }

  export type NestedEnumexpLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.expLevel | EnumexpLevelFieldRefInput<$PrismaModel>
    in?: $Enums.expLevel[] | ListEnumexpLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.expLevel[] | ListEnumexpLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumexpLevelFilter<$PrismaModel> | $Enums.expLevel
  }

  export type NestedEnumjobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.jobStatus | EnumjobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.jobStatus[] | ListEnumjobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.jobStatus[] | ListEnumjobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumjobStatusFilter<$PrismaModel> | $Enums.jobStatus
  }

  export type NestedEnumjobTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.jobType | EnumjobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.jobType[] | ListEnumjobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.jobType[] | ListEnumjobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumjobTypeWithAggregatesFilter<$PrismaModel> | $Enums.jobType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumjobTypeFilter<$PrismaModel>
    _max?: NestedEnumjobTypeFilter<$PrismaModel>
  }

  export type NestedEnumsalaryPeriodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.salaryPeriod | EnumsalaryPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.salaryPeriod[] | ListEnumsalaryPeriodFieldRefInput<$PrismaModel>
    notIn?: $Enums.salaryPeriod[] | ListEnumsalaryPeriodFieldRefInput<$PrismaModel>
    not?: NestedEnumsalaryPeriodWithAggregatesFilter<$PrismaModel> | $Enums.salaryPeriod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumsalaryPeriodFilter<$PrismaModel>
    _max?: NestedEnumsalaryPeriodFilter<$PrismaModel>
  }

  export type NestedEnumvisaSponsorshipWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.visaSponsorship | EnumvisaSponsorshipFieldRefInput<$PrismaModel>
    in?: $Enums.visaSponsorship[] | ListEnumvisaSponsorshipFieldRefInput<$PrismaModel>
    notIn?: $Enums.visaSponsorship[] | ListEnumvisaSponsorshipFieldRefInput<$PrismaModel>
    not?: NestedEnumvisaSponsorshipWithAggregatesFilter<$PrismaModel> | $Enums.visaSponsorship
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumvisaSponsorshipFilter<$PrismaModel>
    _max?: NestedEnumvisaSponsorshipFilter<$PrismaModel>
  }

  export type NestedEnumexpLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.expLevel | EnumexpLevelFieldRefInput<$PrismaModel>
    in?: $Enums.expLevel[] | ListEnumexpLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.expLevel[] | ListEnumexpLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumexpLevelWithAggregatesFilter<$PrismaModel> | $Enums.expLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumexpLevelFilter<$PrismaModel>
    _max?: NestedEnumexpLevelFilter<$PrismaModel>
  }

  export type NestedEnumjobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.jobStatus | EnumjobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.jobStatus[] | ListEnumjobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.jobStatus[] | ListEnumjobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumjobStatusWithAggregatesFilter<$PrismaModel> | $Enums.jobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumjobStatusFilter<$PrismaModel>
    _max?: NestedEnumjobStatusFilter<$PrismaModel>
  }

  export type NestedEnumjobRequirementsFilter<$PrismaModel = never> = {
    equals?: $Enums.jobRequirements | EnumjobRequirementsFieldRefInput<$PrismaModel>
    in?: $Enums.jobRequirements[] | ListEnumjobRequirementsFieldRefInput<$PrismaModel>
    notIn?: $Enums.jobRequirements[] | ListEnumjobRequirementsFieldRefInput<$PrismaModel>
    not?: NestedEnumjobRequirementsFilter<$PrismaModel> | $Enums.jobRequirements
  }

  export type NestedEnumjobRequirementsWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.jobRequirements | EnumjobRequirementsFieldRefInput<$PrismaModel>
    in?: $Enums.jobRequirements[] | ListEnumjobRequirementsFieldRefInput<$PrismaModel>
    notIn?: $Enums.jobRequirements[] | ListEnumjobRequirementsFieldRefInput<$PrismaModel>
    not?: NestedEnumjobRequirementsWithAggregatesFilter<$PrismaModel> | $Enums.jobRequirements
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumjobRequirementsFilter<$PrismaModel>
    _max?: NestedEnumjobRequirementsFilter<$PrismaModel>
  }

  export type NestedEnumjobBenefitFilter<$PrismaModel = never> = {
    equals?: $Enums.jobBenefit | EnumjobBenefitFieldRefInput<$PrismaModel>
    in?: $Enums.jobBenefit[] | ListEnumjobBenefitFieldRefInput<$PrismaModel>
    notIn?: $Enums.jobBenefit[] | ListEnumjobBenefitFieldRefInput<$PrismaModel>
    not?: NestedEnumjobBenefitFilter<$PrismaModel> | $Enums.jobBenefit
  }

  export type NestedEnumjobBenefitWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.jobBenefit | EnumjobBenefitFieldRefInput<$PrismaModel>
    in?: $Enums.jobBenefit[] | ListEnumjobBenefitFieldRefInput<$PrismaModel>
    notIn?: $Enums.jobBenefit[] | ListEnumjobBenefitFieldRefInput<$PrismaModel>
    not?: NestedEnumjobBenefitWithAggregatesFilter<$PrismaModel> | $Enums.jobBenefit
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumjobBenefitFilter<$PrismaModel>
    _max?: NestedEnumjobBenefitFilter<$PrismaModel>
  }

  export type NestedEnumapplicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.applicationStatus | EnumapplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.applicationStatus[] | ListEnumapplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.applicationStatus[] | ListEnumapplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumapplicationStatusFilter<$PrismaModel> | $Enums.applicationStatus
  }

  export type NestedEnumapplicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.applicationStatus | EnumapplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.applicationStatus[] | ListEnumapplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.applicationStatus[] | ListEnumapplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumapplicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.applicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumapplicationStatusFilter<$PrismaModel>
    _max?: NestedEnumapplicationStatusFilter<$PrismaModel>
  }

  export type NestedEnumappDocumentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.appDocumentStatus | EnumappDocumentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.appDocumentStatus[] | ListEnumappDocumentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.appDocumentStatus[] | ListEnumappDocumentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumappDocumentStatusFilter<$PrismaModel> | $Enums.appDocumentStatus
  }

  export type NestedEnumappDocumentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.appDocumentStatus | EnumappDocumentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.appDocumentStatus[] | ListEnumappDocumentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.appDocumentStatus[] | ListEnumappDocumentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumappDocumentStatusWithAggregatesFilter<$PrismaModel> | $Enums.appDocumentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumappDocumentStatusFilter<$PrismaModel>
    _max?: NestedEnumappDocumentStatusFilter<$PrismaModel>
  }

  export type NestedEnuminterviewTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.interviewType | EnuminterviewTypeFieldRefInput<$PrismaModel>
    in?: $Enums.interviewType[] | ListEnuminterviewTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.interviewType[] | ListEnuminterviewTypeFieldRefInput<$PrismaModel>
    not?: NestedEnuminterviewTypeFilter<$PrismaModel> | $Enums.interviewType
  }

  export type NestedEnuminterviewStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.interviewStatus | EnuminterviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.interviewStatus[] | ListEnuminterviewStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.interviewStatus[] | ListEnuminterviewStatusFieldRefInput<$PrismaModel>
    not?: NestedEnuminterviewStatusFilter<$PrismaModel> | $Enums.interviewStatus
  }

  export type NestedEnuminterviewTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.interviewType | EnuminterviewTypeFieldRefInput<$PrismaModel>
    in?: $Enums.interviewType[] | ListEnuminterviewTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.interviewType[] | ListEnuminterviewTypeFieldRefInput<$PrismaModel>
    not?: NestedEnuminterviewTypeWithAggregatesFilter<$PrismaModel> | $Enums.interviewType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnuminterviewTypeFilter<$PrismaModel>
    _max?: NestedEnuminterviewTypeFilter<$PrismaModel>
  }

  export type NestedEnuminterviewStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.interviewStatus | EnuminterviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.interviewStatus[] | ListEnuminterviewStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.interviewStatus[] | ListEnuminterviewStatusFieldRefInput<$PrismaModel>
    not?: NestedEnuminterviewStatusWithAggregatesFilter<$PrismaModel> | $Enums.interviewStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnuminterviewStatusFilter<$PrismaModel>
    _max?: NestedEnuminterviewStatusFilter<$PrismaModel>
  }

  export type NestedEnumcontactTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.contactType | EnumcontactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.contactType[] | ListEnumcontactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.contactType[] | ListEnumcontactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumcontactTypeFilter<$PrismaModel> | $Enums.contactType
  }

  export type NestedEnumcontactSalaryPaymentPeriodFilter<$PrismaModel = never> = {
    equals?: $Enums.contactSalaryPaymentPeriod | EnumcontactSalaryPaymentPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.contactSalaryPaymentPeriod[] | ListEnumcontactSalaryPaymentPeriodFieldRefInput<$PrismaModel>
    notIn?: $Enums.contactSalaryPaymentPeriod[] | ListEnumcontactSalaryPaymentPeriodFieldRefInput<$PrismaModel>
    not?: NestedEnumcontactSalaryPaymentPeriodFilter<$PrismaModel> | $Enums.contactSalaryPaymentPeriod
  }

  export type NestedEnumcontactStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.contactStatus | EnumcontactStatusFieldRefInput<$PrismaModel>
    in?: $Enums.contactStatus[] | ListEnumcontactStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.contactStatus[] | ListEnumcontactStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumcontactStatusFilter<$PrismaModel> | $Enums.contactStatus
  }

  export type NestedEnumcontactTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.contactType | EnumcontactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.contactType[] | ListEnumcontactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.contactType[] | ListEnumcontactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumcontactTypeWithAggregatesFilter<$PrismaModel> | $Enums.contactType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumcontactTypeFilter<$PrismaModel>
    _max?: NestedEnumcontactTypeFilter<$PrismaModel>
  }

  export type NestedEnumcontactSalaryPaymentPeriodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.contactSalaryPaymentPeriod | EnumcontactSalaryPaymentPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.contactSalaryPaymentPeriod[] | ListEnumcontactSalaryPaymentPeriodFieldRefInput<$PrismaModel>
    notIn?: $Enums.contactSalaryPaymentPeriod[] | ListEnumcontactSalaryPaymentPeriodFieldRefInput<$PrismaModel>
    not?: NestedEnumcontactSalaryPaymentPeriodWithAggregatesFilter<$PrismaModel> | $Enums.contactSalaryPaymentPeriod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumcontactSalaryPaymentPeriodFilter<$PrismaModel>
    _max?: NestedEnumcontactSalaryPaymentPeriodFilter<$PrismaModel>
  }

  export type NestedEnumcontactStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.contactStatus | EnumcontactStatusFieldRefInput<$PrismaModel>
    in?: $Enums.contactStatus[] | ListEnumcontactStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.contactStatus[] | ListEnumcontactStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumcontactStatusWithAggregatesFilter<$PrismaModel> | $Enums.contactStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumcontactStatusFilter<$PrismaModel>
    _max?: NestedEnumcontactStatusFilter<$PrismaModel>
  }

  export type user_addressesCreateWithoutUserInput = {
    adress_line1: string
    adress_line2?: string | null
    city: string
    state?: string | null
    postal_code?: string | null
    country: string
    is_primary?: boolean | null
    created_at?: Date | string | null
  }

  export type user_addressesUncheckedCreateWithoutUserInput = {
    id?: number
    adress_line1: string
    adress_line2?: string | null
    city: string
    state?: string | null
    postal_code?: string | null
    country: string
    is_primary?: boolean | null
    created_at?: Date | string | null
  }

  export type user_addressesCreateOrConnectWithoutUserInput = {
    where: user_addressesWhereUniqueInput
    create: XOR<user_addressesCreateWithoutUserInput, user_addressesUncheckedCreateWithoutUserInput>
  }

  export type user_addressesCreateManyUserInputEnvelope = {
    data: user_addressesCreateManyUserInput | user_addressesCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type resumesCreateWithoutUserInput = {
    title: string
    file_url: string
    is_default?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    applications?: applicationsCreateNestedManyWithoutApplicationsInput
  }

  export type resumesUncheckedCreateWithoutUserInput = {
    id?: number
    title: string
    file_url: string
    is_default?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    applications?: applicationsUncheckedCreateNestedManyWithoutApplicationsInput
  }

  export type resumesCreateOrConnectWithoutUserInput = {
    where: resumesWhereUniqueInput
    create: XOR<resumesCreateWithoutUserInput, resumesUncheckedCreateWithoutUserInput>
  }

  export type resumesCreateManyUserInputEnvelope = {
    data: resumesCreateManyUserInput | resumesCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type educationsCreateWithoutUserInput = {
    institution: string
    degree: string
    field_of_study: string
    start_date: Date | string
    end_date: Date | string
    grade: string
    description: string
    is_foreign_education?: boolean
    country: string
  }

  export type educationsUncheckedCreateWithoutUserInput = {
    id?: number
    institution: string
    degree: string
    field_of_study: string
    start_date: Date | string
    end_date: Date | string
    grade: string
    description: string
    is_foreign_education?: boolean
    country: string
  }

  export type educationsCreateOrConnectWithoutUserInput = {
    where: educationsWhereUniqueInput
    create: XOR<educationsCreateWithoutUserInput, educationsUncheckedCreateWithoutUserInput>
  }

  export type educationsCreateManyUserInputEnvelope = {
    data: educationsCreateManyUserInput | educationsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type work_experiencesCreateWithoutUserInput = {
    company_name: string
    position: string
    location: string
    country: string
    start_date: Date | string
    end_date: Date | string
    is_current_job?: boolean
    description: string
    is_foregin_experience?: boolean
  }

  export type work_experiencesUncheckedCreateWithoutUserInput = {
    id?: number
    company_name: string
    position: string
    location: string
    country: string
    start_date: Date | string
    end_date: Date | string
    is_current_job?: boolean
    description: string
    is_foregin_experience?: boolean
  }

  export type work_experiencesCreateOrConnectWithoutUserInput = {
    where: work_experiencesWhereUniqueInput
    create: XOR<work_experiencesCreateWithoutUserInput, work_experiencesUncheckedCreateWithoutUserInput>
  }

  export type work_experiencesCreateManyUserInputEnvelope = {
    data: work_experiencesCreateManyUserInput | work_experiencesCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type skillsCreateWithoutUserInput = {
    skill_name: string
    proficiency?: $Enums.skillsstatus
    year_of_experience: number
    is_certifield?: boolean
  }

  export type skillsUncheckedCreateWithoutUserInput = {
    id?: number
    skill_name: string
    proficiency?: $Enums.skillsstatus
    year_of_experience: number
    is_certifield?: boolean
  }

  export type skillsCreateOrConnectWithoutUserInput = {
    where: skillsWhereUniqueInput
    create: XOR<skillsCreateWithoutUserInput, skillsUncheckedCreateWithoutUserInput>
  }

  export type skillsCreateManyUserInputEnvelope = {
    data: skillsCreateManyUserInput | skillsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type languagesCreateWithoutUserInput = {
    languages: string
    proficiency: $Enums.proficiencylanguages
    is_primary?: boolean
  }

  export type languagesUncheckedCreateWithoutUserInput = {
    id?: number
    languages: string
    proficiency: $Enums.proficiencylanguages
    is_primary?: boolean
  }

  export type languagesCreateOrConnectWithoutUserInput = {
    where: languagesWhereUniqueInput
    create: XOR<languagesCreateWithoutUserInput, languagesUncheckedCreateWithoutUserInput>
  }

  export type languagesCreateManyUserInputEnvelope = {
    data: languagesCreateManyUserInput | languagesCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type certificationsCreateWithoutUserInput = {
    name: string
    issuing_organization: string
    issue_date: Date | string
    expiration_date: Date | string
    credential_id: string
    credential_url: string
    is_foreign_certification?: boolean
  }

  export type certificationsUncheckedCreateWithoutUserInput = {
    id?: number
    name: string
    issuing_organization: string
    issue_date: Date | string
    expiration_date: Date | string
    credential_id: string
    credential_url: string
    is_foreign_certification?: boolean
  }

  export type certificationsCreateOrConnectWithoutUserInput = {
    where: certificationsWhereUniqueInput
    create: XOR<certificationsCreateWithoutUserInput, certificationsUncheckedCreateWithoutUserInput>
  }

  export type certificationsCreateManyUserInputEnvelope = {
    data: certificationsCreateManyUserInput | certificationsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type visa_informationCreateWithoutVisaInput = {
    visa_type: string
    country: string
    status: string
    expiry__date: Date | string
    is_multiple_entry?: boolean
    notes: string
  }

  export type visa_informationUncheckedCreateWithoutVisaInput = {
    id?: number
    visa_type: string
    country: string
    status: string
    expiry__date: Date | string
    is_multiple_entry?: boolean
    notes: string
  }

  export type visa_informationCreateOrConnectWithoutVisaInput = {
    where: visa_informationWhereUniqueInput
    create: XOR<visa_informationCreateWithoutVisaInput, visa_informationUncheckedCreateWithoutVisaInput>
  }

  export type visa_informationCreateManyVisaInputEnvelope = {
    data: visa_informationCreateManyVisaInput | visa_informationCreateManyVisaInput[]
    skipDuplicates?: boolean
  }

  export type applicationsCreateWithoutAplicationInput = {
    cover_letter: string
    status: $Enums.applicationStatus
    applited_at?: Date | string
    updated_at?: Date | string
    notes: string
    application: jobsCreateNestedOneWithoutApplicationInput
    applications: resumesCreateNestedOneWithoutApplicationsInput
    document?: application_documentsCreateNestedManyWithoutDocumentInput
    interview?: interviewsCreateNestedManyWithoutInterviewInput
  }

  export type applicationsUncheckedCreateWithoutAplicationInput = {
    id?: number
    job_id: number
    resume_id: number
    cover_letter: string
    status: $Enums.applicationStatus
    applited_at?: Date | string
    updated_at?: Date | string
    notes: string
    document?: application_documentsUncheckedCreateNestedManyWithoutDocumentInput
    interview?: interviewsUncheckedCreateNestedManyWithoutInterviewInput
  }

  export type applicationsCreateOrConnectWithoutAplicationInput = {
    where: applicationsWhereUniqueInput
    create: XOR<applicationsCreateWithoutAplicationInput, applicationsUncheckedCreateWithoutAplicationInput>
  }

  export type applicationsCreateManyAplicationInputEnvelope = {
    data: applicationsCreateManyAplicationInput | applicationsCreateManyAplicationInput[]
    skipDuplicates?: boolean
  }

  export type contactsCreateWithoutContactsInput = {
    contact_type: $Enums.contactType
    start_date: Date | string
    end_date: Date | string
    probation_period_months?: number
    salary_amount: number
    salary_currency: string
    salary_payment_period?: $Enums.contactSalaryPaymentPeriod
    benefits_description: string
    visa_sponsorship_details: string
    relocation_assistance_details: string
    status?: $Enums.contactStatus
    signed_at: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    contact: jobsCreateNestedOneWithoutContactInput
    contac: companiesCreateNestedOneWithoutContactsInput
  }

  export type contactsUncheckedCreateWithoutContactsInput = {
    id?: number
    job_id: number
    company_id: number
    contact_type: $Enums.contactType
    start_date: Date | string
    end_date: Date | string
    probation_period_months?: number
    salary_amount: number
    salary_currency: string
    salary_payment_period?: $Enums.contactSalaryPaymentPeriod
    benefits_description: string
    visa_sponsorship_details: string
    relocation_assistance_details: string
    status?: $Enums.contactStatus
    signed_at: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type contactsCreateOrConnectWithoutContactsInput = {
    where: contactsWhereUniqueInput
    create: XOR<contactsCreateWithoutContactsInput, contactsUncheckedCreateWithoutContactsInput>
  }

  export type contactsCreateManyContactsInputEnvelope = {
    data: contactsCreateManyContactsInput | contactsCreateManyContactsInput[]
    skipDuplicates?: boolean
  }

  export type notificationsCreateWithoutNotificationInput = {
    notification_type: string
    title: string
    message: string
    is_read?: boolean
    related_entity_type: string
    related_entity_id: number
    created_at?: Date | string
  }

  export type notificationsUncheckedCreateWithoutNotificationInput = {
    id?: number
    notification_type: string
    title: string
    message: string
    is_read?: boolean
    related_entity_type: string
    related_entity_id: number
    created_at?: Date | string
  }

  export type notificationsCreateOrConnectWithoutNotificationInput = {
    where: notificationsWhereUniqueInput
    create: XOR<notificationsCreateWithoutNotificationInput, notificationsUncheckedCreateWithoutNotificationInput>
  }

  export type notificationsCreateManyNotificationInputEnvelope = {
    data: notificationsCreateManyNotificationInput | notificationsCreateManyNotificationInput[]
    skipDuplicates?: boolean
  }

  export type saved_jobsCreateWithoutSavedjobInput = {
    saved_at?: Date | string
    notes: string
    savedjobs: jobsCreateNestedOneWithoutSavedjobInput
  }

  export type saved_jobsUncheckedCreateWithoutSavedjobInput = {
    id?: number
    job_id: number
    saved_at?: Date | string
    notes: string
  }

  export type saved_jobsCreateOrConnectWithoutSavedjobInput = {
    where: saved_jobsWhereUniqueInput
    create: XOR<saved_jobsCreateWithoutSavedjobInput, saved_jobsUncheckedCreateWithoutSavedjobInput>
  }

  export type saved_jobsCreateManySavedjobInputEnvelope = {
    data: saved_jobsCreateManySavedjobInput | saved_jobsCreateManySavedjobInput[]
    skipDuplicates?: boolean
  }

  export type job_searchesCreateWithoutSearchesInput = {
    search_query: string
    country: string
    city: string
    job_catregory: string
    experience_level: string
    job_type: string
    created_at?: Date | string
  }

  export type job_searchesUncheckedCreateWithoutSearchesInput = {
    id?: number
    search_query: string
    country: string
    city: string
    job_catregory: string
    experience_level: string
    job_type: string
    created_at?: Date | string
  }

  export type job_searchesCreateOrConnectWithoutSearchesInput = {
    where: job_searchesWhereUniqueInput
    create: XOR<job_searchesCreateWithoutSearchesInput, job_searchesUncheckedCreateWithoutSearchesInput>
  }

  export type job_searchesCreateManySearchesInputEnvelope = {
    data: job_searchesCreateManySearchesInput | job_searchesCreateManySearchesInput[]
    skipDuplicates?: boolean
  }

  export type user_addressesUpsertWithWhereUniqueWithoutUserInput = {
    where: user_addressesWhereUniqueInput
    update: XOR<user_addressesUpdateWithoutUserInput, user_addressesUncheckedUpdateWithoutUserInput>
    create: XOR<user_addressesCreateWithoutUserInput, user_addressesUncheckedCreateWithoutUserInput>
  }

  export type user_addressesUpdateWithWhereUniqueWithoutUserInput = {
    where: user_addressesWhereUniqueInput
    data: XOR<user_addressesUpdateWithoutUserInput, user_addressesUncheckedUpdateWithoutUserInput>
  }

  export type user_addressesUpdateManyWithWhereWithoutUserInput = {
    where: user_addressesScalarWhereInput
    data: XOR<user_addressesUpdateManyMutationInput, user_addressesUncheckedUpdateManyWithoutUserInput>
  }

  export type user_addressesScalarWhereInput = {
    AND?: user_addressesScalarWhereInput | user_addressesScalarWhereInput[]
    OR?: user_addressesScalarWhereInput[]
    NOT?: user_addressesScalarWhereInput | user_addressesScalarWhereInput[]
    id?: IntFilter<"user_addresses"> | number
    user_id?: IntFilter<"user_addresses"> | number
    adress_line1?: StringFilter<"user_addresses"> | string
    adress_line2?: StringNullableFilter<"user_addresses"> | string | null
    city?: StringFilter<"user_addresses"> | string
    state?: StringNullableFilter<"user_addresses"> | string | null
    postal_code?: StringNullableFilter<"user_addresses"> | string | null
    country?: StringFilter<"user_addresses"> | string
    is_primary?: BoolNullableFilter<"user_addresses"> | boolean | null
    created_at?: DateTimeNullableFilter<"user_addresses"> | Date | string | null
  }

  export type resumesUpsertWithWhereUniqueWithoutUserInput = {
    where: resumesWhereUniqueInput
    update: XOR<resumesUpdateWithoutUserInput, resumesUncheckedUpdateWithoutUserInput>
    create: XOR<resumesCreateWithoutUserInput, resumesUncheckedCreateWithoutUserInput>
  }

  export type resumesUpdateWithWhereUniqueWithoutUserInput = {
    where: resumesWhereUniqueInput
    data: XOR<resumesUpdateWithoutUserInput, resumesUncheckedUpdateWithoutUserInput>
  }

  export type resumesUpdateManyWithWhereWithoutUserInput = {
    where: resumesScalarWhereInput
    data: XOR<resumesUpdateManyMutationInput, resumesUncheckedUpdateManyWithoutUserInput>
  }

  export type resumesScalarWhereInput = {
    AND?: resumesScalarWhereInput | resumesScalarWhereInput[]
    OR?: resumesScalarWhereInput[]
    NOT?: resumesScalarWhereInput | resumesScalarWhereInput[]
    id?: IntFilter<"resumes"> | number
    user_id?: IntFilter<"resumes"> | number
    title?: StringFilter<"resumes"> | string
    file_url?: StringFilter<"resumes"> | string
    is_default?: BoolFilter<"resumes"> | boolean
    created_at?: DateTimeFilter<"resumes"> | Date | string
    updated_at?: DateTimeFilter<"resumes"> | Date | string
  }

  export type educationsUpsertWithWhereUniqueWithoutUserInput = {
    where: educationsWhereUniqueInput
    update: XOR<educationsUpdateWithoutUserInput, educationsUncheckedUpdateWithoutUserInput>
    create: XOR<educationsCreateWithoutUserInput, educationsUncheckedCreateWithoutUserInput>
  }

  export type educationsUpdateWithWhereUniqueWithoutUserInput = {
    where: educationsWhereUniqueInput
    data: XOR<educationsUpdateWithoutUserInput, educationsUncheckedUpdateWithoutUserInput>
  }

  export type educationsUpdateManyWithWhereWithoutUserInput = {
    where: educationsScalarWhereInput
    data: XOR<educationsUpdateManyMutationInput, educationsUncheckedUpdateManyWithoutUserInput>
  }

  export type educationsScalarWhereInput = {
    AND?: educationsScalarWhereInput | educationsScalarWhereInput[]
    OR?: educationsScalarWhereInput[]
    NOT?: educationsScalarWhereInput | educationsScalarWhereInput[]
    id?: IntFilter<"educations"> | number
    user_id?: IntFilter<"educations"> | number
    institution?: StringFilter<"educations"> | string
    degree?: StringFilter<"educations"> | string
    field_of_study?: StringFilter<"educations"> | string
    start_date?: DateTimeFilter<"educations"> | Date | string
    end_date?: DateTimeFilter<"educations"> | Date | string
    grade?: StringFilter<"educations"> | string
    description?: StringFilter<"educations"> | string
    is_foreign_education?: BoolFilter<"educations"> | boolean
    country?: StringFilter<"educations"> | string
  }

  export type work_experiencesUpsertWithWhereUniqueWithoutUserInput = {
    where: work_experiencesWhereUniqueInput
    update: XOR<work_experiencesUpdateWithoutUserInput, work_experiencesUncheckedUpdateWithoutUserInput>
    create: XOR<work_experiencesCreateWithoutUserInput, work_experiencesUncheckedCreateWithoutUserInput>
  }

  export type work_experiencesUpdateWithWhereUniqueWithoutUserInput = {
    where: work_experiencesWhereUniqueInput
    data: XOR<work_experiencesUpdateWithoutUserInput, work_experiencesUncheckedUpdateWithoutUserInput>
  }

  export type work_experiencesUpdateManyWithWhereWithoutUserInput = {
    where: work_experiencesScalarWhereInput
    data: XOR<work_experiencesUpdateManyMutationInput, work_experiencesUncheckedUpdateManyWithoutUserInput>
  }

  export type work_experiencesScalarWhereInput = {
    AND?: work_experiencesScalarWhereInput | work_experiencesScalarWhereInput[]
    OR?: work_experiencesScalarWhereInput[]
    NOT?: work_experiencesScalarWhereInput | work_experiencesScalarWhereInput[]
    id?: IntFilter<"work_experiences"> | number
    user_id?: IntFilter<"work_experiences"> | number
    company_name?: StringFilter<"work_experiences"> | string
    position?: StringFilter<"work_experiences"> | string
    location?: StringFilter<"work_experiences"> | string
    country?: StringFilter<"work_experiences"> | string
    start_date?: DateTimeFilter<"work_experiences"> | Date | string
    end_date?: DateTimeFilter<"work_experiences"> | Date | string
    is_current_job?: BoolFilter<"work_experiences"> | boolean
    description?: StringFilter<"work_experiences"> | string
    is_foregin_experience?: BoolFilter<"work_experiences"> | boolean
  }

  export type skillsUpsertWithWhereUniqueWithoutUserInput = {
    where: skillsWhereUniqueInput
    update: XOR<skillsUpdateWithoutUserInput, skillsUncheckedUpdateWithoutUserInput>
    create: XOR<skillsCreateWithoutUserInput, skillsUncheckedCreateWithoutUserInput>
  }

  export type skillsUpdateWithWhereUniqueWithoutUserInput = {
    where: skillsWhereUniqueInput
    data: XOR<skillsUpdateWithoutUserInput, skillsUncheckedUpdateWithoutUserInput>
  }

  export type skillsUpdateManyWithWhereWithoutUserInput = {
    where: skillsScalarWhereInput
    data: XOR<skillsUpdateManyMutationInput, skillsUncheckedUpdateManyWithoutUserInput>
  }

  export type skillsScalarWhereInput = {
    AND?: skillsScalarWhereInput | skillsScalarWhereInput[]
    OR?: skillsScalarWhereInput[]
    NOT?: skillsScalarWhereInput | skillsScalarWhereInput[]
    id?: IntFilter<"skills"> | number
    user_id?: IntFilter<"skills"> | number
    skill_name?: StringFilter<"skills"> | string
    proficiency?: EnumskillsstatusFilter<"skills"> | $Enums.skillsstatus
    year_of_experience?: IntFilter<"skills"> | number
    is_certifield?: BoolFilter<"skills"> | boolean
  }

  export type languagesUpsertWithWhereUniqueWithoutUserInput = {
    where: languagesWhereUniqueInput
    update: XOR<languagesUpdateWithoutUserInput, languagesUncheckedUpdateWithoutUserInput>
    create: XOR<languagesCreateWithoutUserInput, languagesUncheckedCreateWithoutUserInput>
  }

  export type languagesUpdateWithWhereUniqueWithoutUserInput = {
    where: languagesWhereUniqueInput
    data: XOR<languagesUpdateWithoutUserInput, languagesUncheckedUpdateWithoutUserInput>
  }

  export type languagesUpdateManyWithWhereWithoutUserInput = {
    where: languagesScalarWhereInput
    data: XOR<languagesUpdateManyMutationInput, languagesUncheckedUpdateManyWithoutUserInput>
  }

  export type languagesScalarWhereInput = {
    AND?: languagesScalarWhereInput | languagesScalarWhereInput[]
    OR?: languagesScalarWhereInput[]
    NOT?: languagesScalarWhereInput | languagesScalarWhereInput[]
    id?: IntFilter<"languages"> | number
    user_id?: IntFilter<"languages"> | number
    languages?: StringFilter<"languages"> | string
    proficiency?: EnumproficiencylanguagesFilter<"languages"> | $Enums.proficiencylanguages
    is_primary?: BoolFilter<"languages"> | boolean
  }

  export type certificationsUpsertWithWhereUniqueWithoutUserInput = {
    where: certificationsWhereUniqueInput
    update: XOR<certificationsUpdateWithoutUserInput, certificationsUncheckedUpdateWithoutUserInput>
    create: XOR<certificationsCreateWithoutUserInput, certificationsUncheckedCreateWithoutUserInput>
  }

  export type certificationsUpdateWithWhereUniqueWithoutUserInput = {
    where: certificationsWhereUniqueInput
    data: XOR<certificationsUpdateWithoutUserInput, certificationsUncheckedUpdateWithoutUserInput>
  }

  export type certificationsUpdateManyWithWhereWithoutUserInput = {
    where: certificationsScalarWhereInput
    data: XOR<certificationsUpdateManyMutationInput, certificationsUncheckedUpdateManyWithoutUserInput>
  }

  export type certificationsScalarWhereInput = {
    AND?: certificationsScalarWhereInput | certificationsScalarWhereInput[]
    OR?: certificationsScalarWhereInput[]
    NOT?: certificationsScalarWhereInput | certificationsScalarWhereInput[]
    id?: IntFilter<"certifications"> | number
    user_id?: IntFilter<"certifications"> | number
    name?: StringFilter<"certifications"> | string
    issuing_organization?: StringFilter<"certifications"> | string
    issue_date?: DateTimeFilter<"certifications"> | Date | string
    expiration_date?: DateTimeFilter<"certifications"> | Date | string
    credential_id?: StringFilter<"certifications"> | string
    credential_url?: StringFilter<"certifications"> | string
    is_foreign_certification?: BoolFilter<"certifications"> | boolean
  }

  export type visa_informationUpsertWithWhereUniqueWithoutVisaInput = {
    where: visa_informationWhereUniqueInput
    update: XOR<visa_informationUpdateWithoutVisaInput, visa_informationUncheckedUpdateWithoutVisaInput>
    create: XOR<visa_informationCreateWithoutVisaInput, visa_informationUncheckedCreateWithoutVisaInput>
  }

  export type visa_informationUpdateWithWhereUniqueWithoutVisaInput = {
    where: visa_informationWhereUniqueInput
    data: XOR<visa_informationUpdateWithoutVisaInput, visa_informationUncheckedUpdateWithoutVisaInput>
  }

  export type visa_informationUpdateManyWithWhereWithoutVisaInput = {
    where: visa_informationScalarWhereInput
    data: XOR<visa_informationUpdateManyMutationInput, visa_informationUncheckedUpdateManyWithoutVisaInput>
  }

  export type visa_informationScalarWhereInput = {
    AND?: visa_informationScalarWhereInput | visa_informationScalarWhereInput[]
    OR?: visa_informationScalarWhereInput[]
    NOT?: visa_informationScalarWhereInput | visa_informationScalarWhereInput[]
    id?: IntFilter<"visa_information"> | number
    user_id?: IntFilter<"visa_information"> | number
    visa_type?: StringFilter<"visa_information"> | string
    country?: StringFilter<"visa_information"> | string
    status?: StringFilter<"visa_information"> | string
    expiry__date?: DateTimeFilter<"visa_information"> | Date | string
    is_multiple_entry?: BoolFilter<"visa_information"> | boolean
    notes?: StringFilter<"visa_information"> | string
  }

  export type applicationsUpsertWithWhereUniqueWithoutAplicationInput = {
    where: applicationsWhereUniqueInput
    update: XOR<applicationsUpdateWithoutAplicationInput, applicationsUncheckedUpdateWithoutAplicationInput>
    create: XOR<applicationsCreateWithoutAplicationInput, applicationsUncheckedCreateWithoutAplicationInput>
  }

  export type applicationsUpdateWithWhereUniqueWithoutAplicationInput = {
    where: applicationsWhereUniqueInput
    data: XOR<applicationsUpdateWithoutAplicationInput, applicationsUncheckedUpdateWithoutAplicationInput>
  }

  export type applicationsUpdateManyWithWhereWithoutAplicationInput = {
    where: applicationsScalarWhereInput
    data: XOR<applicationsUpdateManyMutationInput, applicationsUncheckedUpdateManyWithoutAplicationInput>
  }

  export type applicationsScalarWhereInput = {
    AND?: applicationsScalarWhereInput | applicationsScalarWhereInput[]
    OR?: applicationsScalarWhereInput[]
    NOT?: applicationsScalarWhereInput | applicationsScalarWhereInput[]
    id?: IntFilter<"applications"> | number
    job_id?: IntFilter<"applications"> | number
    user_id?: IntFilter<"applications"> | number
    resume_id?: IntFilter<"applications"> | number
    cover_letter?: StringFilter<"applications"> | string
    status?: EnumapplicationStatusFilter<"applications"> | $Enums.applicationStatus
    applited_at?: DateTimeFilter<"applications"> | Date | string
    updated_at?: DateTimeFilter<"applications"> | Date | string
    notes?: StringFilter<"applications"> | string
  }

  export type contactsUpsertWithWhereUniqueWithoutContactsInput = {
    where: contactsWhereUniqueInput
    update: XOR<contactsUpdateWithoutContactsInput, contactsUncheckedUpdateWithoutContactsInput>
    create: XOR<contactsCreateWithoutContactsInput, contactsUncheckedCreateWithoutContactsInput>
  }

  export type contactsUpdateWithWhereUniqueWithoutContactsInput = {
    where: contactsWhereUniqueInput
    data: XOR<contactsUpdateWithoutContactsInput, contactsUncheckedUpdateWithoutContactsInput>
  }

  export type contactsUpdateManyWithWhereWithoutContactsInput = {
    where: contactsScalarWhereInput
    data: XOR<contactsUpdateManyMutationInput, contactsUncheckedUpdateManyWithoutContactsInput>
  }

  export type contactsScalarWhereInput = {
    AND?: contactsScalarWhereInput | contactsScalarWhereInput[]
    OR?: contactsScalarWhereInput[]
    NOT?: contactsScalarWhereInput | contactsScalarWhereInput[]
    id?: IntFilter<"contacts"> | number
    job_id?: IntFilter<"contacts"> | number
    user_id?: IntFilter<"contacts"> | number
    company_id?: IntFilter<"contacts"> | number
    contact_type?: EnumcontactTypeFilter<"contacts"> | $Enums.contactType
    start_date?: DateTimeFilter<"contacts"> | Date | string
    end_date?: DateTimeFilter<"contacts"> | Date | string
    probation_period_months?: IntFilter<"contacts"> | number
    salary_amount?: IntFilter<"contacts"> | number
    salary_currency?: StringFilter<"contacts"> | string
    salary_payment_period?: EnumcontactSalaryPaymentPeriodFilter<"contacts"> | $Enums.contactSalaryPaymentPeriod
    benefits_description?: StringFilter<"contacts"> | string
    visa_sponsorship_details?: StringFilter<"contacts"> | string
    relocation_assistance_details?: StringFilter<"contacts"> | string
    status?: EnumcontactStatusFilter<"contacts"> | $Enums.contactStatus
    signed_at?: DateTimeFilter<"contacts"> | Date | string
    created_at?: DateTimeFilter<"contacts"> | Date | string
    updated_at?: DateTimeFilter<"contacts"> | Date | string
  }

  export type notificationsUpsertWithWhereUniqueWithoutNotificationInput = {
    where: notificationsWhereUniqueInput
    update: XOR<notificationsUpdateWithoutNotificationInput, notificationsUncheckedUpdateWithoutNotificationInput>
    create: XOR<notificationsCreateWithoutNotificationInput, notificationsUncheckedCreateWithoutNotificationInput>
  }

  export type notificationsUpdateWithWhereUniqueWithoutNotificationInput = {
    where: notificationsWhereUniqueInput
    data: XOR<notificationsUpdateWithoutNotificationInput, notificationsUncheckedUpdateWithoutNotificationInput>
  }

  export type notificationsUpdateManyWithWhereWithoutNotificationInput = {
    where: notificationsScalarWhereInput
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyWithoutNotificationInput>
  }

  export type notificationsScalarWhereInput = {
    AND?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
    OR?: notificationsScalarWhereInput[]
    NOT?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
    id?: IntFilter<"notifications"> | number
    user_id?: IntFilter<"notifications"> | number
    notification_type?: StringFilter<"notifications"> | string
    title?: StringFilter<"notifications"> | string
    message?: StringFilter<"notifications"> | string
    is_read?: BoolFilter<"notifications"> | boolean
    related_entity_type?: StringFilter<"notifications"> | string
    related_entity_id?: IntFilter<"notifications"> | number
    created_at?: DateTimeFilter<"notifications"> | Date | string
  }

  export type saved_jobsUpsertWithWhereUniqueWithoutSavedjobInput = {
    where: saved_jobsWhereUniqueInput
    update: XOR<saved_jobsUpdateWithoutSavedjobInput, saved_jobsUncheckedUpdateWithoutSavedjobInput>
    create: XOR<saved_jobsCreateWithoutSavedjobInput, saved_jobsUncheckedCreateWithoutSavedjobInput>
  }

  export type saved_jobsUpdateWithWhereUniqueWithoutSavedjobInput = {
    where: saved_jobsWhereUniqueInput
    data: XOR<saved_jobsUpdateWithoutSavedjobInput, saved_jobsUncheckedUpdateWithoutSavedjobInput>
  }

  export type saved_jobsUpdateManyWithWhereWithoutSavedjobInput = {
    where: saved_jobsScalarWhereInput
    data: XOR<saved_jobsUpdateManyMutationInput, saved_jobsUncheckedUpdateManyWithoutSavedjobInput>
  }

  export type saved_jobsScalarWhereInput = {
    AND?: saved_jobsScalarWhereInput | saved_jobsScalarWhereInput[]
    OR?: saved_jobsScalarWhereInput[]
    NOT?: saved_jobsScalarWhereInput | saved_jobsScalarWhereInput[]
    id?: IntFilter<"saved_jobs"> | number
    user_id?: IntFilter<"saved_jobs"> | number
    job_id?: IntFilter<"saved_jobs"> | number
    saved_at?: DateTimeFilter<"saved_jobs"> | Date | string
    notes?: StringFilter<"saved_jobs"> | string
  }

  export type job_searchesUpsertWithWhereUniqueWithoutSearchesInput = {
    where: job_searchesWhereUniqueInput
    update: XOR<job_searchesUpdateWithoutSearchesInput, job_searchesUncheckedUpdateWithoutSearchesInput>
    create: XOR<job_searchesCreateWithoutSearchesInput, job_searchesUncheckedCreateWithoutSearchesInput>
  }

  export type job_searchesUpdateWithWhereUniqueWithoutSearchesInput = {
    where: job_searchesWhereUniqueInput
    data: XOR<job_searchesUpdateWithoutSearchesInput, job_searchesUncheckedUpdateWithoutSearchesInput>
  }

  export type job_searchesUpdateManyWithWhereWithoutSearchesInput = {
    where: job_searchesScalarWhereInput
    data: XOR<job_searchesUpdateManyMutationInput, job_searchesUncheckedUpdateManyWithoutSearchesInput>
  }

  export type job_searchesScalarWhereInput = {
    AND?: job_searchesScalarWhereInput | job_searchesScalarWhereInput[]
    OR?: job_searchesScalarWhereInput[]
    NOT?: job_searchesScalarWhereInput | job_searchesScalarWhereInput[]
    id?: IntFilter<"job_searches"> | number
    user_id?: IntFilter<"job_searches"> | number
    search_query?: StringFilter<"job_searches"> | string
    country?: StringFilter<"job_searches"> | string
    city?: StringFilter<"job_searches"> | string
    job_catregory?: StringFilter<"job_searches"> | string
    experience_level?: StringFilter<"job_searches"> | string
    job_type?: StringFilter<"job_searches"> | string
    created_at?: DateTimeFilter<"job_searches"> | Date | string
  }

  export type usersCreateWithoutAddressesInput = {
    first_name: string
    last_name: string
    email: string
    password_hash: string
    phone_number?: string | null
    country_code?: string | null
    date_of_birth?: Date | string | null
    gender?: string | null
    profile_picture_url?: string | null
    bio?: string | null
    created_at?: Date | string
    updated_at: Date | string
    last_login_at?: Date | string | null
    status?: $Enums.userstatus
    resumes?: resumesCreateNestedManyWithoutUserInput
    educations?: educationsCreateNestedManyWithoutUserInput
    experiences?: work_experiencesCreateNestedManyWithoutUserInput
    skills?: skillsCreateNestedManyWithoutUserInput
    languages?: languagesCreateNestedManyWithoutUserInput
    certifications?: certificationsCreateNestedManyWithoutUserInput
    visa?: visa_informationCreateNestedManyWithoutVisaInput
    application?: applicationsCreateNestedManyWithoutAplicationInput
    contacts?: contactsCreateNestedManyWithoutContactsInput
    notification?: notificationsCreateNestedManyWithoutNotificationInput
    savedjob?: saved_jobsCreateNestedManyWithoutSavedjobInput
    searches?: job_searchesCreateNestedManyWithoutSearchesInput
  }

  export type usersUncheckedCreateWithoutAddressesInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password_hash: string
    phone_number?: string | null
    country_code?: string | null
    date_of_birth?: Date | string | null
    gender?: string | null
    profile_picture_url?: string | null
    bio?: string | null
    created_at?: Date | string
    updated_at: Date | string
    last_login_at?: Date | string | null
    status?: $Enums.userstatus
    resumes?: resumesUncheckedCreateNestedManyWithoutUserInput
    educations?: educationsUncheckedCreateNestedManyWithoutUserInput
    experiences?: work_experiencesUncheckedCreateNestedManyWithoutUserInput
    skills?: skillsUncheckedCreateNestedManyWithoutUserInput
    languages?: languagesUncheckedCreateNestedManyWithoutUserInput
    certifications?: certificationsUncheckedCreateNestedManyWithoutUserInput
    visa?: visa_informationUncheckedCreateNestedManyWithoutVisaInput
    application?: applicationsUncheckedCreateNestedManyWithoutAplicationInput
    contacts?: contactsUncheckedCreateNestedManyWithoutContactsInput
    notification?: notificationsUncheckedCreateNestedManyWithoutNotificationInput
    savedjob?: saved_jobsUncheckedCreateNestedManyWithoutSavedjobInput
    searches?: job_searchesUncheckedCreateNestedManyWithoutSearchesInput
  }

  export type usersCreateOrConnectWithoutAddressesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutAddressesInput, usersUncheckedCreateWithoutAddressesInput>
  }

  export type usersUpsertWithoutAddressesInput = {
    update: XOR<usersUpdateWithoutAddressesInput, usersUncheckedUpdateWithoutAddressesInput>
    create: XOR<usersCreateWithoutAddressesInput, usersUncheckedCreateWithoutAddressesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutAddressesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutAddressesInput, usersUncheckedUpdateWithoutAddressesInput>
  }

  export type usersUpdateWithoutAddressesInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumuserstatusFieldUpdateOperationsInput | $Enums.userstatus
    resumes?: resumesUpdateManyWithoutUserNestedInput
    educations?: educationsUpdateManyWithoutUserNestedInput
    experiences?: work_experiencesUpdateManyWithoutUserNestedInput
    skills?: skillsUpdateManyWithoutUserNestedInput
    languages?: languagesUpdateManyWithoutUserNestedInput
    certifications?: certificationsUpdateManyWithoutUserNestedInput
    visa?: visa_informationUpdateManyWithoutVisaNestedInput
    application?: applicationsUpdateManyWithoutAplicationNestedInput
    contacts?: contactsUpdateManyWithoutContactsNestedInput
    notification?: notificationsUpdateManyWithoutNotificationNestedInput
    savedjob?: saved_jobsUpdateManyWithoutSavedjobNestedInput
    searches?: job_searchesUpdateManyWithoutSearchesNestedInput
  }

  export type usersUncheckedUpdateWithoutAddressesInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumuserstatusFieldUpdateOperationsInput | $Enums.userstatus
    resumes?: resumesUncheckedUpdateManyWithoutUserNestedInput
    educations?: educationsUncheckedUpdateManyWithoutUserNestedInput
    experiences?: work_experiencesUncheckedUpdateManyWithoutUserNestedInput
    skills?: skillsUncheckedUpdateManyWithoutUserNestedInput
    languages?: languagesUncheckedUpdateManyWithoutUserNestedInput
    certifications?: certificationsUncheckedUpdateManyWithoutUserNestedInput
    visa?: visa_informationUncheckedUpdateManyWithoutVisaNestedInput
    application?: applicationsUncheckedUpdateManyWithoutAplicationNestedInput
    contacts?: contactsUncheckedUpdateManyWithoutContactsNestedInput
    notification?: notificationsUncheckedUpdateManyWithoutNotificationNestedInput
    savedjob?: saved_jobsUncheckedUpdateManyWithoutSavedjobNestedInput
    searches?: job_searchesUncheckedUpdateManyWithoutSearchesNestedInput
  }

  export type applicationsCreateWithoutApplicationsInput = {
    cover_letter: string
    status: $Enums.applicationStatus
    applited_at?: Date | string
    updated_at?: Date | string
    notes: string
    application: jobsCreateNestedOneWithoutApplicationInput
    aplication: usersCreateNestedOneWithoutApplicationInput
    document?: application_documentsCreateNestedManyWithoutDocumentInput
    interview?: interviewsCreateNestedManyWithoutInterviewInput
  }

  export type applicationsUncheckedCreateWithoutApplicationsInput = {
    id?: number
    job_id: number
    user_id: number
    cover_letter: string
    status: $Enums.applicationStatus
    applited_at?: Date | string
    updated_at?: Date | string
    notes: string
    document?: application_documentsUncheckedCreateNestedManyWithoutDocumentInput
    interview?: interviewsUncheckedCreateNestedManyWithoutInterviewInput
  }

  export type applicationsCreateOrConnectWithoutApplicationsInput = {
    where: applicationsWhereUniqueInput
    create: XOR<applicationsCreateWithoutApplicationsInput, applicationsUncheckedCreateWithoutApplicationsInput>
  }

  export type applicationsCreateManyApplicationsInputEnvelope = {
    data: applicationsCreateManyApplicationsInput | applicationsCreateManyApplicationsInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutResumesInput = {
    first_name: string
    last_name: string
    email: string
    password_hash: string
    phone_number?: string | null
    country_code?: string | null
    date_of_birth?: Date | string | null
    gender?: string | null
    profile_picture_url?: string | null
    bio?: string | null
    created_at?: Date | string
    updated_at: Date | string
    last_login_at?: Date | string | null
    status?: $Enums.userstatus
    addresses?: user_addressesCreateNestedManyWithoutUserInput
    educations?: educationsCreateNestedManyWithoutUserInput
    experiences?: work_experiencesCreateNestedManyWithoutUserInput
    skills?: skillsCreateNestedManyWithoutUserInput
    languages?: languagesCreateNestedManyWithoutUserInput
    certifications?: certificationsCreateNestedManyWithoutUserInput
    visa?: visa_informationCreateNestedManyWithoutVisaInput
    application?: applicationsCreateNestedManyWithoutAplicationInput
    contacts?: contactsCreateNestedManyWithoutContactsInput
    notification?: notificationsCreateNestedManyWithoutNotificationInput
    savedjob?: saved_jobsCreateNestedManyWithoutSavedjobInput
    searches?: job_searchesCreateNestedManyWithoutSearchesInput
  }

  export type usersUncheckedCreateWithoutResumesInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password_hash: string
    phone_number?: string | null
    country_code?: string | null
    date_of_birth?: Date | string | null
    gender?: string | null
    profile_picture_url?: string | null
    bio?: string | null
    created_at?: Date | string
    updated_at: Date | string
    last_login_at?: Date | string | null
    status?: $Enums.userstatus
    addresses?: user_addressesUncheckedCreateNestedManyWithoutUserInput
    educations?: educationsUncheckedCreateNestedManyWithoutUserInput
    experiences?: work_experiencesUncheckedCreateNestedManyWithoutUserInput
    skills?: skillsUncheckedCreateNestedManyWithoutUserInput
    languages?: languagesUncheckedCreateNestedManyWithoutUserInput
    certifications?: certificationsUncheckedCreateNestedManyWithoutUserInput
    visa?: visa_informationUncheckedCreateNestedManyWithoutVisaInput
    application?: applicationsUncheckedCreateNestedManyWithoutAplicationInput
    contacts?: contactsUncheckedCreateNestedManyWithoutContactsInput
    notification?: notificationsUncheckedCreateNestedManyWithoutNotificationInput
    savedjob?: saved_jobsUncheckedCreateNestedManyWithoutSavedjobInput
    searches?: job_searchesUncheckedCreateNestedManyWithoutSearchesInput
  }

  export type usersCreateOrConnectWithoutResumesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutResumesInput, usersUncheckedCreateWithoutResumesInput>
  }

  export type applicationsUpsertWithWhereUniqueWithoutApplicationsInput = {
    where: applicationsWhereUniqueInput
    update: XOR<applicationsUpdateWithoutApplicationsInput, applicationsUncheckedUpdateWithoutApplicationsInput>
    create: XOR<applicationsCreateWithoutApplicationsInput, applicationsUncheckedCreateWithoutApplicationsInput>
  }

  export type applicationsUpdateWithWhereUniqueWithoutApplicationsInput = {
    where: applicationsWhereUniqueInput
    data: XOR<applicationsUpdateWithoutApplicationsInput, applicationsUncheckedUpdateWithoutApplicationsInput>
  }

  export type applicationsUpdateManyWithWhereWithoutApplicationsInput = {
    where: applicationsScalarWhereInput
    data: XOR<applicationsUpdateManyMutationInput, applicationsUncheckedUpdateManyWithoutApplicationsInput>
  }

  export type usersUpsertWithoutResumesInput = {
    update: XOR<usersUpdateWithoutResumesInput, usersUncheckedUpdateWithoutResumesInput>
    create: XOR<usersCreateWithoutResumesInput, usersUncheckedCreateWithoutResumesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutResumesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutResumesInput, usersUncheckedUpdateWithoutResumesInput>
  }

  export type usersUpdateWithoutResumesInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumuserstatusFieldUpdateOperationsInput | $Enums.userstatus
    addresses?: user_addressesUpdateManyWithoutUserNestedInput
    educations?: educationsUpdateManyWithoutUserNestedInput
    experiences?: work_experiencesUpdateManyWithoutUserNestedInput
    skills?: skillsUpdateManyWithoutUserNestedInput
    languages?: languagesUpdateManyWithoutUserNestedInput
    certifications?: certificationsUpdateManyWithoutUserNestedInput
    visa?: visa_informationUpdateManyWithoutVisaNestedInput
    application?: applicationsUpdateManyWithoutAplicationNestedInput
    contacts?: contactsUpdateManyWithoutContactsNestedInput
    notification?: notificationsUpdateManyWithoutNotificationNestedInput
    savedjob?: saved_jobsUpdateManyWithoutSavedjobNestedInput
    searches?: job_searchesUpdateManyWithoutSearchesNestedInput
  }

  export type usersUncheckedUpdateWithoutResumesInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumuserstatusFieldUpdateOperationsInput | $Enums.userstatus
    addresses?: user_addressesUncheckedUpdateManyWithoutUserNestedInput
    educations?: educationsUncheckedUpdateManyWithoutUserNestedInput
    experiences?: work_experiencesUncheckedUpdateManyWithoutUserNestedInput
    skills?: skillsUncheckedUpdateManyWithoutUserNestedInput
    languages?: languagesUncheckedUpdateManyWithoutUserNestedInput
    certifications?: certificationsUncheckedUpdateManyWithoutUserNestedInput
    visa?: visa_informationUncheckedUpdateManyWithoutVisaNestedInput
    application?: applicationsUncheckedUpdateManyWithoutAplicationNestedInput
    contacts?: contactsUncheckedUpdateManyWithoutContactsNestedInput
    notification?: notificationsUncheckedUpdateManyWithoutNotificationNestedInput
    savedjob?: saved_jobsUncheckedUpdateManyWithoutSavedjobNestedInput
    searches?: job_searchesUncheckedUpdateManyWithoutSearchesNestedInput
  }

  export type usersCreateWithoutEducationsInput = {
    first_name: string
    last_name: string
    email: string
    password_hash: string
    phone_number?: string | null
    country_code?: string | null
    date_of_birth?: Date | string | null
    gender?: string | null
    profile_picture_url?: string | null
    bio?: string | null
    created_at?: Date | string
    updated_at: Date | string
    last_login_at?: Date | string | null
    status?: $Enums.userstatus
    addresses?: user_addressesCreateNestedManyWithoutUserInput
    resumes?: resumesCreateNestedManyWithoutUserInput
    experiences?: work_experiencesCreateNestedManyWithoutUserInput
    skills?: skillsCreateNestedManyWithoutUserInput
    languages?: languagesCreateNestedManyWithoutUserInput
    certifications?: certificationsCreateNestedManyWithoutUserInput
    visa?: visa_informationCreateNestedManyWithoutVisaInput
    application?: applicationsCreateNestedManyWithoutAplicationInput
    contacts?: contactsCreateNestedManyWithoutContactsInput
    notification?: notificationsCreateNestedManyWithoutNotificationInput
    savedjob?: saved_jobsCreateNestedManyWithoutSavedjobInput
    searches?: job_searchesCreateNestedManyWithoutSearchesInput
  }

  export type usersUncheckedCreateWithoutEducationsInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password_hash: string
    phone_number?: string | null
    country_code?: string | null
    date_of_birth?: Date | string | null
    gender?: string | null
    profile_picture_url?: string | null
    bio?: string | null
    created_at?: Date | string
    updated_at: Date | string
    last_login_at?: Date | string | null
    status?: $Enums.userstatus
    addresses?: user_addressesUncheckedCreateNestedManyWithoutUserInput
    resumes?: resumesUncheckedCreateNestedManyWithoutUserInput
    experiences?: work_experiencesUncheckedCreateNestedManyWithoutUserInput
    skills?: skillsUncheckedCreateNestedManyWithoutUserInput
    languages?: languagesUncheckedCreateNestedManyWithoutUserInput
    certifications?: certificationsUncheckedCreateNestedManyWithoutUserInput
    visa?: visa_informationUncheckedCreateNestedManyWithoutVisaInput
    application?: applicationsUncheckedCreateNestedManyWithoutAplicationInput
    contacts?: contactsUncheckedCreateNestedManyWithoutContactsInput
    notification?: notificationsUncheckedCreateNestedManyWithoutNotificationInput
    savedjob?: saved_jobsUncheckedCreateNestedManyWithoutSavedjobInput
    searches?: job_searchesUncheckedCreateNestedManyWithoutSearchesInput
  }

  export type usersCreateOrConnectWithoutEducationsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutEducationsInput, usersUncheckedCreateWithoutEducationsInput>
  }

  export type usersUpsertWithoutEducationsInput = {
    update: XOR<usersUpdateWithoutEducationsInput, usersUncheckedUpdateWithoutEducationsInput>
    create: XOR<usersCreateWithoutEducationsInput, usersUncheckedCreateWithoutEducationsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutEducationsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutEducationsInput, usersUncheckedUpdateWithoutEducationsInput>
  }

  export type usersUpdateWithoutEducationsInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumuserstatusFieldUpdateOperationsInput | $Enums.userstatus
    addresses?: user_addressesUpdateManyWithoutUserNestedInput
    resumes?: resumesUpdateManyWithoutUserNestedInput
    experiences?: work_experiencesUpdateManyWithoutUserNestedInput
    skills?: skillsUpdateManyWithoutUserNestedInput
    languages?: languagesUpdateManyWithoutUserNestedInput
    certifications?: certificationsUpdateManyWithoutUserNestedInput
    visa?: visa_informationUpdateManyWithoutVisaNestedInput
    application?: applicationsUpdateManyWithoutAplicationNestedInput
    contacts?: contactsUpdateManyWithoutContactsNestedInput
    notification?: notificationsUpdateManyWithoutNotificationNestedInput
    savedjob?: saved_jobsUpdateManyWithoutSavedjobNestedInput
    searches?: job_searchesUpdateManyWithoutSearchesNestedInput
  }

  export type usersUncheckedUpdateWithoutEducationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumuserstatusFieldUpdateOperationsInput | $Enums.userstatus
    addresses?: user_addressesUncheckedUpdateManyWithoutUserNestedInput
    resumes?: resumesUncheckedUpdateManyWithoutUserNestedInput
    experiences?: work_experiencesUncheckedUpdateManyWithoutUserNestedInput
    skills?: skillsUncheckedUpdateManyWithoutUserNestedInput
    languages?: languagesUncheckedUpdateManyWithoutUserNestedInput
    certifications?: certificationsUncheckedUpdateManyWithoutUserNestedInput
    visa?: visa_informationUncheckedUpdateManyWithoutVisaNestedInput
    application?: applicationsUncheckedUpdateManyWithoutAplicationNestedInput
    contacts?: contactsUncheckedUpdateManyWithoutContactsNestedInput
    notification?: notificationsUncheckedUpdateManyWithoutNotificationNestedInput
    savedjob?: saved_jobsUncheckedUpdateManyWithoutSavedjobNestedInput
    searches?: job_searchesUncheckedUpdateManyWithoutSearchesNestedInput
  }

  export type usersCreateWithoutExperiencesInput = {
    first_name: string
    last_name: string
    email: string
    password_hash: string
    phone_number?: string | null
    country_code?: string | null
    date_of_birth?: Date | string | null
    gender?: string | null
    profile_picture_url?: string | null
    bio?: string | null
    created_at?: Date | string
    updated_at: Date | string
    last_login_at?: Date | string | null
    status?: $Enums.userstatus
    addresses?: user_addressesCreateNestedManyWithoutUserInput
    resumes?: resumesCreateNestedManyWithoutUserInput
    educations?: educationsCreateNestedManyWithoutUserInput
    skills?: skillsCreateNestedManyWithoutUserInput
    languages?: languagesCreateNestedManyWithoutUserInput
    certifications?: certificationsCreateNestedManyWithoutUserInput
    visa?: visa_informationCreateNestedManyWithoutVisaInput
    application?: applicationsCreateNestedManyWithoutAplicationInput
    contacts?: contactsCreateNestedManyWithoutContactsInput
    notification?: notificationsCreateNestedManyWithoutNotificationInput
    savedjob?: saved_jobsCreateNestedManyWithoutSavedjobInput
    searches?: job_searchesCreateNestedManyWithoutSearchesInput
  }

  export type usersUncheckedCreateWithoutExperiencesInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password_hash: string
    phone_number?: string | null
    country_code?: string | null
    date_of_birth?: Date | string | null
    gender?: string | null
    profile_picture_url?: string | null
    bio?: string | null
    created_at?: Date | string
    updated_at: Date | string
    last_login_at?: Date | string | null
    status?: $Enums.userstatus
    addresses?: user_addressesUncheckedCreateNestedManyWithoutUserInput
    resumes?: resumesUncheckedCreateNestedManyWithoutUserInput
    educations?: educationsUncheckedCreateNestedManyWithoutUserInput
    skills?: skillsUncheckedCreateNestedManyWithoutUserInput
    languages?: languagesUncheckedCreateNestedManyWithoutUserInput
    certifications?: certificationsUncheckedCreateNestedManyWithoutUserInput
    visa?: visa_informationUncheckedCreateNestedManyWithoutVisaInput
    application?: applicationsUncheckedCreateNestedManyWithoutAplicationInput
    contacts?: contactsUncheckedCreateNestedManyWithoutContactsInput
    notification?: notificationsUncheckedCreateNestedManyWithoutNotificationInput
    savedjob?: saved_jobsUncheckedCreateNestedManyWithoutSavedjobInput
    searches?: job_searchesUncheckedCreateNestedManyWithoutSearchesInput
  }

  export type usersCreateOrConnectWithoutExperiencesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutExperiencesInput, usersUncheckedCreateWithoutExperiencesInput>
  }

  export type usersUpsertWithoutExperiencesInput = {
    update: XOR<usersUpdateWithoutExperiencesInput, usersUncheckedUpdateWithoutExperiencesInput>
    create: XOR<usersCreateWithoutExperiencesInput, usersUncheckedCreateWithoutExperiencesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutExperiencesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutExperiencesInput, usersUncheckedUpdateWithoutExperiencesInput>
  }

  export type usersUpdateWithoutExperiencesInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumuserstatusFieldUpdateOperationsInput | $Enums.userstatus
    addresses?: user_addressesUpdateManyWithoutUserNestedInput
    resumes?: resumesUpdateManyWithoutUserNestedInput
    educations?: educationsUpdateManyWithoutUserNestedInput
    skills?: skillsUpdateManyWithoutUserNestedInput
    languages?: languagesUpdateManyWithoutUserNestedInput
    certifications?: certificationsUpdateManyWithoutUserNestedInput
    visa?: visa_informationUpdateManyWithoutVisaNestedInput
    application?: applicationsUpdateManyWithoutAplicationNestedInput
    contacts?: contactsUpdateManyWithoutContactsNestedInput
    notification?: notificationsUpdateManyWithoutNotificationNestedInput
    savedjob?: saved_jobsUpdateManyWithoutSavedjobNestedInput
    searches?: job_searchesUpdateManyWithoutSearchesNestedInput
  }

  export type usersUncheckedUpdateWithoutExperiencesInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumuserstatusFieldUpdateOperationsInput | $Enums.userstatus
    addresses?: user_addressesUncheckedUpdateManyWithoutUserNestedInput
    resumes?: resumesUncheckedUpdateManyWithoutUserNestedInput
    educations?: educationsUncheckedUpdateManyWithoutUserNestedInput
    skills?: skillsUncheckedUpdateManyWithoutUserNestedInput
    languages?: languagesUncheckedUpdateManyWithoutUserNestedInput
    certifications?: certificationsUncheckedUpdateManyWithoutUserNestedInput
    visa?: visa_informationUncheckedUpdateManyWithoutVisaNestedInput
    application?: applicationsUncheckedUpdateManyWithoutAplicationNestedInput
    contacts?: contactsUncheckedUpdateManyWithoutContactsNestedInput
    notification?: notificationsUncheckedUpdateManyWithoutNotificationNestedInput
    savedjob?: saved_jobsUncheckedUpdateManyWithoutSavedjobNestedInput
    searches?: job_searchesUncheckedUpdateManyWithoutSearchesNestedInput
  }

  export type usersCreateWithoutSkillsInput = {
    first_name: string
    last_name: string
    email: string
    password_hash: string
    phone_number?: string | null
    country_code?: string | null
    date_of_birth?: Date | string | null
    gender?: string | null
    profile_picture_url?: string | null
    bio?: string | null
    created_at?: Date | string
    updated_at: Date | string
    last_login_at?: Date | string | null
    status?: $Enums.userstatus
    addresses?: user_addressesCreateNestedManyWithoutUserInput
    resumes?: resumesCreateNestedManyWithoutUserInput
    educations?: educationsCreateNestedManyWithoutUserInput
    experiences?: work_experiencesCreateNestedManyWithoutUserInput
    languages?: languagesCreateNestedManyWithoutUserInput
    certifications?: certificationsCreateNestedManyWithoutUserInput
    visa?: visa_informationCreateNestedManyWithoutVisaInput
    application?: applicationsCreateNestedManyWithoutAplicationInput
    contacts?: contactsCreateNestedManyWithoutContactsInput
    notification?: notificationsCreateNestedManyWithoutNotificationInput
    savedjob?: saved_jobsCreateNestedManyWithoutSavedjobInput
    searches?: job_searchesCreateNestedManyWithoutSearchesInput
  }

  export type usersUncheckedCreateWithoutSkillsInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password_hash: string
    phone_number?: string | null
    country_code?: string | null
    date_of_birth?: Date | string | null
    gender?: string | null
    profile_picture_url?: string | null
    bio?: string | null
    created_at?: Date | string
    updated_at: Date | string
    last_login_at?: Date | string | null
    status?: $Enums.userstatus
    addresses?: user_addressesUncheckedCreateNestedManyWithoutUserInput
    resumes?: resumesUncheckedCreateNestedManyWithoutUserInput
    educations?: educationsUncheckedCreateNestedManyWithoutUserInput
    experiences?: work_experiencesUncheckedCreateNestedManyWithoutUserInput
    languages?: languagesUncheckedCreateNestedManyWithoutUserInput
    certifications?: certificationsUncheckedCreateNestedManyWithoutUserInput
    visa?: visa_informationUncheckedCreateNestedManyWithoutVisaInput
    application?: applicationsUncheckedCreateNestedManyWithoutAplicationInput
    contacts?: contactsUncheckedCreateNestedManyWithoutContactsInput
    notification?: notificationsUncheckedCreateNestedManyWithoutNotificationInput
    savedjob?: saved_jobsUncheckedCreateNestedManyWithoutSavedjobInput
    searches?: job_searchesUncheckedCreateNestedManyWithoutSearchesInput
  }

  export type usersCreateOrConnectWithoutSkillsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutSkillsInput, usersUncheckedCreateWithoutSkillsInput>
  }

  export type usersUpsertWithoutSkillsInput = {
    update: XOR<usersUpdateWithoutSkillsInput, usersUncheckedUpdateWithoutSkillsInput>
    create: XOR<usersCreateWithoutSkillsInput, usersUncheckedCreateWithoutSkillsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutSkillsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutSkillsInput, usersUncheckedUpdateWithoutSkillsInput>
  }

  export type usersUpdateWithoutSkillsInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumuserstatusFieldUpdateOperationsInput | $Enums.userstatus
    addresses?: user_addressesUpdateManyWithoutUserNestedInput
    resumes?: resumesUpdateManyWithoutUserNestedInput
    educations?: educationsUpdateManyWithoutUserNestedInput
    experiences?: work_experiencesUpdateManyWithoutUserNestedInput
    languages?: languagesUpdateManyWithoutUserNestedInput
    certifications?: certificationsUpdateManyWithoutUserNestedInput
    visa?: visa_informationUpdateManyWithoutVisaNestedInput
    application?: applicationsUpdateManyWithoutAplicationNestedInput
    contacts?: contactsUpdateManyWithoutContactsNestedInput
    notification?: notificationsUpdateManyWithoutNotificationNestedInput
    savedjob?: saved_jobsUpdateManyWithoutSavedjobNestedInput
    searches?: job_searchesUpdateManyWithoutSearchesNestedInput
  }

  export type usersUncheckedUpdateWithoutSkillsInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumuserstatusFieldUpdateOperationsInput | $Enums.userstatus
    addresses?: user_addressesUncheckedUpdateManyWithoutUserNestedInput
    resumes?: resumesUncheckedUpdateManyWithoutUserNestedInput
    educations?: educationsUncheckedUpdateManyWithoutUserNestedInput
    experiences?: work_experiencesUncheckedUpdateManyWithoutUserNestedInput
    languages?: languagesUncheckedUpdateManyWithoutUserNestedInput
    certifications?: certificationsUncheckedUpdateManyWithoutUserNestedInput
    visa?: visa_informationUncheckedUpdateManyWithoutVisaNestedInput
    application?: applicationsUncheckedUpdateManyWithoutAplicationNestedInput
    contacts?: contactsUncheckedUpdateManyWithoutContactsNestedInput
    notification?: notificationsUncheckedUpdateManyWithoutNotificationNestedInput
    savedjob?: saved_jobsUncheckedUpdateManyWithoutSavedjobNestedInput
    searches?: job_searchesUncheckedUpdateManyWithoutSearchesNestedInput
  }

  export type usersCreateWithoutLanguagesInput = {
    first_name: string
    last_name: string
    email: string
    password_hash: string
    phone_number?: string | null
    country_code?: string | null
    date_of_birth?: Date | string | null
    gender?: string | null
    profile_picture_url?: string | null
    bio?: string | null
    created_at?: Date | string
    updated_at: Date | string
    last_login_at?: Date | string | null
    status?: $Enums.userstatus
    addresses?: user_addressesCreateNestedManyWithoutUserInput
    resumes?: resumesCreateNestedManyWithoutUserInput
    educations?: educationsCreateNestedManyWithoutUserInput
    experiences?: work_experiencesCreateNestedManyWithoutUserInput
    skills?: skillsCreateNestedManyWithoutUserInput
    certifications?: certificationsCreateNestedManyWithoutUserInput
    visa?: visa_informationCreateNestedManyWithoutVisaInput
    application?: applicationsCreateNestedManyWithoutAplicationInput
    contacts?: contactsCreateNestedManyWithoutContactsInput
    notification?: notificationsCreateNestedManyWithoutNotificationInput
    savedjob?: saved_jobsCreateNestedManyWithoutSavedjobInput
    searches?: job_searchesCreateNestedManyWithoutSearchesInput
  }

  export type usersUncheckedCreateWithoutLanguagesInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password_hash: string
    phone_number?: string | null
    country_code?: string | null
    date_of_birth?: Date | string | null
    gender?: string | null
    profile_picture_url?: string | null
    bio?: string | null
    created_at?: Date | string
    updated_at: Date | string
    last_login_at?: Date | string | null
    status?: $Enums.userstatus
    addresses?: user_addressesUncheckedCreateNestedManyWithoutUserInput
    resumes?: resumesUncheckedCreateNestedManyWithoutUserInput
    educations?: educationsUncheckedCreateNestedManyWithoutUserInput
    experiences?: work_experiencesUncheckedCreateNestedManyWithoutUserInput
    skills?: skillsUncheckedCreateNestedManyWithoutUserInput
    certifications?: certificationsUncheckedCreateNestedManyWithoutUserInput
    visa?: visa_informationUncheckedCreateNestedManyWithoutVisaInput
    application?: applicationsUncheckedCreateNestedManyWithoutAplicationInput
    contacts?: contactsUncheckedCreateNestedManyWithoutContactsInput
    notification?: notificationsUncheckedCreateNestedManyWithoutNotificationInput
    savedjob?: saved_jobsUncheckedCreateNestedManyWithoutSavedjobInput
    searches?: job_searchesUncheckedCreateNestedManyWithoutSearchesInput
  }

  export type usersCreateOrConnectWithoutLanguagesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutLanguagesInput, usersUncheckedCreateWithoutLanguagesInput>
  }

  export type usersUpsertWithoutLanguagesInput = {
    update: XOR<usersUpdateWithoutLanguagesInput, usersUncheckedUpdateWithoutLanguagesInput>
    create: XOR<usersCreateWithoutLanguagesInput, usersUncheckedCreateWithoutLanguagesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutLanguagesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutLanguagesInput, usersUncheckedUpdateWithoutLanguagesInput>
  }

  export type usersUpdateWithoutLanguagesInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumuserstatusFieldUpdateOperationsInput | $Enums.userstatus
    addresses?: user_addressesUpdateManyWithoutUserNestedInput
    resumes?: resumesUpdateManyWithoutUserNestedInput
    educations?: educationsUpdateManyWithoutUserNestedInput
    experiences?: work_experiencesUpdateManyWithoutUserNestedInput
    skills?: skillsUpdateManyWithoutUserNestedInput
    certifications?: certificationsUpdateManyWithoutUserNestedInput
    visa?: visa_informationUpdateManyWithoutVisaNestedInput
    application?: applicationsUpdateManyWithoutAplicationNestedInput
    contacts?: contactsUpdateManyWithoutContactsNestedInput
    notification?: notificationsUpdateManyWithoutNotificationNestedInput
    savedjob?: saved_jobsUpdateManyWithoutSavedjobNestedInput
    searches?: job_searchesUpdateManyWithoutSearchesNestedInput
  }

  export type usersUncheckedUpdateWithoutLanguagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumuserstatusFieldUpdateOperationsInput | $Enums.userstatus
    addresses?: user_addressesUncheckedUpdateManyWithoutUserNestedInput
    resumes?: resumesUncheckedUpdateManyWithoutUserNestedInput
    educations?: educationsUncheckedUpdateManyWithoutUserNestedInput
    experiences?: work_experiencesUncheckedUpdateManyWithoutUserNestedInput
    skills?: skillsUncheckedUpdateManyWithoutUserNestedInput
    certifications?: certificationsUncheckedUpdateManyWithoutUserNestedInput
    visa?: visa_informationUncheckedUpdateManyWithoutVisaNestedInput
    application?: applicationsUncheckedUpdateManyWithoutAplicationNestedInput
    contacts?: contactsUncheckedUpdateManyWithoutContactsNestedInput
    notification?: notificationsUncheckedUpdateManyWithoutNotificationNestedInput
    savedjob?: saved_jobsUncheckedUpdateManyWithoutSavedjobNestedInput
    searches?: job_searchesUncheckedUpdateManyWithoutSearchesNestedInput
  }

  export type usersCreateWithoutCertificationsInput = {
    first_name: string
    last_name: string
    email: string
    password_hash: string
    phone_number?: string | null
    country_code?: string | null
    date_of_birth?: Date | string | null
    gender?: string | null
    profile_picture_url?: string | null
    bio?: string | null
    created_at?: Date | string
    updated_at: Date | string
    last_login_at?: Date | string | null
    status?: $Enums.userstatus
    addresses?: user_addressesCreateNestedManyWithoutUserInput
    resumes?: resumesCreateNestedManyWithoutUserInput
    educations?: educationsCreateNestedManyWithoutUserInput
    experiences?: work_experiencesCreateNestedManyWithoutUserInput
    skills?: skillsCreateNestedManyWithoutUserInput
    languages?: languagesCreateNestedManyWithoutUserInput
    visa?: visa_informationCreateNestedManyWithoutVisaInput
    application?: applicationsCreateNestedManyWithoutAplicationInput
    contacts?: contactsCreateNestedManyWithoutContactsInput
    notification?: notificationsCreateNestedManyWithoutNotificationInput
    savedjob?: saved_jobsCreateNestedManyWithoutSavedjobInput
    searches?: job_searchesCreateNestedManyWithoutSearchesInput
  }

  export type usersUncheckedCreateWithoutCertificationsInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password_hash: string
    phone_number?: string | null
    country_code?: string | null
    date_of_birth?: Date | string | null
    gender?: string | null
    profile_picture_url?: string | null
    bio?: string | null
    created_at?: Date | string
    updated_at: Date | string
    last_login_at?: Date | string | null
    status?: $Enums.userstatus
    addresses?: user_addressesUncheckedCreateNestedManyWithoutUserInput
    resumes?: resumesUncheckedCreateNestedManyWithoutUserInput
    educations?: educationsUncheckedCreateNestedManyWithoutUserInput
    experiences?: work_experiencesUncheckedCreateNestedManyWithoutUserInput
    skills?: skillsUncheckedCreateNestedManyWithoutUserInput
    languages?: languagesUncheckedCreateNestedManyWithoutUserInput
    visa?: visa_informationUncheckedCreateNestedManyWithoutVisaInput
    application?: applicationsUncheckedCreateNestedManyWithoutAplicationInput
    contacts?: contactsUncheckedCreateNestedManyWithoutContactsInput
    notification?: notificationsUncheckedCreateNestedManyWithoutNotificationInput
    savedjob?: saved_jobsUncheckedCreateNestedManyWithoutSavedjobInput
    searches?: job_searchesUncheckedCreateNestedManyWithoutSearchesInput
  }

  export type usersCreateOrConnectWithoutCertificationsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutCertificationsInput, usersUncheckedCreateWithoutCertificationsInput>
  }

  export type usersUpsertWithoutCertificationsInput = {
    update: XOR<usersUpdateWithoutCertificationsInput, usersUncheckedUpdateWithoutCertificationsInput>
    create: XOR<usersCreateWithoutCertificationsInput, usersUncheckedCreateWithoutCertificationsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutCertificationsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutCertificationsInput, usersUncheckedUpdateWithoutCertificationsInput>
  }

  export type usersUpdateWithoutCertificationsInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumuserstatusFieldUpdateOperationsInput | $Enums.userstatus
    addresses?: user_addressesUpdateManyWithoutUserNestedInput
    resumes?: resumesUpdateManyWithoutUserNestedInput
    educations?: educationsUpdateManyWithoutUserNestedInput
    experiences?: work_experiencesUpdateManyWithoutUserNestedInput
    skills?: skillsUpdateManyWithoutUserNestedInput
    languages?: languagesUpdateManyWithoutUserNestedInput
    visa?: visa_informationUpdateManyWithoutVisaNestedInput
    application?: applicationsUpdateManyWithoutAplicationNestedInput
    contacts?: contactsUpdateManyWithoutContactsNestedInput
    notification?: notificationsUpdateManyWithoutNotificationNestedInput
    savedjob?: saved_jobsUpdateManyWithoutSavedjobNestedInput
    searches?: job_searchesUpdateManyWithoutSearchesNestedInput
  }

  export type usersUncheckedUpdateWithoutCertificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumuserstatusFieldUpdateOperationsInput | $Enums.userstatus
    addresses?: user_addressesUncheckedUpdateManyWithoutUserNestedInput
    resumes?: resumesUncheckedUpdateManyWithoutUserNestedInput
    educations?: educationsUncheckedUpdateManyWithoutUserNestedInput
    experiences?: work_experiencesUncheckedUpdateManyWithoutUserNestedInput
    skills?: skillsUncheckedUpdateManyWithoutUserNestedInput
    languages?: languagesUncheckedUpdateManyWithoutUserNestedInput
    visa?: visa_informationUncheckedUpdateManyWithoutVisaNestedInput
    application?: applicationsUncheckedUpdateManyWithoutAplicationNestedInput
    contacts?: contactsUncheckedUpdateManyWithoutContactsNestedInput
    notification?: notificationsUncheckedUpdateManyWithoutNotificationNestedInput
    savedjob?: saved_jobsUncheckedUpdateManyWithoutSavedjobNestedInput
    searches?: job_searchesUncheckedUpdateManyWithoutSearchesNestedInput
  }

  export type usersCreateWithoutVisaInput = {
    first_name: string
    last_name: string
    email: string
    password_hash: string
    phone_number?: string | null
    country_code?: string | null
    date_of_birth?: Date | string | null
    gender?: string | null
    profile_picture_url?: string | null
    bio?: string | null
    created_at?: Date | string
    updated_at: Date | string
    last_login_at?: Date | string | null
    status?: $Enums.userstatus
    addresses?: user_addressesCreateNestedManyWithoutUserInput
    resumes?: resumesCreateNestedManyWithoutUserInput
    educations?: educationsCreateNestedManyWithoutUserInput
    experiences?: work_experiencesCreateNestedManyWithoutUserInput
    skills?: skillsCreateNestedManyWithoutUserInput
    languages?: languagesCreateNestedManyWithoutUserInput
    certifications?: certificationsCreateNestedManyWithoutUserInput
    application?: applicationsCreateNestedManyWithoutAplicationInput
    contacts?: contactsCreateNestedManyWithoutContactsInput
    notification?: notificationsCreateNestedManyWithoutNotificationInput
    savedjob?: saved_jobsCreateNestedManyWithoutSavedjobInput
    searches?: job_searchesCreateNestedManyWithoutSearchesInput
  }

  export type usersUncheckedCreateWithoutVisaInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password_hash: string
    phone_number?: string | null
    country_code?: string | null
    date_of_birth?: Date | string | null
    gender?: string | null
    profile_picture_url?: string | null
    bio?: string | null
    created_at?: Date | string
    updated_at: Date | string
    last_login_at?: Date | string | null
    status?: $Enums.userstatus
    addresses?: user_addressesUncheckedCreateNestedManyWithoutUserInput
    resumes?: resumesUncheckedCreateNestedManyWithoutUserInput
    educations?: educationsUncheckedCreateNestedManyWithoutUserInput
    experiences?: work_experiencesUncheckedCreateNestedManyWithoutUserInput
    skills?: skillsUncheckedCreateNestedManyWithoutUserInput
    languages?: languagesUncheckedCreateNestedManyWithoutUserInput
    certifications?: certificationsUncheckedCreateNestedManyWithoutUserInput
    application?: applicationsUncheckedCreateNestedManyWithoutAplicationInput
    contacts?: contactsUncheckedCreateNestedManyWithoutContactsInput
    notification?: notificationsUncheckedCreateNestedManyWithoutNotificationInput
    savedjob?: saved_jobsUncheckedCreateNestedManyWithoutSavedjobInput
    searches?: job_searchesUncheckedCreateNestedManyWithoutSearchesInput
  }

  export type usersCreateOrConnectWithoutVisaInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutVisaInput, usersUncheckedCreateWithoutVisaInput>
  }

  export type usersUpsertWithoutVisaInput = {
    update: XOR<usersUpdateWithoutVisaInput, usersUncheckedUpdateWithoutVisaInput>
    create: XOR<usersCreateWithoutVisaInput, usersUncheckedCreateWithoutVisaInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutVisaInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutVisaInput, usersUncheckedUpdateWithoutVisaInput>
  }

  export type usersUpdateWithoutVisaInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumuserstatusFieldUpdateOperationsInput | $Enums.userstatus
    addresses?: user_addressesUpdateManyWithoutUserNestedInput
    resumes?: resumesUpdateManyWithoutUserNestedInput
    educations?: educationsUpdateManyWithoutUserNestedInput
    experiences?: work_experiencesUpdateManyWithoutUserNestedInput
    skills?: skillsUpdateManyWithoutUserNestedInput
    languages?: languagesUpdateManyWithoutUserNestedInput
    certifications?: certificationsUpdateManyWithoutUserNestedInput
    application?: applicationsUpdateManyWithoutAplicationNestedInput
    contacts?: contactsUpdateManyWithoutContactsNestedInput
    notification?: notificationsUpdateManyWithoutNotificationNestedInput
    savedjob?: saved_jobsUpdateManyWithoutSavedjobNestedInput
    searches?: job_searchesUpdateManyWithoutSearchesNestedInput
  }

  export type usersUncheckedUpdateWithoutVisaInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumuserstatusFieldUpdateOperationsInput | $Enums.userstatus
    addresses?: user_addressesUncheckedUpdateManyWithoutUserNestedInput
    resumes?: resumesUncheckedUpdateManyWithoutUserNestedInput
    educations?: educationsUncheckedUpdateManyWithoutUserNestedInput
    experiences?: work_experiencesUncheckedUpdateManyWithoutUserNestedInput
    skills?: skillsUncheckedUpdateManyWithoutUserNestedInput
    languages?: languagesUncheckedUpdateManyWithoutUserNestedInput
    certifications?: certificationsUncheckedUpdateManyWithoutUserNestedInput
    application?: applicationsUncheckedUpdateManyWithoutAplicationNestedInput
    contacts?: contactsUncheckedUpdateManyWithoutContactsNestedInput
    notification?: notificationsUncheckedUpdateManyWithoutNotificationNestedInput
    savedjob?: saved_jobsUncheckedUpdateManyWithoutSavedjobNestedInput
    searches?: job_searchesUncheckedUpdateManyWithoutSearchesNestedInput
  }

  export type company_locationsCreateWithoutCompaniesInput = {
    country: string
    city: string
    address: string
    is_headquarters?: boolean
    phone_number: string
  }

  export type company_locationsUncheckedCreateWithoutCompaniesInput = {
    id?: number
    country: string
    city: string
    address: string
    is_headquarters?: boolean
    phone_number: string
  }

  export type company_locationsCreateOrConnectWithoutCompaniesInput = {
    where: company_locationsWhereUniqueInput
    create: XOR<company_locationsCreateWithoutCompaniesInput, company_locationsUncheckedCreateWithoutCompaniesInput>
  }

  export type company_locationsCreateManyCompaniesInputEnvelope = {
    data: company_locationsCreateManyCompaniesInput | company_locationsCreateManyCompaniesInput[]
    skipDuplicates?: boolean
  }

  export type jobsCreateWithoutJobInput = {
    title: string
    description: string
    job_category: string
    job_type: $Enums.jobType
    location_country: string
    location_city: string
    is_relocation_assistance?: boolean
    is_remote_possible?: boolean
    salary_currency: string
    salary_min: number
    salary_max: number
    salary_period?: $Enums.salaryPeriod
    visa_sponsorship?: $Enums.visaSponsorship
    experience_level?: $Enums.expLevel
    education_requirement: string
    posted_by: number
    status: $Enums.jobStatus
    posted_at?: Date | string
    deadline: Date | string
    views_count?: number
    requirements?: job_requirementsCreateNestedManyWithoutRequirementsInput
    responsibilites?: job_responsibilitesCreateNestedManyWithoutResponsibilitesInput
    benefits?: job_benefitsCreateNestedManyWithoutBenefitsInput
    application?: applicationsCreateNestedManyWithoutApplicationInput
    contact?: contactsCreateNestedManyWithoutContactInput
    savedjob?: saved_jobsCreateNestedManyWithoutSavedjobsInput
  }

  export type jobsUncheckedCreateWithoutJobInput = {
    id?: number
    title: string
    description: string
    job_category: string
    job_type: $Enums.jobType
    location_country: string
    location_city: string
    is_relocation_assistance?: boolean
    is_remote_possible?: boolean
    salary_currency: string
    salary_min: number
    salary_max: number
    salary_period?: $Enums.salaryPeriod
    visa_sponsorship?: $Enums.visaSponsorship
    experience_level?: $Enums.expLevel
    education_requirement: string
    posted_by: number
    status: $Enums.jobStatus
    posted_at?: Date | string
    deadline: Date | string
    views_count?: number
    requirements?: job_requirementsUncheckedCreateNestedManyWithoutRequirementsInput
    responsibilites?: job_responsibilitesUncheckedCreateNestedManyWithoutResponsibilitesInput
    benefits?: job_benefitsUncheckedCreateNestedManyWithoutBenefitsInput
    application?: applicationsUncheckedCreateNestedManyWithoutApplicationInput
    contact?: contactsUncheckedCreateNestedManyWithoutContactInput
    savedjob?: saved_jobsUncheckedCreateNestedManyWithoutSavedjobsInput
  }

  export type jobsCreateOrConnectWithoutJobInput = {
    where: jobsWhereUniqueInput
    create: XOR<jobsCreateWithoutJobInput, jobsUncheckedCreateWithoutJobInput>
  }

  export type jobsCreateManyJobInputEnvelope = {
    data: jobsCreateManyJobInput | jobsCreateManyJobInput[]
    skipDuplicates?: boolean
  }

  export type contactsCreateWithoutContacInput = {
    contact_type: $Enums.contactType
    start_date: Date | string
    end_date: Date | string
    probation_period_months?: number
    salary_amount: number
    salary_currency: string
    salary_payment_period?: $Enums.contactSalaryPaymentPeriod
    benefits_description: string
    visa_sponsorship_details: string
    relocation_assistance_details: string
    status?: $Enums.contactStatus
    signed_at: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    contact: jobsCreateNestedOneWithoutContactInput
    contacts: usersCreateNestedOneWithoutContactsInput
  }

  export type contactsUncheckedCreateWithoutContacInput = {
    id?: number
    job_id: number
    user_id: number
    contact_type: $Enums.contactType
    start_date: Date | string
    end_date: Date | string
    probation_period_months?: number
    salary_amount: number
    salary_currency: string
    salary_payment_period?: $Enums.contactSalaryPaymentPeriod
    benefits_description: string
    visa_sponsorship_details: string
    relocation_assistance_details: string
    status?: $Enums.contactStatus
    signed_at: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type contactsCreateOrConnectWithoutContacInput = {
    where: contactsWhereUniqueInput
    create: XOR<contactsCreateWithoutContacInput, contactsUncheckedCreateWithoutContacInput>
  }

  export type contactsCreateManyContacInputEnvelope = {
    data: contactsCreateManyContacInput | contactsCreateManyContacInput[]
    skipDuplicates?: boolean
  }

  export type company_locationsUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: company_locationsWhereUniqueInput
    update: XOR<company_locationsUpdateWithoutCompaniesInput, company_locationsUncheckedUpdateWithoutCompaniesInput>
    create: XOR<company_locationsCreateWithoutCompaniesInput, company_locationsUncheckedCreateWithoutCompaniesInput>
  }

  export type company_locationsUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: company_locationsWhereUniqueInput
    data: XOR<company_locationsUpdateWithoutCompaniesInput, company_locationsUncheckedUpdateWithoutCompaniesInput>
  }

  export type company_locationsUpdateManyWithWhereWithoutCompaniesInput = {
    where: company_locationsScalarWhereInput
    data: XOR<company_locationsUpdateManyMutationInput, company_locationsUncheckedUpdateManyWithoutCompaniesInput>
  }

  export type company_locationsScalarWhereInput = {
    AND?: company_locationsScalarWhereInput | company_locationsScalarWhereInput[]
    OR?: company_locationsScalarWhereInput[]
    NOT?: company_locationsScalarWhereInput | company_locationsScalarWhereInput[]
    id?: IntFilter<"company_locations"> | number
    company_id?: IntFilter<"company_locations"> | number
    country?: StringFilter<"company_locations"> | string
    city?: StringFilter<"company_locations"> | string
    address?: StringFilter<"company_locations"> | string
    is_headquarters?: BoolFilter<"company_locations"> | boolean
    phone_number?: StringFilter<"company_locations"> | string
  }

  export type jobsUpsertWithWhereUniqueWithoutJobInput = {
    where: jobsWhereUniqueInput
    update: XOR<jobsUpdateWithoutJobInput, jobsUncheckedUpdateWithoutJobInput>
    create: XOR<jobsCreateWithoutJobInput, jobsUncheckedCreateWithoutJobInput>
  }

  export type jobsUpdateWithWhereUniqueWithoutJobInput = {
    where: jobsWhereUniqueInput
    data: XOR<jobsUpdateWithoutJobInput, jobsUncheckedUpdateWithoutJobInput>
  }

  export type jobsUpdateManyWithWhereWithoutJobInput = {
    where: jobsScalarWhereInput
    data: XOR<jobsUpdateManyMutationInput, jobsUncheckedUpdateManyWithoutJobInput>
  }

  export type jobsScalarWhereInput = {
    AND?: jobsScalarWhereInput | jobsScalarWhereInput[]
    OR?: jobsScalarWhereInput[]
    NOT?: jobsScalarWhereInput | jobsScalarWhereInput[]
    id?: IntFilter<"jobs"> | number
    company_id?: IntFilter<"jobs"> | number
    title?: StringFilter<"jobs"> | string
    description?: StringFilter<"jobs"> | string
    job_category?: StringFilter<"jobs"> | string
    job_type?: EnumjobTypeFilter<"jobs"> | $Enums.jobType
    location_country?: StringFilter<"jobs"> | string
    location_city?: StringFilter<"jobs"> | string
    is_relocation_assistance?: BoolFilter<"jobs"> | boolean
    is_remote_possible?: BoolFilter<"jobs"> | boolean
    salary_currency?: StringFilter<"jobs"> | string
    salary_min?: IntFilter<"jobs"> | number
    salary_max?: IntFilter<"jobs"> | number
    salary_period?: EnumsalaryPeriodFilter<"jobs"> | $Enums.salaryPeriod
    visa_sponsorship?: EnumvisaSponsorshipFilter<"jobs"> | $Enums.visaSponsorship
    experience_level?: EnumexpLevelFilter<"jobs"> | $Enums.expLevel
    education_requirement?: StringFilter<"jobs"> | string
    posted_by?: IntFilter<"jobs"> | number
    status?: EnumjobStatusFilter<"jobs"> | $Enums.jobStatus
    posted_at?: DateTimeFilter<"jobs"> | Date | string
    deadline?: DateTimeFilter<"jobs"> | Date | string
    views_count?: IntFilter<"jobs"> | number
  }

  export type contactsUpsertWithWhereUniqueWithoutContacInput = {
    where: contactsWhereUniqueInput
    update: XOR<contactsUpdateWithoutContacInput, contactsUncheckedUpdateWithoutContacInput>
    create: XOR<contactsCreateWithoutContacInput, contactsUncheckedCreateWithoutContacInput>
  }

  export type contactsUpdateWithWhereUniqueWithoutContacInput = {
    where: contactsWhereUniqueInput
    data: XOR<contactsUpdateWithoutContacInput, contactsUncheckedUpdateWithoutContacInput>
  }

  export type contactsUpdateManyWithWhereWithoutContacInput = {
    where: contactsScalarWhereInput
    data: XOR<contactsUpdateManyMutationInput, contactsUncheckedUpdateManyWithoutContacInput>
  }

  export type companiesCreateWithoutCompaniesInput = {
    name: string
    description: string
    industry: string
    founded_year: number
    website_url: string
    logo_url: string
    headquarters_country: string
    company_siz?: $Enums.companySize
    is_verified?: boolean
    created_at?: Date | string
    job?: jobsCreateNestedManyWithoutJobInput
    contacts?: contactsCreateNestedManyWithoutContacInput
  }

  export type companiesUncheckedCreateWithoutCompaniesInput = {
    id?: number
    name: string
    description: string
    industry: string
    founded_year: number
    website_url: string
    logo_url: string
    headquarters_country: string
    company_siz?: $Enums.companySize
    is_verified?: boolean
    created_at?: Date | string
    job?: jobsUncheckedCreateNestedManyWithoutJobInput
    contacts?: contactsUncheckedCreateNestedManyWithoutContacInput
  }

  export type companiesCreateOrConnectWithoutCompaniesInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesCreateWithoutCompaniesInput, companiesUncheckedCreateWithoutCompaniesInput>
  }

  export type companiesUpsertWithoutCompaniesInput = {
    update: XOR<companiesUpdateWithoutCompaniesInput, companiesUncheckedUpdateWithoutCompaniesInput>
    create: XOR<companiesCreateWithoutCompaniesInput, companiesUncheckedCreateWithoutCompaniesInput>
    where?: companiesWhereInput
  }

  export type companiesUpdateToOneWithWhereWithoutCompaniesInput = {
    where?: companiesWhereInput
    data: XOR<companiesUpdateWithoutCompaniesInput, companiesUncheckedUpdateWithoutCompaniesInput>
  }

  export type companiesUpdateWithoutCompaniesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    founded_year?: IntFieldUpdateOperationsInput | number
    website_url?: StringFieldUpdateOperationsInput | string
    logo_url?: StringFieldUpdateOperationsInput | string
    headquarters_country?: StringFieldUpdateOperationsInput | string
    company_siz?: EnumcompanySizeFieldUpdateOperationsInput | $Enums.companySize
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: jobsUpdateManyWithoutJobNestedInput
    contacts?: contactsUpdateManyWithoutContacNestedInput
  }

  export type companiesUncheckedUpdateWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    founded_year?: IntFieldUpdateOperationsInput | number
    website_url?: StringFieldUpdateOperationsInput | string
    logo_url?: StringFieldUpdateOperationsInput | string
    headquarters_country?: StringFieldUpdateOperationsInput | string
    company_siz?: EnumcompanySizeFieldUpdateOperationsInput | $Enums.companySize
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: jobsUncheckedUpdateManyWithoutJobNestedInput
    contacts?: contactsUncheckedUpdateManyWithoutContacNestedInput
  }

  export type companiesCreateWithoutJobInput = {
    name: string
    description: string
    industry: string
    founded_year: number
    website_url: string
    logo_url: string
    headquarters_country: string
    company_siz?: $Enums.companySize
    is_verified?: boolean
    created_at?: Date | string
    companies?: company_locationsCreateNestedManyWithoutCompaniesInput
    contacts?: contactsCreateNestedManyWithoutContacInput
  }

  export type companiesUncheckedCreateWithoutJobInput = {
    id?: number
    name: string
    description: string
    industry: string
    founded_year: number
    website_url: string
    logo_url: string
    headquarters_country: string
    company_siz?: $Enums.companySize
    is_verified?: boolean
    created_at?: Date | string
    companies?: company_locationsUncheckedCreateNestedManyWithoutCompaniesInput
    contacts?: contactsUncheckedCreateNestedManyWithoutContacInput
  }

  export type companiesCreateOrConnectWithoutJobInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesCreateWithoutJobInput, companiesUncheckedCreateWithoutJobInput>
  }

  export type job_requirementsCreateWithoutRequirementsInput = {
    requirement_type: $Enums.jobRequirements
    requirement_text: string
    is_mandatory?: boolean
    priority?: number
  }

  export type job_requirementsUncheckedCreateWithoutRequirementsInput = {
    id?: number
    requirement_type: $Enums.jobRequirements
    requirement_text: string
    is_mandatory?: boolean
    priority?: number
  }

  export type job_requirementsCreateOrConnectWithoutRequirementsInput = {
    where: job_requirementsWhereUniqueInput
    create: XOR<job_requirementsCreateWithoutRequirementsInput, job_requirementsUncheckedCreateWithoutRequirementsInput>
  }

  export type job_requirementsCreateManyRequirementsInputEnvelope = {
    data: job_requirementsCreateManyRequirementsInput | job_requirementsCreateManyRequirementsInput[]
    skipDuplicates?: boolean
  }

  export type job_responsibilitesCreateWithoutResponsibilitesInput = {
    responsibility_text: string
    priority?: number
  }

  export type job_responsibilitesUncheckedCreateWithoutResponsibilitesInput = {
    id?: number
    responsibility_text: string
    priority?: number
  }

  export type job_responsibilitesCreateOrConnectWithoutResponsibilitesInput = {
    where: job_responsibilitesWhereUniqueInput
    create: XOR<job_responsibilitesCreateWithoutResponsibilitesInput, job_responsibilitesUncheckedCreateWithoutResponsibilitesInput>
  }

  export type job_responsibilitesCreateManyResponsibilitesInputEnvelope = {
    data: job_responsibilitesCreateManyResponsibilitesInput | job_responsibilitesCreateManyResponsibilitesInput[]
    skipDuplicates?: boolean
  }

  export type job_benefitsCreateWithoutBenefitsInput = {
    benefit_type: $Enums.jobBenefit
    description: string
  }

  export type job_benefitsUncheckedCreateWithoutBenefitsInput = {
    id?: number
    benefit_type: $Enums.jobBenefit
    description: string
  }

  export type job_benefitsCreateOrConnectWithoutBenefitsInput = {
    where: job_benefitsWhereUniqueInput
    create: XOR<job_benefitsCreateWithoutBenefitsInput, job_benefitsUncheckedCreateWithoutBenefitsInput>
  }

  export type job_benefitsCreateManyBenefitsInputEnvelope = {
    data: job_benefitsCreateManyBenefitsInput | job_benefitsCreateManyBenefitsInput[]
    skipDuplicates?: boolean
  }

  export type applicationsCreateWithoutApplicationInput = {
    cover_letter: string
    status: $Enums.applicationStatus
    applited_at?: Date | string
    updated_at?: Date | string
    notes: string
    aplication: usersCreateNestedOneWithoutApplicationInput
    applications: resumesCreateNestedOneWithoutApplicationsInput
    document?: application_documentsCreateNestedManyWithoutDocumentInput
    interview?: interviewsCreateNestedManyWithoutInterviewInput
  }

  export type applicationsUncheckedCreateWithoutApplicationInput = {
    id?: number
    user_id: number
    resume_id: number
    cover_letter: string
    status: $Enums.applicationStatus
    applited_at?: Date | string
    updated_at?: Date | string
    notes: string
    document?: application_documentsUncheckedCreateNestedManyWithoutDocumentInput
    interview?: interviewsUncheckedCreateNestedManyWithoutInterviewInput
  }

  export type applicationsCreateOrConnectWithoutApplicationInput = {
    where: applicationsWhereUniqueInput
    create: XOR<applicationsCreateWithoutApplicationInput, applicationsUncheckedCreateWithoutApplicationInput>
  }

  export type applicationsCreateManyApplicationInputEnvelope = {
    data: applicationsCreateManyApplicationInput | applicationsCreateManyApplicationInput[]
    skipDuplicates?: boolean
  }

  export type contactsCreateWithoutContactInput = {
    contact_type: $Enums.contactType
    start_date: Date | string
    end_date: Date | string
    probation_period_months?: number
    salary_amount: number
    salary_currency: string
    salary_payment_period?: $Enums.contactSalaryPaymentPeriod
    benefits_description: string
    visa_sponsorship_details: string
    relocation_assistance_details: string
    status?: $Enums.contactStatus
    signed_at: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    contacts: usersCreateNestedOneWithoutContactsInput
    contac: companiesCreateNestedOneWithoutContactsInput
  }

  export type contactsUncheckedCreateWithoutContactInput = {
    id?: number
    user_id: number
    company_id: number
    contact_type: $Enums.contactType
    start_date: Date | string
    end_date: Date | string
    probation_period_months?: number
    salary_amount: number
    salary_currency: string
    salary_payment_period?: $Enums.contactSalaryPaymentPeriod
    benefits_description: string
    visa_sponsorship_details: string
    relocation_assistance_details: string
    status?: $Enums.contactStatus
    signed_at: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type contactsCreateOrConnectWithoutContactInput = {
    where: contactsWhereUniqueInput
    create: XOR<contactsCreateWithoutContactInput, contactsUncheckedCreateWithoutContactInput>
  }

  export type contactsCreateManyContactInputEnvelope = {
    data: contactsCreateManyContactInput | contactsCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type saved_jobsCreateWithoutSavedjobsInput = {
    saved_at?: Date | string
    notes: string
    savedjob: usersCreateNestedOneWithoutSavedjobInput
  }

  export type saved_jobsUncheckedCreateWithoutSavedjobsInput = {
    id?: number
    user_id: number
    saved_at?: Date | string
    notes: string
  }

  export type saved_jobsCreateOrConnectWithoutSavedjobsInput = {
    where: saved_jobsWhereUniqueInput
    create: XOR<saved_jobsCreateWithoutSavedjobsInput, saved_jobsUncheckedCreateWithoutSavedjobsInput>
  }

  export type saved_jobsCreateManySavedjobsInputEnvelope = {
    data: saved_jobsCreateManySavedjobsInput | saved_jobsCreateManySavedjobsInput[]
    skipDuplicates?: boolean
  }

  export type companiesUpsertWithoutJobInput = {
    update: XOR<companiesUpdateWithoutJobInput, companiesUncheckedUpdateWithoutJobInput>
    create: XOR<companiesCreateWithoutJobInput, companiesUncheckedCreateWithoutJobInput>
    where?: companiesWhereInput
  }

  export type companiesUpdateToOneWithWhereWithoutJobInput = {
    where?: companiesWhereInput
    data: XOR<companiesUpdateWithoutJobInput, companiesUncheckedUpdateWithoutJobInput>
  }

  export type companiesUpdateWithoutJobInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    founded_year?: IntFieldUpdateOperationsInput | number
    website_url?: StringFieldUpdateOperationsInput | string
    logo_url?: StringFieldUpdateOperationsInput | string
    headquarters_country?: StringFieldUpdateOperationsInput | string
    company_siz?: EnumcompanySizeFieldUpdateOperationsInput | $Enums.companySize
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: company_locationsUpdateManyWithoutCompaniesNestedInput
    contacts?: contactsUpdateManyWithoutContacNestedInput
  }

  export type companiesUncheckedUpdateWithoutJobInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    founded_year?: IntFieldUpdateOperationsInput | number
    website_url?: StringFieldUpdateOperationsInput | string
    logo_url?: StringFieldUpdateOperationsInput | string
    headquarters_country?: StringFieldUpdateOperationsInput | string
    company_siz?: EnumcompanySizeFieldUpdateOperationsInput | $Enums.companySize
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: company_locationsUncheckedUpdateManyWithoutCompaniesNestedInput
    contacts?: contactsUncheckedUpdateManyWithoutContacNestedInput
  }

  export type job_requirementsUpsertWithWhereUniqueWithoutRequirementsInput = {
    where: job_requirementsWhereUniqueInput
    update: XOR<job_requirementsUpdateWithoutRequirementsInput, job_requirementsUncheckedUpdateWithoutRequirementsInput>
    create: XOR<job_requirementsCreateWithoutRequirementsInput, job_requirementsUncheckedCreateWithoutRequirementsInput>
  }

  export type job_requirementsUpdateWithWhereUniqueWithoutRequirementsInput = {
    where: job_requirementsWhereUniqueInput
    data: XOR<job_requirementsUpdateWithoutRequirementsInput, job_requirementsUncheckedUpdateWithoutRequirementsInput>
  }

  export type job_requirementsUpdateManyWithWhereWithoutRequirementsInput = {
    where: job_requirementsScalarWhereInput
    data: XOR<job_requirementsUpdateManyMutationInput, job_requirementsUncheckedUpdateManyWithoutRequirementsInput>
  }

  export type job_requirementsScalarWhereInput = {
    AND?: job_requirementsScalarWhereInput | job_requirementsScalarWhereInput[]
    OR?: job_requirementsScalarWhereInput[]
    NOT?: job_requirementsScalarWhereInput | job_requirementsScalarWhereInput[]
    id?: IntFilter<"job_requirements"> | number
    job_id?: IntFilter<"job_requirements"> | number
    requirement_type?: EnumjobRequirementsFilter<"job_requirements"> | $Enums.jobRequirements
    requirement_text?: StringFilter<"job_requirements"> | string
    is_mandatory?: BoolFilter<"job_requirements"> | boolean
    priority?: IntFilter<"job_requirements"> | number
  }

  export type job_responsibilitesUpsertWithWhereUniqueWithoutResponsibilitesInput = {
    where: job_responsibilitesWhereUniqueInput
    update: XOR<job_responsibilitesUpdateWithoutResponsibilitesInput, job_responsibilitesUncheckedUpdateWithoutResponsibilitesInput>
    create: XOR<job_responsibilitesCreateWithoutResponsibilitesInput, job_responsibilitesUncheckedCreateWithoutResponsibilitesInput>
  }

  export type job_responsibilitesUpdateWithWhereUniqueWithoutResponsibilitesInput = {
    where: job_responsibilitesWhereUniqueInput
    data: XOR<job_responsibilitesUpdateWithoutResponsibilitesInput, job_responsibilitesUncheckedUpdateWithoutResponsibilitesInput>
  }

  export type job_responsibilitesUpdateManyWithWhereWithoutResponsibilitesInput = {
    where: job_responsibilitesScalarWhereInput
    data: XOR<job_responsibilitesUpdateManyMutationInput, job_responsibilitesUncheckedUpdateManyWithoutResponsibilitesInput>
  }

  export type job_responsibilitesScalarWhereInput = {
    AND?: job_responsibilitesScalarWhereInput | job_responsibilitesScalarWhereInput[]
    OR?: job_responsibilitesScalarWhereInput[]
    NOT?: job_responsibilitesScalarWhereInput | job_responsibilitesScalarWhereInput[]
    id?: IntFilter<"job_responsibilites"> | number
    job_id?: IntFilter<"job_responsibilites"> | number
    responsibility_text?: StringFilter<"job_responsibilites"> | string
    priority?: IntFilter<"job_responsibilites"> | number
  }

  export type job_benefitsUpsertWithWhereUniqueWithoutBenefitsInput = {
    where: job_benefitsWhereUniqueInput
    update: XOR<job_benefitsUpdateWithoutBenefitsInput, job_benefitsUncheckedUpdateWithoutBenefitsInput>
    create: XOR<job_benefitsCreateWithoutBenefitsInput, job_benefitsUncheckedCreateWithoutBenefitsInput>
  }

  export type job_benefitsUpdateWithWhereUniqueWithoutBenefitsInput = {
    where: job_benefitsWhereUniqueInput
    data: XOR<job_benefitsUpdateWithoutBenefitsInput, job_benefitsUncheckedUpdateWithoutBenefitsInput>
  }

  export type job_benefitsUpdateManyWithWhereWithoutBenefitsInput = {
    where: job_benefitsScalarWhereInput
    data: XOR<job_benefitsUpdateManyMutationInput, job_benefitsUncheckedUpdateManyWithoutBenefitsInput>
  }

  export type job_benefitsScalarWhereInput = {
    AND?: job_benefitsScalarWhereInput | job_benefitsScalarWhereInput[]
    OR?: job_benefitsScalarWhereInput[]
    NOT?: job_benefitsScalarWhereInput | job_benefitsScalarWhereInput[]
    id?: IntFilter<"job_benefits"> | number
    job_id?: IntFilter<"job_benefits"> | number
    benefit_type?: EnumjobBenefitFilter<"job_benefits"> | $Enums.jobBenefit
    description?: StringFilter<"job_benefits"> | string
  }

  export type applicationsUpsertWithWhereUniqueWithoutApplicationInput = {
    where: applicationsWhereUniqueInput
    update: XOR<applicationsUpdateWithoutApplicationInput, applicationsUncheckedUpdateWithoutApplicationInput>
    create: XOR<applicationsCreateWithoutApplicationInput, applicationsUncheckedCreateWithoutApplicationInput>
  }

  export type applicationsUpdateWithWhereUniqueWithoutApplicationInput = {
    where: applicationsWhereUniqueInput
    data: XOR<applicationsUpdateWithoutApplicationInput, applicationsUncheckedUpdateWithoutApplicationInput>
  }

  export type applicationsUpdateManyWithWhereWithoutApplicationInput = {
    where: applicationsScalarWhereInput
    data: XOR<applicationsUpdateManyMutationInput, applicationsUncheckedUpdateManyWithoutApplicationInput>
  }

  export type contactsUpsertWithWhereUniqueWithoutContactInput = {
    where: contactsWhereUniqueInput
    update: XOR<contactsUpdateWithoutContactInput, contactsUncheckedUpdateWithoutContactInput>
    create: XOR<contactsCreateWithoutContactInput, contactsUncheckedCreateWithoutContactInput>
  }

  export type contactsUpdateWithWhereUniqueWithoutContactInput = {
    where: contactsWhereUniqueInput
    data: XOR<contactsUpdateWithoutContactInput, contactsUncheckedUpdateWithoutContactInput>
  }

  export type contactsUpdateManyWithWhereWithoutContactInput = {
    where: contactsScalarWhereInput
    data: XOR<contactsUpdateManyMutationInput, contactsUncheckedUpdateManyWithoutContactInput>
  }

  export type saved_jobsUpsertWithWhereUniqueWithoutSavedjobsInput = {
    where: saved_jobsWhereUniqueInput
    update: XOR<saved_jobsUpdateWithoutSavedjobsInput, saved_jobsUncheckedUpdateWithoutSavedjobsInput>
    create: XOR<saved_jobsCreateWithoutSavedjobsInput, saved_jobsUncheckedCreateWithoutSavedjobsInput>
  }

  export type saved_jobsUpdateWithWhereUniqueWithoutSavedjobsInput = {
    where: saved_jobsWhereUniqueInput
    data: XOR<saved_jobsUpdateWithoutSavedjobsInput, saved_jobsUncheckedUpdateWithoutSavedjobsInput>
  }

  export type saved_jobsUpdateManyWithWhereWithoutSavedjobsInput = {
    where: saved_jobsScalarWhereInput
    data: XOR<saved_jobsUpdateManyMutationInput, saved_jobsUncheckedUpdateManyWithoutSavedjobsInput>
  }

  export type jobsCreateWithoutRequirementsInput = {
    title: string
    description: string
    job_category: string
    job_type: $Enums.jobType
    location_country: string
    location_city: string
    is_relocation_assistance?: boolean
    is_remote_possible?: boolean
    salary_currency: string
    salary_min: number
    salary_max: number
    salary_period?: $Enums.salaryPeriod
    visa_sponsorship?: $Enums.visaSponsorship
    experience_level?: $Enums.expLevel
    education_requirement: string
    posted_by: number
    status: $Enums.jobStatus
    posted_at?: Date | string
    deadline: Date | string
    views_count?: number
    job: companiesCreateNestedOneWithoutJobInput
    responsibilites?: job_responsibilitesCreateNestedManyWithoutResponsibilitesInput
    benefits?: job_benefitsCreateNestedManyWithoutBenefitsInput
    application?: applicationsCreateNestedManyWithoutApplicationInput
    contact?: contactsCreateNestedManyWithoutContactInput
    savedjob?: saved_jobsCreateNestedManyWithoutSavedjobsInput
  }

  export type jobsUncheckedCreateWithoutRequirementsInput = {
    id?: number
    company_id: number
    title: string
    description: string
    job_category: string
    job_type: $Enums.jobType
    location_country: string
    location_city: string
    is_relocation_assistance?: boolean
    is_remote_possible?: boolean
    salary_currency: string
    salary_min: number
    salary_max: number
    salary_period?: $Enums.salaryPeriod
    visa_sponsorship?: $Enums.visaSponsorship
    experience_level?: $Enums.expLevel
    education_requirement: string
    posted_by: number
    status: $Enums.jobStatus
    posted_at?: Date | string
    deadline: Date | string
    views_count?: number
    responsibilites?: job_responsibilitesUncheckedCreateNestedManyWithoutResponsibilitesInput
    benefits?: job_benefitsUncheckedCreateNestedManyWithoutBenefitsInput
    application?: applicationsUncheckedCreateNestedManyWithoutApplicationInput
    contact?: contactsUncheckedCreateNestedManyWithoutContactInput
    savedjob?: saved_jobsUncheckedCreateNestedManyWithoutSavedjobsInput
  }

  export type jobsCreateOrConnectWithoutRequirementsInput = {
    where: jobsWhereUniqueInput
    create: XOR<jobsCreateWithoutRequirementsInput, jobsUncheckedCreateWithoutRequirementsInput>
  }

  export type jobsUpsertWithoutRequirementsInput = {
    update: XOR<jobsUpdateWithoutRequirementsInput, jobsUncheckedUpdateWithoutRequirementsInput>
    create: XOR<jobsCreateWithoutRequirementsInput, jobsUncheckedCreateWithoutRequirementsInput>
    where?: jobsWhereInput
  }

  export type jobsUpdateToOneWithWhereWithoutRequirementsInput = {
    where?: jobsWhereInput
    data: XOR<jobsUpdateWithoutRequirementsInput, jobsUncheckedUpdateWithoutRequirementsInput>
  }

  export type jobsUpdateWithoutRequirementsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    job_category?: StringFieldUpdateOperationsInput | string
    job_type?: EnumjobTypeFieldUpdateOperationsInput | $Enums.jobType
    location_country?: StringFieldUpdateOperationsInput | string
    location_city?: StringFieldUpdateOperationsInput | string
    is_relocation_assistance?: BoolFieldUpdateOperationsInput | boolean
    is_remote_possible?: BoolFieldUpdateOperationsInput | boolean
    salary_currency?: StringFieldUpdateOperationsInput | string
    salary_min?: IntFieldUpdateOperationsInput | number
    salary_max?: IntFieldUpdateOperationsInput | number
    salary_period?: EnumsalaryPeriodFieldUpdateOperationsInput | $Enums.salaryPeriod
    visa_sponsorship?: EnumvisaSponsorshipFieldUpdateOperationsInput | $Enums.visaSponsorship
    experience_level?: EnumexpLevelFieldUpdateOperationsInput | $Enums.expLevel
    education_requirement?: StringFieldUpdateOperationsInput | string
    posted_by?: IntFieldUpdateOperationsInput | number
    status?: EnumjobStatusFieldUpdateOperationsInput | $Enums.jobStatus
    posted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    views_count?: IntFieldUpdateOperationsInput | number
    job?: companiesUpdateOneRequiredWithoutJobNestedInput
    responsibilites?: job_responsibilitesUpdateManyWithoutResponsibilitesNestedInput
    benefits?: job_benefitsUpdateManyWithoutBenefitsNestedInput
    application?: applicationsUpdateManyWithoutApplicationNestedInput
    contact?: contactsUpdateManyWithoutContactNestedInput
    savedjob?: saved_jobsUpdateManyWithoutSavedjobsNestedInput
  }

  export type jobsUncheckedUpdateWithoutRequirementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    job_category?: StringFieldUpdateOperationsInput | string
    job_type?: EnumjobTypeFieldUpdateOperationsInput | $Enums.jobType
    location_country?: StringFieldUpdateOperationsInput | string
    location_city?: StringFieldUpdateOperationsInput | string
    is_relocation_assistance?: BoolFieldUpdateOperationsInput | boolean
    is_remote_possible?: BoolFieldUpdateOperationsInput | boolean
    salary_currency?: StringFieldUpdateOperationsInput | string
    salary_min?: IntFieldUpdateOperationsInput | number
    salary_max?: IntFieldUpdateOperationsInput | number
    salary_period?: EnumsalaryPeriodFieldUpdateOperationsInput | $Enums.salaryPeriod
    visa_sponsorship?: EnumvisaSponsorshipFieldUpdateOperationsInput | $Enums.visaSponsorship
    experience_level?: EnumexpLevelFieldUpdateOperationsInput | $Enums.expLevel
    education_requirement?: StringFieldUpdateOperationsInput | string
    posted_by?: IntFieldUpdateOperationsInput | number
    status?: EnumjobStatusFieldUpdateOperationsInput | $Enums.jobStatus
    posted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    views_count?: IntFieldUpdateOperationsInput | number
    responsibilites?: job_responsibilitesUncheckedUpdateManyWithoutResponsibilitesNestedInput
    benefits?: job_benefitsUncheckedUpdateManyWithoutBenefitsNestedInput
    application?: applicationsUncheckedUpdateManyWithoutApplicationNestedInput
    contact?: contactsUncheckedUpdateManyWithoutContactNestedInput
    savedjob?: saved_jobsUncheckedUpdateManyWithoutSavedjobsNestedInput
  }

  export type jobsCreateWithoutResponsibilitesInput = {
    title: string
    description: string
    job_category: string
    job_type: $Enums.jobType
    location_country: string
    location_city: string
    is_relocation_assistance?: boolean
    is_remote_possible?: boolean
    salary_currency: string
    salary_min: number
    salary_max: number
    salary_period?: $Enums.salaryPeriod
    visa_sponsorship?: $Enums.visaSponsorship
    experience_level?: $Enums.expLevel
    education_requirement: string
    posted_by: number
    status: $Enums.jobStatus
    posted_at?: Date | string
    deadline: Date | string
    views_count?: number
    job: companiesCreateNestedOneWithoutJobInput
    requirements?: job_requirementsCreateNestedManyWithoutRequirementsInput
    benefits?: job_benefitsCreateNestedManyWithoutBenefitsInput
    application?: applicationsCreateNestedManyWithoutApplicationInput
    contact?: contactsCreateNestedManyWithoutContactInput
    savedjob?: saved_jobsCreateNestedManyWithoutSavedjobsInput
  }

  export type jobsUncheckedCreateWithoutResponsibilitesInput = {
    id?: number
    company_id: number
    title: string
    description: string
    job_category: string
    job_type: $Enums.jobType
    location_country: string
    location_city: string
    is_relocation_assistance?: boolean
    is_remote_possible?: boolean
    salary_currency: string
    salary_min: number
    salary_max: number
    salary_period?: $Enums.salaryPeriod
    visa_sponsorship?: $Enums.visaSponsorship
    experience_level?: $Enums.expLevel
    education_requirement: string
    posted_by: number
    status: $Enums.jobStatus
    posted_at?: Date | string
    deadline: Date | string
    views_count?: number
    requirements?: job_requirementsUncheckedCreateNestedManyWithoutRequirementsInput
    benefits?: job_benefitsUncheckedCreateNestedManyWithoutBenefitsInput
    application?: applicationsUncheckedCreateNestedManyWithoutApplicationInput
    contact?: contactsUncheckedCreateNestedManyWithoutContactInput
    savedjob?: saved_jobsUncheckedCreateNestedManyWithoutSavedjobsInput
  }

  export type jobsCreateOrConnectWithoutResponsibilitesInput = {
    where: jobsWhereUniqueInput
    create: XOR<jobsCreateWithoutResponsibilitesInput, jobsUncheckedCreateWithoutResponsibilitesInput>
  }

  export type jobsUpsertWithoutResponsibilitesInput = {
    update: XOR<jobsUpdateWithoutResponsibilitesInput, jobsUncheckedUpdateWithoutResponsibilitesInput>
    create: XOR<jobsCreateWithoutResponsibilitesInput, jobsUncheckedCreateWithoutResponsibilitesInput>
    where?: jobsWhereInput
  }

  export type jobsUpdateToOneWithWhereWithoutResponsibilitesInput = {
    where?: jobsWhereInput
    data: XOR<jobsUpdateWithoutResponsibilitesInput, jobsUncheckedUpdateWithoutResponsibilitesInput>
  }

  export type jobsUpdateWithoutResponsibilitesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    job_category?: StringFieldUpdateOperationsInput | string
    job_type?: EnumjobTypeFieldUpdateOperationsInput | $Enums.jobType
    location_country?: StringFieldUpdateOperationsInput | string
    location_city?: StringFieldUpdateOperationsInput | string
    is_relocation_assistance?: BoolFieldUpdateOperationsInput | boolean
    is_remote_possible?: BoolFieldUpdateOperationsInput | boolean
    salary_currency?: StringFieldUpdateOperationsInput | string
    salary_min?: IntFieldUpdateOperationsInput | number
    salary_max?: IntFieldUpdateOperationsInput | number
    salary_period?: EnumsalaryPeriodFieldUpdateOperationsInput | $Enums.salaryPeriod
    visa_sponsorship?: EnumvisaSponsorshipFieldUpdateOperationsInput | $Enums.visaSponsorship
    experience_level?: EnumexpLevelFieldUpdateOperationsInput | $Enums.expLevel
    education_requirement?: StringFieldUpdateOperationsInput | string
    posted_by?: IntFieldUpdateOperationsInput | number
    status?: EnumjobStatusFieldUpdateOperationsInput | $Enums.jobStatus
    posted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    views_count?: IntFieldUpdateOperationsInput | number
    job?: companiesUpdateOneRequiredWithoutJobNestedInput
    requirements?: job_requirementsUpdateManyWithoutRequirementsNestedInput
    benefits?: job_benefitsUpdateManyWithoutBenefitsNestedInput
    application?: applicationsUpdateManyWithoutApplicationNestedInput
    contact?: contactsUpdateManyWithoutContactNestedInput
    savedjob?: saved_jobsUpdateManyWithoutSavedjobsNestedInput
  }

  export type jobsUncheckedUpdateWithoutResponsibilitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    job_category?: StringFieldUpdateOperationsInput | string
    job_type?: EnumjobTypeFieldUpdateOperationsInput | $Enums.jobType
    location_country?: StringFieldUpdateOperationsInput | string
    location_city?: StringFieldUpdateOperationsInput | string
    is_relocation_assistance?: BoolFieldUpdateOperationsInput | boolean
    is_remote_possible?: BoolFieldUpdateOperationsInput | boolean
    salary_currency?: StringFieldUpdateOperationsInput | string
    salary_min?: IntFieldUpdateOperationsInput | number
    salary_max?: IntFieldUpdateOperationsInput | number
    salary_period?: EnumsalaryPeriodFieldUpdateOperationsInput | $Enums.salaryPeriod
    visa_sponsorship?: EnumvisaSponsorshipFieldUpdateOperationsInput | $Enums.visaSponsorship
    experience_level?: EnumexpLevelFieldUpdateOperationsInput | $Enums.expLevel
    education_requirement?: StringFieldUpdateOperationsInput | string
    posted_by?: IntFieldUpdateOperationsInput | number
    status?: EnumjobStatusFieldUpdateOperationsInput | $Enums.jobStatus
    posted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    views_count?: IntFieldUpdateOperationsInput | number
    requirements?: job_requirementsUncheckedUpdateManyWithoutRequirementsNestedInput
    benefits?: job_benefitsUncheckedUpdateManyWithoutBenefitsNestedInput
    application?: applicationsUncheckedUpdateManyWithoutApplicationNestedInput
    contact?: contactsUncheckedUpdateManyWithoutContactNestedInput
    savedjob?: saved_jobsUncheckedUpdateManyWithoutSavedjobsNestedInput
  }

  export type jobsCreateWithoutBenefitsInput = {
    title: string
    description: string
    job_category: string
    job_type: $Enums.jobType
    location_country: string
    location_city: string
    is_relocation_assistance?: boolean
    is_remote_possible?: boolean
    salary_currency: string
    salary_min: number
    salary_max: number
    salary_period?: $Enums.salaryPeriod
    visa_sponsorship?: $Enums.visaSponsorship
    experience_level?: $Enums.expLevel
    education_requirement: string
    posted_by: number
    status: $Enums.jobStatus
    posted_at?: Date | string
    deadline: Date | string
    views_count?: number
    job: companiesCreateNestedOneWithoutJobInput
    requirements?: job_requirementsCreateNestedManyWithoutRequirementsInput
    responsibilites?: job_responsibilitesCreateNestedManyWithoutResponsibilitesInput
    application?: applicationsCreateNestedManyWithoutApplicationInput
    contact?: contactsCreateNestedManyWithoutContactInput
    savedjob?: saved_jobsCreateNestedManyWithoutSavedjobsInput
  }

  export type jobsUncheckedCreateWithoutBenefitsInput = {
    id?: number
    company_id: number
    title: string
    description: string
    job_category: string
    job_type: $Enums.jobType
    location_country: string
    location_city: string
    is_relocation_assistance?: boolean
    is_remote_possible?: boolean
    salary_currency: string
    salary_min: number
    salary_max: number
    salary_period?: $Enums.salaryPeriod
    visa_sponsorship?: $Enums.visaSponsorship
    experience_level?: $Enums.expLevel
    education_requirement: string
    posted_by: number
    status: $Enums.jobStatus
    posted_at?: Date | string
    deadline: Date | string
    views_count?: number
    requirements?: job_requirementsUncheckedCreateNestedManyWithoutRequirementsInput
    responsibilites?: job_responsibilitesUncheckedCreateNestedManyWithoutResponsibilitesInput
    application?: applicationsUncheckedCreateNestedManyWithoutApplicationInput
    contact?: contactsUncheckedCreateNestedManyWithoutContactInput
    savedjob?: saved_jobsUncheckedCreateNestedManyWithoutSavedjobsInput
  }

  export type jobsCreateOrConnectWithoutBenefitsInput = {
    where: jobsWhereUniqueInput
    create: XOR<jobsCreateWithoutBenefitsInput, jobsUncheckedCreateWithoutBenefitsInput>
  }

  export type jobsUpsertWithoutBenefitsInput = {
    update: XOR<jobsUpdateWithoutBenefitsInput, jobsUncheckedUpdateWithoutBenefitsInput>
    create: XOR<jobsCreateWithoutBenefitsInput, jobsUncheckedCreateWithoutBenefitsInput>
    where?: jobsWhereInput
  }

  export type jobsUpdateToOneWithWhereWithoutBenefitsInput = {
    where?: jobsWhereInput
    data: XOR<jobsUpdateWithoutBenefitsInput, jobsUncheckedUpdateWithoutBenefitsInput>
  }

  export type jobsUpdateWithoutBenefitsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    job_category?: StringFieldUpdateOperationsInput | string
    job_type?: EnumjobTypeFieldUpdateOperationsInput | $Enums.jobType
    location_country?: StringFieldUpdateOperationsInput | string
    location_city?: StringFieldUpdateOperationsInput | string
    is_relocation_assistance?: BoolFieldUpdateOperationsInput | boolean
    is_remote_possible?: BoolFieldUpdateOperationsInput | boolean
    salary_currency?: StringFieldUpdateOperationsInput | string
    salary_min?: IntFieldUpdateOperationsInput | number
    salary_max?: IntFieldUpdateOperationsInput | number
    salary_period?: EnumsalaryPeriodFieldUpdateOperationsInput | $Enums.salaryPeriod
    visa_sponsorship?: EnumvisaSponsorshipFieldUpdateOperationsInput | $Enums.visaSponsorship
    experience_level?: EnumexpLevelFieldUpdateOperationsInput | $Enums.expLevel
    education_requirement?: StringFieldUpdateOperationsInput | string
    posted_by?: IntFieldUpdateOperationsInput | number
    status?: EnumjobStatusFieldUpdateOperationsInput | $Enums.jobStatus
    posted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    views_count?: IntFieldUpdateOperationsInput | number
    job?: companiesUpdateOneRequiredWithoutJobNestedInput
    requirements?: job_requirementsUpdateManyWithoutRequirementsNestedInput
    responsibilites?: job_responsibilitesUpdateManyWithoutResponsibilitesNestedInput
    application?: applicationsUpdateManyWithoutApplicationNestedInput
    contact?: contactsUpdateManyWithoutContactNestedInput
    savedjob?: saved_jobsUpdateManyWithoutSavedjobsNestedInput
  }

  export type jobsUncheckedUpdateWithoutBenefitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    job_category?: StringFieldUpdateOperationsInput | string
    job_type?: EnumjobTypeFieldUpdateOperationsInput | $Enums.jobType
    location_country?: StringFieldUpdateOperationsInput | string
    location_city?: StringFieldUpdateOperationsInput | string
    is_relocation_assistance?: BoolFieldUpdateOperationsInput | boolean
    is_remote_possible?: BoolFieldUpdateOperationsInput | boolean
    salary_currency?: StringFieldUpdateOperationsInput | string
    salary_min?: IntFieldUpdateOperationsInput | number
    salary_max?: IntFieldUpdateOperationsInput | number
    salary_period?: EnumsalaryPeriodFieldUpdateOperationsInput | $Enums.salaryPeriod
    visa_sponsorship?: EnumvisaSponsorshipFieldUpdateOperationsInput | $Enums.visaSponsorship
    experience_level?: EnumexpLevelFieldUpdateOperationsInput | $Enums.expLevel
    education_requirement?: StringFieldUpdateOperationsInput | string
    posted_by?: IntFieldUpdateOperationsInput | number
    status?: EnumjobStatusFieldUpdateOperationsInput | $Enums.jobStatus
    posted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    views_count?: IntFieldUpdateOperationsInput | number
    requirements?: job_requirementsUncheckedUpdateManyWithoutRequirementsNestedInput
    responsibilites?: job_responsibilitesUncheckedUpdateManyWithoutResponsibilitesNestedInput
    application?: applicationsUncheckedUpdateManyWithoutApplicationNestedInput
    contact?: contactsUncheckedUpdateManyWithoutContactNestedInput
    savedjob?: saved_jobsUncheckedUpdateManyWithoutSavedjobsNestedInput
  }

  export type jobsCreateWithoutApplicationInput = {
    title: string
    description: string
    job_category: string
    job_type: $Enums.jobType
    location_country: string
    location_city: string
    is_relocation_assistance?: boolean
    is_remote_possible?: boolean
    salary_currency: string
    salary_min: number
    salary_max: number
    salary_period?: $Enums.salaryPeriod
    visa_sponsorship?: $Enums.visaSponsorship
    experience_level?: $Enums.expLevel
    education_requirement: string
    posted_by: number
    status: $Enums.jobStatus
    posted_at?: Date | string
    deadline: Date | string
    views_count?: number
    job: companiesCreateNestedOneWithoutJobInput
    requirements?: job_requirementsCreateNestedManyWithoutRequirementsInput
    responsibilites?: job_responsibilitesCreateNestedManyWithoutResponsibilitesInput
    benefits?: job_benefitsCreateNestedManyWithoutBenefitsInput
    contact?: contactsCreateNestedManyWithoutContactInput
    savedjob?: saved_jobsCreateNestedManyWithoutSavedjobsInput
  }

  export type jobsUncheckedCreateWithoutApplicationInput = {
    id?: number
    company_id: number
    title: string
    description: string
    job_category: string
    job_type: $Enums.jobType
    location_country: string
    location_city: string
    is_relocation_assistance?: boolean
    is_remote_possible?: boolean
    salary_currency: string
    salary_min: number
    salary_max: number
    salary_period?: $Enums.salaryPeriod
    visa_sponsorship?: $Enums.visaSponsorship
    experience_level?: $Enums.expLevel
    education_requirement: string
    posted_by: number
    status: $Enums.jobStatus
    posted_at?: Date | string
    deadline: Date | string
    views_count?: number
    requirements?: job_requirementsUncheckedCreateNestedManyWithoutRequirementsInput
    responsibilites?: job_responsibilitesUncheckedCreateNestedManyWithoutResponsibilitesInput
    benefits?: job_benefitsUncheckedCreateNestedManyWithoutBenefitsInput
    contact?: contactsUncheckedCreateNestedManyWithoutContactInput
    savedjob?: saved_jobsUncheckedCreateNestedManyWithoutSavedjobsInput
  }

  export type jobsCreateOrConnectWithoutApplicationInput = {
    where: jobsWhereUniqueInput
    create: XOR<jobsCreateWithoutApplicationInput, jobsUncheckedCreateWithoutApplicationInput>
  }

  export type usersCreateWithoutApplicationInput = {
    first_name: string
    last_name: string
    email: string
    password_hash: string
    phone_number?: string | null
    country_code?: string | null
    date_of_birth?: Date | string | null
    gender?: string | null
    profile_picture_url?: string | null
    bio?: string | null
    created_at?: Date | string
    updated_at: Date | string
    last_login_at?: Date | string | null
    status?: $Enums.userstatus
    addresses?: user_addressesCreateNestedManyWithoutUserInput
    resumes?: resumesCreateNestedManyWithoutUserInput
    educations?: educationsCreateNestedManyWithoutUserInput
    experiences?: work_experiencesCreateNestedManyWithoutUserInput
    skills?: skillsCreateNestedManyWithoutUserInput
    languages?: languagesCreateNestedManyWithoutUserInput
    certifications?: certificationsCreateNestedManyWithoutUserInput
    visa?: visa_informationCreateNestedManyWithoutVisaInput
    contacts?: contactsCreateNestedManyWithoutContactsInput
    notification?: notificationsCreateNestedManyWithoutNotificationInput
    savedjob?: saved_jobsCreateNestedManyWithoutSavedjobInput
    searches?: job_searchesCreateNestedManyWithoutSearchesInput
  }

  export type usersUncheckedCreateWithoutApplicationInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password_hash: string
    phone_number?: string | null
    country_code?: string | null
    date_of_birth?: Date | string | null
    gender?: string | null
    profile_picture_url?: string | null
    bio?: string | null
    created_at?: Date | string
    updated_at: Date | string
    last_login_at?: Date | string | null
    status?: $Enums.userstatus
    addresses?: user_addressesUncheckedCreateNestedManyWithoutUserInput
    resumes?: resumesUncheckedCreateNestedManyWithoutUserInput
    educations?: educationsUncheckedCreateNestedManyWithoutUserInput
    experiences?: work_experiencesUncheckedCreateNestedManyWithoutUserInput
    skills?: skillsUncheckedCreateNestedManyWithoutUserInput
    languages?: languagesUncheckedCreateNestedManyWithoutUserInput
    certifications?: certificationsUncheckedCreateNestedManyWithoutUserInput
    visa?: visa_informationUncheckedCreateNestedManyWithoutVisaInput
    contacts?: contactsUncheckedCreateNestedManyWithoutContactsInput
    notification?: notificationsUncheckedCreateNestedManyWithoutNotificationInput
    savedjob?: saved_jobsUncheckedCreateNestedManyWithoutSavedjobInput
    searches?: job_searchesUncheckedCreateNestedManyWithoutSearchesInput
  }

  export type usersCreateOrConnectWithoutApplicationInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutApplicationInput, usersUncheckedCreateWithoutApplicationInput>
  }

  export type resumesCreateWithoutApplicationsInput = {
    title: string
    file_url: string
    is_default?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    user: usersCreateNestedOneWithoutResumesInput
  }

  export type resumesUncheckedCreateWithoutApplicationsInput = {
    id?: number
    user_id: number
    title: string
    file_url: string
    is_default?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type resumesCreateOrConnectWithoutApplicationsInput = {
    where: resumesWhereUniqueInput
    create: XOR<resumesCreateWithoutApplicationsInput, resumesUncheckedCreateWithoutApplicationsInput>
  }

  export type application_documentsCreateWithoutDocumentInput = {
    document_type: $Enums.appDocumentStatus
    file_url: string
    uploaded_at?: Date | string
  }

  export type application_documentsUncheckedCreateWithoutDocumentInput = {
    id?: number
    document_type: $Enums.appDocumentStatus
    file_url: string
    uploaded_at?: Date | string
  }

  export type application_documentsCreateOrConnectWithoutDocumentInput = {
    where: application_documentsWhereUniqueInput
    create: XOR<application_documentsCreateWithoutDocumentInput, application_documentsUncheckedCreateWithoutDocumentInput>
  }

  export type application_documentsCreateManyDocumentInputEnvelope = {
    data: application_documentsCreateManyDocumentInput | application_documentsCreateManyDocumentInput[]
    skipDuplicates?: boolean
  }

  export type interviewsCreateWithoutInterviewInput = {
    interview_type: $Enums.interviewType
    scheduled_time: Date | string
    timezone: string
    duration_minutes?: number
    location: string
    meeting_url: string
    interview_name: string
    interview_position: string
    status: $Enums.interviewStatus
    feedback: string
    rating: number
    notes: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type interviewsUncheckedCreateWithoutInterviewInput = {
    id?: number
    interview_type: $Enums.interviewType
    scheduled_time: Date | string
    timezone: string
    duration_minutes?: number
    location: string
    meeting_url: string
    interview_name: string
    interview_position: string
    status: $Enums.interviewStatus
    feedback: string
    rating: number
    notes: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type interviewsCreateOrConnectWithoutInterviewInput = {
    where: interviewsWhereUniqueInput
    create: XOR<interviewsCreateWithoutInterviewInput, interviewsUncheckedCreateWithoutInterviewInput>
  }

  export type interviewsCreateManyInterviewInputEnvelope = {
    data: interviewsCreateManyInterviewInput | interviewsCreateManyInterviewInput[]
    skipDuplicates?: boolean
  }

  export type jobsUpsertWithoutApplicationInput = {
    update: XOR<jobsUpdateWithoutApplicationInput, jobsUncheckedUpdateWithoutApplicationInput>
    create: XOR<jobsCreateWithoutApplicationInput, jobsUncheckedCreateWithoutApplicationInput>
    where?: jobsWhereInput
  }

  export type jobsUpdateToOneWithWhereWithoutApplicationInput = {
    where?: jobsWhereInput
    data: XOR<jobsUpdateWithoutApplicationInput, jobsUncheckedUpdateWithoutApplicationInput>
  }

  export type jobsUpdateWithoutApplicationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    job_category?: StringFieldUpdateOperationsInput | string
    job_type?: EnumjobTypeFieldUpdateOperationsInput | $Enums.jobType
    location_country?: StringFieldUpdateOperationsInput | string
    location_city?: StringFieldUpdateOperationsInput | string
    is_relocation_assistance?: BoolFieldUpdateOperationsInput | boolean
    is_remote_possible?: BoolFieldUpdateOperationsInput | boolean
    salary_currency?: StringFieldUpdateOperationsInput | string
    salary_min?: IntFieldUpdateOperationsInput | number
    salary_max?: IntFieldUpdateOperationsInput | number
    salary_period?: EnumsalaryPeriodFieldUpdateOperationsInput | $Enums.salaryPeriod
    visa_sponsorship?: EnumvisaSponsorshipFieldUpdateOperationsInput | $Enums.visaSponsorship
    experience_level?: EnumexpLevelFieldUpdateOperationsInput | $Enums.expLevel
    education_requirement?: StringFieldUpdateOperationsInput | string
    posted_by?: IntFieldUpdateOperationsInput | number
    status?: EnumjobStatusFieldUpdateOperationsInput | $Enums.jobStatus
    posted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    views_count?: IntFieldUpdateOperationsInput | number
    job?: companiesUpdateOneRequiredWithoutJobNestedInput
    requirements?: job_requirementsUpdateManyWithoutRequirementsNestedInput
    responsibilites?: job_responsibilitesUpdateManyWithoutResponsibilitesNestedInput
    benefits?: job_benefitsUpdateManyWithoutBenefitsNestedInput
    contact?: contactsUpdateManyWithoutContactNestedInput
    savedjob?: saved_jobsUpdateManyWithoutSavedjobsNestedInput
  }

  export type jobsUncheckedUpdateWithoutApplicationInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    job_category?: StringFieldUpdateOperationsInput | string
    job_type?: EnumjobTypeFieldUpdateOperationsInput | $Enums.jobType
    location_country?: StringFieldUpdateOperationsInput | string
    location_city?: StringFieldUpdateOperationsInput | string
    is_relocation_assistance?: BoolFieldUpdateOperationsInput | boolean
    is_remote_possible?: BoolFieldUpdateOperationsInput | boolean
    salary_currency?: StringFieldUpdateOperationsInput | string
    salary_min?: IntFieldUpdateOperationsInput | number
    salary_max?: IntFieldUpdateOperationsInput | number
    salary_period?: EnumsalaryPeriodFieldUpdateOperationsInput | $Enums.salaryPeriod
    visa_sponsorship?: EnumvisaSponsorshipFieldUpdateOperationsInput | $Enums.visaSponsorship
    experience_level?: EnumexpLevelFieldUpdateOperationsInput | $Enums.expLevel
    education_requirement?: StringFieldUpdateOperationsInput | string
    posted_by?: IntFieldUpdateOperationsInput | number
    status?: EnumjobStatusFieldUpdateOperationsInput | $Enums.jobStatus
    posted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    views_count?: IntFieldUpdateOperationsInput | number
    requirements?: job_requirementsUncheckedUpdateManyWithoutRequirementsNestedInput
    responsibilites?: job_responsibilitesUncheckedUpdateManyWithoutResponsibilitesNestedInput
    benefits?: job_benefitsUncheckedUpdateManyWithoutBenefitsNestedInput
    contact?: contactsUncheckedUpdateManyWithoutContactNestedInput
    savedjob?: saved_jobsUncheckedUpdateManyWithoutSavedjobsNestedInput
  }

  export type usersUpsertWithoutApplicationInput = {
    update: XOR<usersUpdateWithoutApplicationInput, usersUncheckedUpdateWithoutApplicationInput>
    create: XOR<usersCreateWithoutApplicationInput, usersUncheckedCreateWithoutApplicationInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutApplicationInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutApplicationInput, usersUncheckedUpdateWithoutApplicationInput>
  }

  export type usersUpdateWithoutApplicationInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumuserstatusFieldUpdateOperationsInput | $Enums.userstatus
    addresses?: user_addressesUpdateManyWithoutUserNestedInput
    resumes?: resumesUpdateManyWithoutUserNestedInput
    educations?: educationsUpdateManyWithoutUserNestedInput
    experiences?: work_experiencesUpdateManyWithoutUserNestedInput
    skills?: skillsUpdateManyWithoutUserNestedInput
    languages?: languagesUpdateManyWithoutUserNestedInput
    certifications?: certificationsUpdateManyWithoutUserNestedInput
    visa?: visa_informationUpdateManyWithoutVisaNestedInput
    contacts?: contactsUpdateManyWithoutContactsNestedInput
    notification?: notificationsUpdateManyWithoutNotificationNestedInput
    savedjob?: saved_jobsUpdateManyWithoutSavedjobNestedInput
    searches?: job_searchesUpdateManyWithoutSearchesNestedInput
  }

  export type usersUncheckedUpdateWithoutApplicationInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumuserstatusFieldUpdateOperationsInput | $Enums.userstatus
    addresses?: user_addressesUncheckedUpdateManyWithoutUserNestedInput
    resumes?: resumesUncheckedUpdateManyWithoutUserNestedInput
    educations?: educationsUncheckedUpdateManyWithoutUserNestedInput
    experiences?: work_experiencesUncheckedUpdateManyWithoutUserNestedInput
    skills?: skillsUncheckedUpdateManyWithoutUserNestedInput
    languages?: languagesUncheckedUpdateManyWithoutUserNestedInput
    certifications?: certificationsUncheckedUpdateManyWithoutUserNestedInput
    visa?: visa_informationUncheckedUpdateManyWithoutVisaNestedInput
    contacts?: contactsUncheckedUpdateManyWithoutContactsNestedInput
    notification?: notificationsUncheckedUpdateManyWithoutNotificationNestedInput
    savedjob?: saved_jobsUncheckedUpdateManyWithoutSavedjobNestedInput
    searches?: job_searchesUncheckedUpdateManyWithoutSearchesNestedInput
  }

  export type resumesUpsertWithoutApplicationsInput = {
    update: XOR<resumesUpdateWithoutApplicationsInput, resumesUncheckedUpdateWithoutApplicationsInput>
    create: XOR<resumesCreateWithoutApplicationsInput, resumesUncheckedCreateWithoutApplicationsInput>
    where?: resumesWhereInput
  }

  export type resumesUpdateToOneWithWhereWithoutApplicationsInput = {
    where?: resumesWhereInput
    data: XOR<resumesUpdateWithoutApplicationsInput, resumesUncheckedUpdateWithoutApplicationsInput>
  }

  export type resumesUpdateWithoutApplicationsInput = {
    title?: StringFieldUpdateOperationsInput | string
    file_url?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutResumesNestedInput
  }

  export type resumesUncheckedUpdateWithoutApplicationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    file_url?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type application_documentsUpsertWithWhereUniqueWithoutDocumentInput = {
    where: application_documentsWhereUniqueInput
    update: XOR<application_documentsUpdateWithoutDocumentInput, application_documentsUncheckedUpdateWithoutDocumentInput>
    create: XOR<application_documentsCreateWithoutDocumentInput, application_documentsUncheckedCreateWithoutDocumentInput>
  }

  export type application_documentsUpdateWithWhereUniqueWithoutDocumentInput = {
    where: application_documentsWhereUniqueInput
    data: XOR<application_documentsUpdateWithoutDocumentInput, application_documentsUncheckedUpdateWithoutDocumentInput>
  }

  export type application_documentsUpdateManyWithWhereWithoutDocumentInput = {
    where: application_documentsScalarWhereInput
    data: XOR<application_documentsUpdateManyMutationInput, application_documentsUncheckedUpdateManyWithoutDocumentInput>
  }

  export type application_documentsScalarWhereInput = {
    AND?: application_documentsScalarWhereInput | application_documentsScalarWhereInput[]
    OR?: application_documentsScalarWhereInput[]
    NOT?: application_documentsScalarWhereInput | application_documentsScalarWhereInput[]
    id?: IntFilter<"application_documents"> | number
    application_id?: IntFilter<"application_documents"> | number
    document_type?: EnumappDocumentStatusFilter<"application_documents"> | $Enums.appDocumentStatus
    file_url?: StringFilter<"application_documents"> | string
    uploaded_at?: DateTimeFilter<"application_documents"> | Date | string
  }

  export type interviewsUpsertWithWhereUniqueWithoutInterviewInput = {
    where: interviewsWhereUniqueInput
    update: XOR<interviewsUpdateWithoutInterviewInput, interviewsUncheckedUpdateWithoutInterviewInput>
    create: XOR<interviewsCreateWithoutInterviewInput, interviewsUncheckedCreateWithoutInterviewInput>
  }

  export type interviewsUpdateWithWhereUniqueWithoutInterviewInput = {
    where: interviewsWhereUniqueInput
    data: XOR<interviewsUpdateWithoutInterviewInput, interviewsUncheckedUpdateWithoutInterviewInput>
  }

  export type interviewsUpdateManyWithWhereWithoutInterviewInput = {
    where: interviewsScalarWhereInput
    data: XOR<interviewsUpdateManyMutationInput, interviewsUncheckedUpdateManyWithoutInterviewInput>
  }

  export type interviewsScalarWhereInput = {
    AND?: interviewsScalarWhereInput | interviewsScalarWhereInput[]
    OR?: interviewsScalarWhereInput[]
    NOT?: interviewsScalarWhereInput | interviewsScalarWhereInput[]
    id?: IntFilter<"interviews"> | number
    application_id?: IntFilter<"interviews"> | number
    interview_type?: EnuminterviewTypeFilter<"interviews"> | $Enums.interviewType
    scheduled_time?: DateTimeFilter<"interviews"> | Date | string
    timezone?: StringFilter<"interviews"> | string
    duration_minutes?: IntFilter<"interviews"> | number
    location?: StringFilter<"interviews"> | string
    meeting_url?: StringFilter<"interviews"> | string
    interview_name?: StringFilter<"interviews"> | string
    interview_position?: StringFilter<"interviews"> | string
    status?: EnuminterviewStatusFilter<"interviews"> | $Enums.interviewStatus
    feedback?: StringFilter<"interviews"> | string
    rating?: IntFilter<"interviews"> | number
    notes?: StringFilter<"interviews"> | string
    created_at?: DateTimeFilter<"interviews"> | Date | string
    updated_at?: DateTimeFilter<"interviews"> | Date | string
  }

  export type applicationsCreateWithoutDocumentInput = {
    cover_letter: string
    status: $Enums.applicationStatus
    applited_at?: Date | string
    updated_at?: Date | string
    notes: string
    application: jobsCreateNestedOneWithoutApplicationInput
    aplication: usersCreateNestedOneWithoutApplicationInput
    applications: resumesCreateNestedOneWithoutApplicationsInput
    interview?: interviewsCreateNestedManyWithoutInterviewInput
  }

  export type applicationsUncheckedCreateWithoutDocumentInput = {
    id?: number
    job_id: number
    user_id: number
    resume_id: number
    cover_letter: string
    status: $Enums.applicationStatus
    applited_at?: Date | string
    updated_at?: Date | string
    notes: string
    interview?: interviewsUncheckedCreateNestedManyWithoutInterviewInput
  }

  export type applicationsCreateOrConnectWithoutDocumentInput = {
    where: applicationsWhereUniqueInput
    create: XOR<applicationsCreateWithoutDocumentInput, applicationsUncheckedCreateWithoutDocumentInput>
  }

  export type applicationsUpsertWithoutDocumentInput = {
    update: XOR<applicationsUpdateWithoutDocumentInput, applicationsUncheckedUpdateWithoutDocumentInput>
    create: XOR<applicationsCreateWithoutDocumentInput, applicationsUncheckedCreateWithoutDocumentInput>
    where?: applicationsWhereInput
  }

  export type applicationsUpdateToOneWithWhereWithoutDocumentInput = {
    where?: applicationsWhereInput
    data: XOR<applicationsUpdateWithoutDocumentInput, applicationsUncheckedUpdateWithoutDocumentInput>
  }

  export type applicationsUpdateWithoutDocumentInput = {
    cover_letter?: StringFieldUpdateOperationsInput | string
    status?: EnumapplicationStatusFieldUpdateOperationsInput | $Enums.applicationStatus
    applited_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    application?: jobsUpdateOneRequiredWithoutApplicationNestedInput
    aplication?: usersUpdateOneRequiredWithoutApplicationNestedInput
    applications?: resumesUpdateOneRequiredWithoutApplicationsNestedInput
    interview?: interviewsUpdateManyWithoutInterviewNestedInput
  }

  export type applicationsUncheckedUpdateWithoutDocumentInput = {
    id?: IntFieldUpdateOperationsInput | number
    job_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    resume_id?: IntFieldUpdateOperationsInput | number
    cover_letter?: StringFieldUpdateOperationsInput | string
    status?: EnumapplicationStatusFieldUpdateOperationsInput | $Enums.applicationStatus
    applited_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    interview?: interviewsUncheckedUpdateManyWithoutInterviewNestedInput
  }

  export type applicationsCreateWithoutInterviewInput = {
    cover_letter: string
    status: $Enums.applicationStatus
    applited_at?: Date | string
    updated_at?: Date | string
    notes: string
    application: jobsCreateNestedOneWithoutApplicationInput
    aplication: usersCreateNestedOneWithoutApplicationInput
    applications: resumesCreateNestedOneWithoutApplicationsInput
    document?: application_documentsCreateNestedManyWithoutDocumentInput
  }

  export type applicationsUncheckedCreateWithoutInterviewInput = {
    id?: number
    job_id: number
    user_id: number
    resume_id: number
    cover_letter: string
    status: $Enums.applicationStatus
    applited_at?: Date | string
    updated_at?: Date | string
    notes: string
    document?: application_documentsUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type applicationsCreateOrConnectWithoutInterviewInput = {
    where: applicationsWhereUniqueInput
    create: XOR<applicationsCreateWithoutInterviewInput, applicationsUncheckedCreateWithoutInterviewInput>
  }

  export type applicationsUpsertWithoutInterviewInput = {
    update: XOR<applicationsUpdateWithoutInterviewInput, applicationsUncheckedUpdateWithoutInterviewInput>
    create: XOR<applicationsCreateWithoutInterviewInput, applicationsUncheckedCreateWithoutInterviewInput>
    where?: applicationsWhereInput
  }

  export type applicationsUpdateToOneWithWhereWithoutInterviewInput = {
    where?: applicationsWhereInput
    data: XOR<applicationsUpdateWithoutInterviewInput, applicationsUncheckedUpdateWithoutInterviewInput>
  }

  export type applicationsUpdateWithoutInterviewInput = {
    cover_letter?: StringFieldUpdateOperationsInput | string
    status?: EnumapplicationStatusFieldUpdateOperationsInput | $Enums.applicationStatus
    applited_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    application?: jobsUpdateOneRequiredWithoutApplicationNestedInput
    aplication?: usersUpdateOneRequiredWithoutApplicationNestedInput
    applications?: resumesUpdateOneRequiredWithoutApplicationsNestedInput
    document?: application_documentsUpdateManyWithoutDocumentNestedInput
  }

  export type applicationsUncheckedUpdateWithoutInterviewInput = {
    id?: IntFieldUpdateOperationsInput | number
    job_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    resume_id?: IntFieldUpdateOperationsInput | number
    cover_letter?: StringFieldUpdateOperationsInput | string
    status?: EnumapplicationStatusFieldUpdateOperationsInput | $Enums.applicationStatus
    applited_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    document?: application_documentsUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type jobsCreateWithoutContactInput = {
    title: string
    description: string
    job_category: string
    job_type: $Enums.jobType
    location_country: string
    location_city: string
    is_relocation_assistance?: boolean
    is_remote_possible?: boolean
    salary_currency: string
    salary_min: number
    salary_max: number
    salary_period?: $Enums.salaryPeriod
    visa_sponsorship?: $Enums.visaSponsorship
    experience_level?: $Enums.expLevel
    education_requirement: string
    posted_by: number
    status: $Enums.jobStatus
    posted_at?: Date | string
    deadline: Date | string
    views_count?: number
    job: companiesCreateNestedOneWithoutJobInput
    requirements?: job_requirementsCreateNestedManyWithoutRequirementsInput
    responsibilites?: job_responsibilitesCreateNestedManyWithoutResponsibilitesInput
    benefits?: job_benefitsCreateNestedManyWithoutBenefitsInput
    application?: applicationsCreateNestedManyWithoutApplicationInput
    savedjob?: saved_jobsCreateNestedManyWithoutSavedjobsInput
  }

  export type jobsUncheckedCreateWithoutContactInput = {
    id?: number
    company_id: number
    title: string
    description: string
    job_category: string
    job_type: $Enums.jobType
    location_country: string
    location_city: string
    is_relocation_assistance?: boolean
    is_remote_possible?: boolean
    salary_currency: string
    salary_min: number
    salary_max: number
    salary_period?: $Enums.salaryPeriod
    visa_sponsorship?: $Enums.visaSponsorship
    experience_level?: $Enums.expLevel
    education_requirement: string
    posted_by: number
    status: $Enums.jobStatus
    posted_at?: Date | string
    deadline: Date | string
    views_count?: number
    requirements?: job_requirementsUncheckedCreateNestedManyWithoutRequirementsInput
    responsibilites?: job_responsibilitesUncheckedCreateNestedManyWithoutResponsibilitesInput
    benefits?: job_benefitsUncheckedCreateNestedManyWithoutBenefitsInput
    application?: applicationsUncheckedCreateNestedManyWithoutApplicationInput
    savedjob?: saved_jobsUncheckedCreateNestedManyWithoutSavedjobsInput
  }

  export type jobsCreateOrConnectWithoutContactInput = {
    where: jobsWhereUniqueInput
    create: XOR<jobsCreateWithoutContactInput, jobsUncheckedCreateWithoutContactInput>
  }

  export type usersCreateWithoutContactsInput = {
    first_name: string
    last_name: string
    email: string
    password_hash: string
    phone_number?: string | null
    country_code?: string | null
    date_of_birth?: Date | string | null
    gender?: string | null
    profile_picture_url?: string | null
    bio?: string | null
    created_at?: Date | string
    updated_at: Date | string
    last_login_at?: Date | string | null
    status?: $Enums.userstatus
    addresses?: user_addressesCreateNestedManyWithoutUserInput
    resumes?: resumesCreateNestedManyWithoutUserInput
    educations?: educationsCreateNestedManyWithoutUserInput
    experiences?: work_experiencesCreateNestedManyWithoutUserInput
    skills?: skillsCreateNestedManyWithoutUserInput
    languages?: languagesCreateNestedManyWithoutUserInput
    certifications?: certificationsCreateNestedManyWithoutUserInput
    visa?: visa_informationCreateNestedManyWithoutVisaInput
    application?: applicationsCreateNestedManyWithoutAplicationInput
    notification?: notificationsCreateNestedManyWithoutNotificationInput
    savedjob?: saved_jobsCreateNestedManyWithoutSavedjobInput
    searches?: job_searchesCreateNestedManyWithoutSearchesInput
  }

  export type usersUncheckedCreateWithoutContactsInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password_hash: string
    phone_number?: string | null
    country_code?: string | null
    date_of_birth?: Date | string | null
    gender?: string | null
    profile_picture_url?: string | null
    bio?: string | null
    created_at?: Date | string
    updated_at: Date | string
    last_login_at?: Date | string | null
    status?: $Enums.userstatus
    addresses?: user_addressesUncheckedCreateNestedManyWithoutUserInput
    resumes?: resumesUncheckedCreateNestedManyWithoutUserInput
    educations?: educationsUncheckedCreateNestedManyWithoutUserInput
    experiences?: work_experiencesUncheckedCreateNestedManyWithoutUserInput
    skills?: skillsUncheckedCreateNestedManyWithoutUserInput
    languages?: languagesUncheckedCreateNestedManyWithoutUserInput
    certifications?: certificationsUncheckedCreateNestedManyWithoutUserInput
    visa?: visa_informationUncheckedCreateNestedManyWithoutVisaInput
    application?: applicationsUncheckedCreateNestedManyWithoutAplicationInput
    notification?: notificationsUncheckedCreateNestedManyWithoutNotificationInput
    savedjob?: saved_jobsUncheckedCreateNestedManyWithoutSavedjobInput
    searches?: job_searchesUncheckedCreateNestedManyWithoutSearchesInput
  }

  export type usersCreateOrConnectWithoutContactsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutContactsInput, usersUncheckedCreateWithoutContactsInput>
  }

  export type companiesCreateWithoutContactsInput = {
    name: string
    description: string
    industry: string
    founded_year: number
    website_url: string
    logo_url: string
    headquarters_country: string
    company_siz?: $Enums.companySize
    is_verified?: boolean
    created_at?: Date | string
    companies?: company_locationsCreateNestedManyWithoutCompaniesInput
    job?: jobsCreateNestedManyWithoutJobInput
  }

  export type companiesUncheckedCreateWithoutContactsInput = {
    id?: number
    name: string
    description: string
    industry: string
    founded_year: number
    website_url: string
    logo_url: string
    headquarters_country: string
    company_siz?: $Enums.companySize
    is_verified?: boolean
    created_at?: Date | string
    companies?: company_locationsUncheckedCreateNestedManyWithoutCompaniesInput
    job?: jobsUncheckedCreateNestedManyWithoutJobInput
  }

  export type companiesCreateOrConnectWithoutContactsInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesCreateWithoutContactsInput, companiesUncheckedCreateWithoutContactsInput>
  }

  export type jobsUpsertWithoutContactInput = {
    update: XOR<jobsUpdateWithoutContactInput, jobsUncheckedUpdateWithoutContactInput>
    create: XOR<jobsCreateWithoutContactInput, jobsUncheckedCreateWithoutContactInput>
    where?: jobsWhereInput
  }

  export type jobsUpdateToOneWithWhereWithoutContactInput = {
    where?: jobsWhereInput
    data: XOR<jobsUpdateWithoutContactInput, jobsUncheckedUpdateWithoutContactInput>
  }

  export type jobsUpdateWithoutContactInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    job_category?: StringFieldUpdateOperationsInput | string
    job_type?: EnumjobTypeFieldUpdateOperationsInput | $Enums.jobType
    location_country?: StringFieldUpdateOperationsInput | string
    location_city?: StringFieldUpdateOperationsInput | string
    is_relocation_assistance?: BoolFieldUpdateOperationsInput | boolean
    is_remote_possible?: BoolFieldUpdateOperationsInput | boolean
    salary_currency?: StringFieldUpdateOperationsInput | string
    salary_min?: IntFieldUpdateOperationsInput | number
    salary_max?: IntFieldUpdateOperationsInput | number
    salary_period?: EnumsalaryPeriodFieldUpdateOperationsInput | $Enums.salaryPeriod
    visa_sponsorship?: EnumvisaSponsorshipFieldUpdateOperationsInput | $Enums.visaSponsorship
    experience_level?: EnumexpLevelFieldUpdateOperationsInput | $Enums.expLevel
    education_requirement?: StringFieldUpdateOperationsInput | string
    posted_by?: IntFieldUpdateOperationsInput | number
    status?: EnumjobStatusFieldUpdateOperationsInput | $Enums.jobStatus
    posted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    views_count?: IntFieldUpdateOperationsInput | number
    job?: companiesUpdateOneRequiredWithoutJobNestedInput
    requirements?: job_requirementsUpdateManyWithoutRequirementsNestedInput
    responsibilites?: job_responsibilitesUpdateManyWithoutResponsibilitesNestedInput
    benefits?: job_benefitsUpdateManyWithoutBenefitsNestedInput
    application?: applicationsUpdateManyWithoutApplicationNestedInput
    savedjob?: saved_jobsUpdateManyWithoutSavedjobsNestedInput
  }

  export type jobsUncheckedUpdateWithoutContactInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    job_category?: StringFieldUpdateOperationsInput | string
    job_type?: EnumjobTypeFieldUpdateOperationsInput | $Enums.jobType
    location_country?: StringFieldUpdateOperationsInput | string
    location_city?: StringFieldUpdateOperationsInput | string
    is_relocation_assistance?: BoolFieldUpdateOperationsInput | boolean
    is_remote_possible?: BoolFieldUpdateOperationsInput | boolean
    salary_currency?: StringFieldUpdateOperationsInput | string
    salary_min?: IntFieldUpdateOperationsInput | number
    salary_max?: IntFieldUpdateOperationsInput | number
    salary_period?: EnumsalaryPeriodFieldUpdateOperationsInput | $Enums.salaryPeriod
    visa_sponsorship?: EnumvisaSponsorshipFieldUpdateOperationsInput | $Enums.visaSponsorship
    experience_level?: EnumexpLevelFieldUpdateOperationsInput | $Enums.expLevel
    education_requirement?: StringFieldUpdateOperationsInput | string
    posted_by?: IntFieldUpdateOperationsInput | number
    status?: EnumjobStatusFieldUpdateOperationsInput | $Enums.jobStatus
    posted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    views_count?: IntFieldUpdateOperationsInput | number
    requirements?: job_requirementsUncheckedUpdateManyWithoutRequirementsNestedInput
    responsibilites?: job_responsibilitesUncheckedUpdateManyWithoutResponsibilitesNestedInput
    benefits?: job_benefitsUncheckedUpdateManyWithoutBenefitsNestedInput
    application?: applicationsUncheckedUpdateManyWithoutApplicationNestedInput
    savedjob?: saved_jobsUncheckedUpdateManyWithoutSavedjobsNestedInput
  }

  export type usersUpsertWithoutContactsInput = {
    update: XOR<usersUpdateWithoutContactsInput, usersUncheckedUpdateWithoutContactsInput>
    create: XOR<usersCreateWithoutContactsInput, usersUncheckedCreateWithoutContactsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutContactsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutContactsInput, usersUncheckedUpdateWithoutContactsInput>
  }

  export type usersUpdateWithoutContactsInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumuserstatusFieldUpdateOperationsInput | $Enums.userstatus
    addresses?: user_addressesUpdateManyWithoutUserNestedInput
    resumes?: resumesUpdateManyWithoutUserNestedInput
    educations?: educationsUpdateManyWithoutUserNestedInput
    experiences?: work_experiencesUpdateManyWithoutUserNestedInput
    skills?: skillsUpdateManyWithoutUserNestedInput
    languages?: languagesUpdateManyWithoutUserNestedInput
    certifications?: certificationsUpdateManyWithoutUserNestedInput
    visa?: visa_informationUpdateManyWithoutVisaNestedInput
    application?: applicationsUpdateManyWithoutAplicationNestedInput
    notification?: notificationsUpdateManyWithoutNotificationNestedInput
    savedjob?: saved_jobsUpdateManyWithoutSavedjobNestedInput
    searches?: job_searchesUpdateManyWithoutSearchesNestedInput
  }

  export type usersUncheckedUpdateWithoutContactsInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumuserstatusFieldUpdateOperationsInput | $Enums.userstatus
    addresses?: user_addressesUncheckedUpdateManyWithoutUserNestedInput
    resumes?: resumesUncheckedUpdateManyWithoutUserNestedInput
    educations?: educationsUncheckedUpdateManyWithoutUserNestedInput
    experiences?: work_experiencesUncheckedUpdateManyWithoutUserNestedInput
    skills?: skillsUncheckedUpdateManyWithoutUserNestedInput
    languages?: languagesUncheckedUpdateManyWithoutUserNestedInput
    certifications?: certificationsUncheckedUpdateManyWithoutUserNestedInput
    visa?: visa_informationUncheckedUpdateManyWithoutVisaNestedInput
    application?: applicationsUncheckedUpdateManyWithoutAplicationNestedInput
    notification?: notificationsUncheckedUpdateManyWithoutNotificationNestedInput
    savedjob?: saved_jobsUncheckedUpdateManyWithoutSavedjobNestedInput
    searches?: job_searchesUncheckedUpdateManyWithoutSearchesNestedInput
  }

  export type companiesUpsertWithoutContactsInput = {
    update: XOR<companiesUpdateWithoutContactsInput, companiesUncheckedUpdateWithoutContactsInput>
    create: XOR<companiesCreateWithoutContactsInput, companiesUncheckedCreateWithoutContactsInput>
    where?: companiesWhereInput
  }

  export type companiesUpdateToOneWithWhereWithoutContactsInput = {
    where?: companiesWhereInput
    data: XOR<companiesUpdateWithoutContactsInput, companiesUncheckedUpdateWithoutContactsInput>
  }

  export type companiesUpdateWithoutContactsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    founded_year?: IntFieldUpdateOperationsInput | number
    website_url?: StringFieldUpdateOperationsInput | string
    logo_url?: StringFieldUpdateOperationsInput | string
    headquarters_country?: StringFieldUpdateOperationsInput | string
    company_siz?: EnumcompanySizeFieldUpdateOperationsInput | $Enums.companySize
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: company_locationsUpdateManyWithoutCompaniesNestedInput
    job?: jobsUpdateManyWithoutJobNestedInput
  }

  export type companiesUncheckedUpdateWithoutContactsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    founded_year?: IntFieldUpdateOperationsInput | number
    website_url?: StringFieldUpdateOperationsInput | string
    logo_url?: StringFieldUpdateOperationsInput | string
    headquarters_country?: StringFieldUpdateOperationsInput | string
    company_siz?: EnumcompanySizeFieldUpdateOperationsInput | $Enums.companySize
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: company_locationsUncheckedUpdateManyWithoutCompaniesNestedInput
    job?: jobsUncheckedUpdateManyWithoutJobNestedInput
  }

  export type usersCreateWithoutNotificationInput = {
    first_name: string
    last_name: string
    email: string
    password_hash: string
    phone_number?: string | null
    country_code?: string | null
    date_of_birth?: Date | string | null
    gender?: string | null
    profile_picture_url?: string | null
    bio?: string | null
    created_at?: Date | string
    updated_at: Date | string
    last_login_at?: Date | string | null
    status?: $Enums.userstatus
    addresses?: user_addressesCreateNestedManyWithoutUserInput
    resumes?: resumesCreateNestedManyWithoutUserInput
    educations?: educationsCreateNestedManyWithoutUserInput
    experiences?: work_experiencesCreateNestedManyWithoutUserInput
    skills?: skillsCreateNestedManyWithoutUserInput
    languages?: languagesCreateNestedManyWithoutUserInput
    certifications?: certificationsCreateNestedManyWithoutUserInput
    visa?: visa_informationCreateNestedManyWithoutVisaInput
    application?: applicationsCreateNestedManyWithoutAplicationInput
    contacts?: contactsCreateNestedManyWithoutContactsInput
    savedjob?: saved_jobsCreateNestedManyWithoutSavedjobInput
    searches?: job_searchesCreateNestedManyWithoutSearchesInput
  }

  export type usersUncheckedCreateWithoutNotificationInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password_hash: string
    phone_number?: string | null
    country_code?: string | null
    date_of_birth?: Date | string | null
    gender?: string | null
    profile_picture_url?: string | null
    bio?: string | null
    created_at?: Date | string
    updated_at: Date | string
    last_login_at?: Date | string | null
    status?: $Enums.userstatus
    addresses?: user_addressesUncheckedCreateNestedManyWithoutUserInput
    resumes?: resumesUncheckedCreateNestedManyWithoutUserInput
    educations?: educationsUncheckedCreateNestedManyWithoutUserInput
    experiences?: work_experiencesUncheckedCreateNestedManyWithoutUserInput
    skills?: skillsUncheckedCreateNestedManyWithoutUserInput
    languages?: languagesUncheckedCreateNestedManyWithoutUserInput
    certifications?: certificationsUncheckedCreateNestedManyWithoutUserInput
    visa?: visa_informationUncheckedCreateNestedManyWithoutVisaInput
    application?: applicationsUncheckedCreateNestedManyWithoutAplicationInput
    contacts?: contactsUncheckedCreateNestedManyWithoutContactsInput
    savedjob?: saved_jobsUncheckedCreateNestedManyWithoutSavedjobInput
    searches?: job_searchesUncheckedCreateNestedManyWithoutSearchesInput
  }

  export type usersCreateOrConnectWithoutNotificationInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutNotificationInput, usersUncheckedCreateWithoutNotificationInput>
  }

  export type usersUpsertWithoutNotificationInput = {
    update: XOR<usersUpdateWithoutNotificationInput, usersUncheckedUpdateWithoutNotificationInput>
    create: XOR<usersCreateWithoutNotificationInput, usersUncheckedCreateWithoutNotificationInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutNotificationInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutNotificationInput, usersUncheckedUpdateWithoutNotificationInput>
  }

  export type usersUpdateWithoutNotificationInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumuserstatusFieldUpdateOperationsInput | $Enums.userstatus
    addresses?: user_addressesUpdateManyWithoutUserNestedInput
    resumes?: resumesUpdateManyWithoutUserNestedInput
    educations?: educationsUpdateManyWithoutUserNestedInput
    experiences?: work_experiencesUpdateManyWithoutUserNestedInput
    skills?: skillsUpdateManyWithoutUserNestedInput
    languages?: languagesUpdateManyWithoutUserNestedInput
    certifications?: certificationsUpdateManyWithoutUserNestedInput
    visa?: visa_informationUpdateManyWithoutVisaNestedInput
    application?: applicationsUpdateManyWithoutAplicationNestedInput
    contacts?: contactsUpdateManyWithoutContactsNestedInput
    savedjob?: saved_jobsUpdateManyWithoutSavedjobNestedInput
    searches?: job_searchesUpdateManyWithoutSearchesNestedInput
  }

  export type usersUncheckedUpdateWithoutNotificationInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumuserstatusFieldUpdateOperationsInput | $Enums.userstatus
    addresses?: user_addressesUncheckedUpdateManyWithoutUserNestedInput
    resumes?: resumesUncheckedUpdateManyWithoutUserNestedInput
    educations?: educationsUncheckedUpdateManyWithoutUserNestedInput
    experiences?: work_experiencesUncheckedUpdateManyWithoutUserNestedInput
    skills?: skillsUncheckedUpdateManyWithoutUserNestedInput
    languages?: languagesUncheckedUpdateManyWithoutUserNestedInput
    certifications?: certificationsUncheckedUpdateManyWithoutUserNestedInput
    visa?: visa_informationUncheckedUpdateManyWithoutVisaNestedInput
    application?: applicationsUncheckedUpdateManyWithoutAplicationNestedInput
    contacts?: contactsUncheckedUpdateManyWithoutContactsNestedInput
    savedjob?: saved_jobsUncheckedUpdateManyWithoutSavedjobNestedInput
    searches?: job_searchesUncheckedUpdateManyWithoutSearchesNestedInput
  }

  export type usersCreateWithoutSavedjobInput = {
    first_name: string
    last_name: string
    email: string
    password_hash: string
    phone_number?: string | null
    country_code?: string | null
    date_of_birth?: Date | string | null
    gender?: string | null
    profile_picture_url?: string | null
    bio?: string | null
    created_at?: Date | string
    updated_at: Date | string
    last_login_at?: Date | string | null
    status?: $Enums.userstatus
    addresses?: user_addressesCreateNestedManyWithoutUserInput
    resumes?: resumesCreateNestedManyWithoutUserInput
    educations?: educationsCreateNestedManyWithoutUserInput
    experiences?: work_experiencesCreateNestedManyWithoutUserInput
    skills?: skillsCreateNestedManyWithoutUserInput
    languages?: languagesCreateNestedManyWithoutUserInput
    certifications?: certificationsCreateNestedManyWithoutUserInput
    visa?: visa_informationCreateNestedManyWithoutVisaInput
    application?: applicationsCreateNestedManyWithoutAplicationInput
    contacts?: contactsCreateNestedManyWithoutContactsInput
    notification?: notificationsCreateNestedManyWithoutNotificationInput
    searches?: job_searchesCreateNestedManyWithoutSearchesInput
  }

  export type usersUncheckedCreateWithoutSavedjobInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password_hash: string
    phone_number?: string | null
    country_code?: string | null
    date_of_birth?: Date | string | null
    gender?: string | null
    profile_picture_url?: string | null
    bio?: string | null
    created_at?: Date | string
    updated_at: Date | string
    last_login_at?: Date | string | null
    status?: $Enums.userstatus
    addresses?: user_addressesUncheckedCreateNestedManyWithoutUserInput
    resumes?: resumesUncheckedCreateNestedManyWithoutUserInput
    educations?: educationsUncheckedCreateNestedManyWithoutUserInput
    experiences?: work_experiencesUncheckedCreateNestedManyWithoutUserInput
    skills?: skillsUncheckedCreateNestedManyWithoutUserInput
    languages?: languagesUncheckedCreateNestedManyWithoutUserInput
    certifications?: certificationsUncheckedCreateNestedManyWithoutUserInput
    visa?: visa_informationUncheckedCreateNestedManyWithoutVisaInput
    application?: applicationsUncheckedCreateNestedManyWithoutAplicationInput
    contacts?: contactsUncheckedCreateNestedManyWithoutContactsInput
    notification?: notificationsUncheckedCreateNestedManyWithoutNotificationInput
    searches?: job_searchesUncheckedCreateNestedManyWithoutSearchesInput
  }

  export type usersCreateOrConnectWithoutSavedjobInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutSavedjobInput, usersUncheckedCreateWithoutSavedjobInput>
  }

  export type jobsCreateWithoutSavedjobInput = {
    title: string
    description: string
    job_category: string
    job_type: $Enums.jobType
    location_country: string
    location_city: string
    is_relocation_assistance?: boolean
    is_remote_possible?: boolean
    salary_currency: string
    salary_min: number
    salary_max: number
    salary_period?: $Enums.salaryPeriod
    visa_sponsorship?: $Enums.visaSponsorship
    experience_level?: $Enums.expLevel
    education_requirement: string
    posted_by: number
    status: $Enums.jobStatus
    posted_at?: Date | string
    deadline: Date | string
    views_count?: number
    job: companiesCreateNestedOneWithoutJobInput
    requirements?: job_requirementsCreateNestedManyWithoutRequirementsInput
    responsibilites?: job_responsibilitesCreateNestedManyWithoutResponsibilitesInput
    benefits?: job_benefitsCreateNestedManyWithoutBenefitsInput
    application?: applicationsCreateNestedManyWithoutApplicationInput
    contact?: contactsCreateNestedManyWithoutContactInput
  }

  export type jobsUncheckedCreateWithoutSavedjobInput = {
    id?: number
    company_id: number
    title: string
    description: string
    job_category: string
    job_type: $Enums.jobType
    location_country: string
    location_city: string
    is_relocation_assistance?: boolean
    is_remote_possible?: boolean
    salary_currency: string
    salary_min: number
    salary_max: number
    salary_period?: $Enums.salaryPeriod
    visa_sponsorship?: $Enums.visaSponsorship
    experience_level?: $Enums.expLevel
    education_requirement: string
    posted_by: number
    status: $Enums.jobStatus
    posted_at?: Date | string
    deadline: Date | string
    views_count?: number
    requirements?: job_requirementsUncheckedCreateNestedManyWithoutRequirementsInput
    responsibilites?: job_responsibilitesUncheckedCreateNestedManyWithoutResponsibilitesInput
    benefits?: job_benefitsUncheckedCreateNestedManyWithoutBenefitsInput
    application?: applicationsUncheckedCreateNestedManyWithoutApplicationInput
    contact?: contactsUncheckedCreateNestedManyWithoutContactInput
  }

  export type jobsCreateOrConnectWithoutSavedjobInput = {
    where: jobsWhereUniqueInput
    create: XOR<jobsCreateWithoutSavedjobInput, jobsUncheckedCreateWithoutSavedjobInput>
  }

  export type usersUpsertWithoutSavedjobInput = {
    update: XOR<usersUpdateWithoutSavedjobInput, usersUncheckedUpdateWithoutSavedjobInput>
    create: XOR<usersCreateWithoutSavedjobInput, usersUncheckedCreateWithoutSavedjobInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutSavedjobInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutSavedjobInput, usersUncheckedUpdateWithoutSavedjobInput>
  }

  export type usersUpdateWithoutSavedjobInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumuserstatusFieldUpdateOperationsInput | $Enums.userstatus
    addresses?: user_addressesUpdateManyWithoutUserNestedInput
    resumes?: resumesUpdateManyWithoutUserNestedInput
    educations?: educationsUpdateManyWithoutUserNestedInput
    experiences?: work_experiencesUpdateManyWithoutUserNestedInput
    skills?: skillsUpdateManyWithoutUserNestedInput
    languages?: languagesUpdateManyWithoutUserNestedInput
    certifications?: certificationsUpdateManyWithoutUserNestedInput
    visa?: visa_informationUpdateManyWithoutVisaNestedInput
    application?: applicationsUpdateManyWithoutAplicationNestedInput
    contacts?: contactsUpdateManyWithoutContactsNestedInput
    notification?: notificationsUpdateManyWithoutNotificationNestedInput
    searches?: job_searchesUpdateManyWithoutSearchesNestedInput
  }

  export type usersUncheckedUpdateWithoutSavedjobInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumuserstatusFieldUpdateOperationsInput | $Enums.userstatus
    addresses?: user_addressesUncheckedUpdateManyWithoutUserNestedInput
    resumes?: resumesUncheckedUpdateManyWithoutUserNestedInput
    educations?: educationsUncheckedUpdateManyWithoutUserNestedInput
    experiences?: work_experiencesUncheckedUpdateManyWithoutUserNestedInput
    skills?: skillsUncheckedUpdateManyWithoutUserNestedInput
    languages?: languagesUncheckedUpdateManyWithoutUserNestedInput
    certifications?: certificationsUncheckedUpdateManyWithoutUserNestedInput
    visa?: visa_informationUncheckedUpdateManyWithoutVisaNestedInput
    application?: applicationsUncheckedUpdateManyWithoutAplicationNestedInput
    contacts?: contactsUncheckedUpdateManyWithoutContactsNestedInput
    notification?: notificationsUncheckedUpdateManyWithoutNotificationNestedInput
    searches?: job_searchesUncheckedUpdateManyWithoutSearchesNestedInput
  }

  export type jobsUpsertWithoutSavedjobInput = {
    update: XOR<jobsUpdateWithoutSavedjobInput, jobsUncheckedUpdateWithoutSavedjobInput>
    create: XOR<jobsCreateWithoutSavedjobInput, jobsUncheckedCreateWithoutSavedjobInput>
    where?: jobsWhereInput
  }

  export type jobsUpdateToOneWithWhereWithoutSavedjobInput = {
    where?: jobsWhereInput
    data: XOR<jobsUpdateWithoutSavedjobInput, jobsUncheckedUpdateWithoutSavedjobInput>
  }

  export type jobsUpdateWithoutSavedjobInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    job_category?: StringFieldUpdateOperationsInput | string
    job_type?: EnumjobTypeFieldUpdateOperationsInput | $Enums.jobType
    location_country?: StringFieldUpdateOperationsInput | string
    location_city?: StringFieldUpdateOperationsInput | string
    is_relocation_assistance?: BoolFieldUpdateOperationsInput | boolean
    is_remote_possible?: BoolFieldUpdateOperationsInput | boolean
    salary_currency?: StringFieldUpdateOperationsInput | string
    salary_min?: IntFieldUpdateOperationsInput | number
    salary_max?: IntFieldUpdateOperationsInput | number
    salary_period?: EnumsalaryPeriodFieldUpdateOperationsInput | $Enums.salaryPeriod
    visa_sponsorship?: EnumvisaSponsorshipFieldUpdateOperationsInput | $Enums.visaSponsorship
    experience_level?: EnumexpLevelFieldUpdateOperationsInput | $Enums.expLevel
    education_requirement?: StringFieldUpdateOperationsInput | string
    posted_by?: IntFieldUpdateOperationsInput | number
    status?: EnumjobStatusFieldUpdateOperationsInput | $Enums.jobStatus
    posted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    views_count?: IntFieldUpdateOperationsInput | number
    job?: companiesUpdateOneRequiredWithoutJobNestedInput
    requirements?: job_requirementsUpdateManyWithoutRequirementsNestedInput
    responsibilites?: job_responsibilitesUpdateManyWithoutResponsibilitesNestedInput
    benefits?: job_benefitsUpdateManyWithoutBenefitsNestedInput
    application?: applicationsUpdateManyWithoutApplicationNestedInput
    contact?: contactsUpdateManyWithoutContactNestedInput
  }

  export type jobsUncheckedUpdateWithoutSavedjobInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    job_category?: StringFieldUpdateOperationsInput | string
    job_type?: EnumjobTypeFieldUpdateOperationsInput | $Enums.jobType
    location_country?: StringFieldUpdateOperationsInput | string
    location_city?: StringFieldUpdateOperationsInput | string
    is_relocation_assistance?: BoolFieldUpdateOperationsInput | boolean
    is_remote_possible?: BoolFieldUpdateOperationsInput | boolean
    salary_currency?: StringFieldUpdateOperationsInput | string
    salary_min?: IntFieldUpdateOperationsInput | number
    salary_max?: IntFieldUpdateOperationsInput | number
    salary_period?: EnumsalaryPeriodFieldUpdateOperationsInput | $Enums.salaryPeriod
    visa_sponsorship?: EnumvisaSponsorshipFieldUpdateOperationsInput | $Enums.visaSponsorship
    experience_level?: EnumexpLevelFieldUpdateOperationsInput | $Enums.expLevel
    education_requirement?: StringFieldUpdateOperationsInput | string
    posted_by?: IntFieldUpdateOperationsInput | number
    status?: EnumjobStatusFieldUpdateOperationsInput | $Enums.jobStatus
    posted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    views_count?: IntFieldUpdateOperationsInput | number
    requirements?: job_requirementsUncheckedUpdateManyWithoutRequirementsNestedInput
    responsibilites?: job_responsibilitesUncheckedUpdateManyWithoutResponsibilitesNestedInput
    benefits?: job_benefitsUncheckedUpdateManyWithoutBenefitsNestedInput
    application?: applicationsUncheckedUpdateManyWithoutApplicationNestedInput
    contact?: contactsUncheckedUpdateManyWithoutContactNestedInput
  }

  export type usersCreateWithoutSearchesInput = {
    first_name: string
    last_name: string
    email: string
    password_hash: string
    phone_number?: string | null
    country_code?: string | null
    date_of_birth?: Date | string | null
    gender?: string | null
    profile_picture_url?: string | null
    bio?: string | null
    created_at?: Date | string
    updated_at: Date | string
    last_login_at?: Date | string | null
    status?: $Enums.userstatus
    addresses?: user_addressesCreateNestedManyWithoutUserInput
    resumes?: resumesCreateNestedManyWithoutUserInput
    educations?: educationsCreateNestedManyWithoutUserInput
    experiences?: work_experiencesCreateNestedManyWithoutUserInput
    skills?: skillsCreateNestedManyWithoutUserInput
    languages?: languagesCreateNestedManyWithoutUserInput
    certifications?: certificationsCreateNestedManyWithoutUserInput
    visa?: visa_informationCreateNestedManyWithoutVisaInput
    application?: applicationsCreateNestedManyWithoutAplicationInput
    contacts?: contactsCreateNestedManyWithoutContactsInput
    notification?: notificationsCreateNestedManyWithoutNotificationInput
    savedjob?: saved_jobsCreateNestedManyWithoutSavedjobInput
  }

  export type usersUncheckedCreateWithoutSearchesInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password_hash: string
    phone_number?: string | null
    country_code?: string | null
    date_of_birth?: Date | string | null
    gender?: string | null
    profile_picture_url?: string | null
    bio?: string | null
    created_at?: Date | string
    updated_at: Date | string
    last_login_at?: Date | string | null
    status?: $Enums.userstatus
    addresses?: user_addressesUncheckedCreateNestedManyWithoutUserInput
    resumes?: resumesUncheckedCreateNestedManyWithoutUserInput
    educations?: educationsUncheckedCreateNestedManyWithoutUserInput
    experiences?: work_experiencesUncheckedCreateNestedManyWithoutUserInput
    skills?: skillsUncheckedCreateNestedManyWithoutUserInput
    languages?: languagesUncheckedCreateNestedManyWithoutUserInput
    certifications?: certificationsUncheckedCreateNestedManyWithoutUserInput
    visa?: visa_informationUncheckedCreateNestedManyWithoutVisaInput
    application?: applicationsUncheckedCreateNestedManyWithoutAplicationInput
    contacts?: contactsUncheckedCreateNestedManyWithoutContactsInput
    notification?: notificationsUncheckedCreateNestedManyWithoutNotificationInput
    savedjob?: saved_jobsUncheckedCreateNestedManyWithoutSavedjobInput
  }

  export type usersCreateOrConnectWithoutSearchesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutSearchesInput, usersUncheckedCreateWithoutSearchesInput>
  }

  export type usersUpsertWithoutSearchesInput = {
    update: XOR<usersUpdateWithoutSearchesInput, usersUncheckedUpdateWithoutSearchesInput>
    create: XOR<usersCreateWithoutSearchesInput, usersUncheckedCreateWithoutSearchesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutSearchesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutSearchesInput, usersUncheckedUpdateWithoutSearchesInput>
  }

  export type usersUpdateWithoutSearchesInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumuserstatusFieldUpdateOperationsInput | $Enums.userstatus
    addresses?: user_addressesUpdateManyWithoutUserNestedInput
    resumes?: resumesUpdateManyWithoutUserNestedInput
    educations?: educationsUpdateManyWithoutUserNestedInput
    experiences?: work_experiencesUpdateManyWithoutUserNestedInput
    skills?: skillsUpdateManyWithoutUserNestedInput
    languages?: languagesUpdateManyWithoutUserNestedInput
    certifications?: certificationsUpdateManyWithoutUserNestedInput
    visa?: visa_informationUpdateManyWithoutVisaNestedInput
    application?: applicationsUpdateManyWithoutAplicationNestedInput
    contacts?: contactsUpdateManyWithoutContactsNestedInput
    notification?: notificationsUpdateManyWithoutNotificationNestedInput
    savedjob?: saved_jobsUpdateManyWithoutSavedjobNestedInput
  }

  export type usersUncheckedUpdateWithoutSearchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumuserstatusFieldUpdateOperationsInput | $Enums.userstatus
    addresses?: user_addressesUncheckedUpdateManyWithoutUserNestedInput
    resumes?: resumesUncheckedUpdateManyWithoutUserNestedInput
    educations?: educationsUncheckedUpdateManyWithoutUserNestedInput
    experiences?: work_experiencesUncheckedUpdateManyWithoutUserNestedInput
    skills?: skillsUncheckedUpdateManyWithoutUserNestedInput
    languages?: languagesUncheckedUpdateManyWithoutUserNestedInput
    certifications?: certificationsUncheckedUpdateManyWithoutUserNestedInput
    visa?: visa_informationUncheckedUpdateManyWithoutVisaNestedInput
    application?: applicationsUncheckedUpdateManyWithoutAplicationNestedInput
    contacts?: contactsUncheckedUpdateManyWithoutContactsNestedInput
    notification?: notificationsUncheckedUpdateManyWithoutNotificationNestedInput
    savedjob?: saved_jobsUncheckedUpdateManyWithoutSavedjobNestedInput
  }

  export type user_addressesCreateManyUserInput = {
    id?: number
    adress_line1: string
    adress_line2?: string | null
    city: string
    state?: string | null
    postal_code?: string | null
    country: string
    is_primary?: boolean | null
    created_at?: Date | string | null
  }

  export type resumesCreateManyUserInput = {
    id?: number
    title: string
    file_url: string
    is_default?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type educationsCreateManyUserInput = {
    id?: number
    institution: string
    degree: string
    field_of_study: string
    start_date: Date | string
    end_date: Date | string
    grade: string
    description: string
    is_foreign_education?: boolean
    country: string
  }

  export type work_experiencesCreateManyUserInput = {
    id?: number
    company_name: string
    position: string
    location: string
    country: string
    start_date: Date | string
    end_date: Date | string
    is_current_job?: boolean
    description: string
    is_foregin_experience?: boolean
  }

  export type skillsCreateManyUserInput = {
    id?: number
    skill_name: string
    proficiency?: $Enums.skillsstatus
    year_of_experience: number
    is_certifield?: boolean
  }

  export type languagesCreateManyUserInput = {
    id?: number
    languages: string
    proficiency: $Enums.proficiencylanguages
    is_primary?: boolean
  }

  export type certificationsCreateManyUserInput = {
    id?: number
    name: string
    issuing_organization: string
    issue_date: Date | string
    expiration_date: Date | string
    credential_id: string
    credential_url: string
    is_foreign_certification?: boolean
  }

  export type visa_informationCreateManyVisaInput = {
    id?: number
    visa_type: string
    country: string
    status: string
    expiry__date: Date | string
    is_multiple_entry?: boolean
    notes: string
  }

  export type applicationsCreateManyAplicationInput = {
    id?: number
    job_id: number
    resume_id: number
    cover_letter: string
    status: $Enums.applicationStatus
    applited_at?: Date | string
    updated_at?: Date | string
    notes: string
  }

  export type contactsCreateManyContactsInput = {
    id?: number
    job_id: number
    company_id: number
    contact_type: $Enums.contactType
    start_date: Date | string
    end_date: Date | string
    probation_period_months?: number
    salary_amount: number
    salary_currency: string
    salary_payment_period?: $Enums.contactSalaryPaymentPeriod
    benefits_description: string
    visa_sponsorship_details: string
    relocation_assistance_details: string
    status?: $Enums.contactStatus
    signed_at: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type notificationsCreateManyNotificationInput = {
    id?: number
    notification_type: string
    title: string
    message: string
    is_read?: boolean
    related_entity_type: string
    related_entity_id: number
    created_at?: Date | string
  }

  export type saved_jobsCreateManySavedjobInput = {
    id?: number
    job_id: number
    saved_at?: Date | string
    notes: string
  }

  export type job_searchesCreateManySearchesInput = {
    id?: number
    search_query: string
    country: string
    city: string
    job_catregory: string
    experience_level: string
    job_type: string
    created_at?: Date | string
  }

  export type user_addressesUpdateWithoutUserInput = {
    adress_line1?: StringFieldUpdateOperationsInput | string
    adress_line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    is_primary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_addressesUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    adress_line1?: StringFieldUpdateOperationsInput | string
    adress_line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    is_primary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_addressesUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    adress_line1?: StringFieldUpdateOperationsInput | string
    adress_line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    is_primary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type resumesUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    file_url?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: applicationsUpdateManyWithoutApplicationsNestedInput
  }

  export type resumesUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    file_url?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: applicationsUncheckedUpdateManyWithoutApplicationsNestedInput
  }

  export type resumesUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    file_url?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type educationsUpdateWithoutUserInput = {
    institution?: StringFieldUpdateOperationsInput | string
    degree?: StringFieldUpdateOperationsInput | string
    field_of_study?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    grade?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    is_foreign_education?: BoolFieldUpdateOperationsInput | boolean
    country?: StringFieldUpdateOperationsInput | string
  }

  export type educationsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    institution?: StringFieldUpdateOperationsInput | string
    degree?: StringFieldUpdateOperationsInput | string
    field_of_study?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    grade?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    is_foreign_education?: BoolFieldUpdateOperationsInput | boolean
    country?: StringFieldUpdateOperationsInput | string
  }

  export type educationsUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    institution?: StringFieldUpdateOperationsInput | string
    degree?: StringFieldUpdateOperationsInput | string
    field_of_study?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    grade?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    is_foreign_education?: BoolFieldUpdateOperationsInput | boolean
    country?: StringFieldUpdateOperationsInput | string
  }

  export type work_experiencesUpdateWithoutUserInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_current_job?: BoolFieldUpdateOperationsInput | boolean
    description?: StringFieldUpdateOperationsInput | string
    is_foregin_experience?: BoolFieldUpdateOperationsInput | boolean
  }

  export type work_experiencesUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_current_job?: BoolFieldUpdateOperationsInput | boolean
    description?: StringFieldUpdateOperationsInput | string
    is_foregin_experience?: BoolFieldUpdateOperationsInput | boolean
  }

  export type work_experiencesUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_current_job?: BoolFieldUpdateOperationsInput | boolean
    description?: StringFieldUpdateOperationsInput | string
    is_foregin_experience?: BoolFieldUpdateOperationsInput | boolean
  }

  export type skillsUpdateWithoutUserInput = {
    skill_name?: StringFieldUpdateOperationsInput | string
    proficiency?: EnumskillsstatusFieldUpdateOperationsInput | $Enums.skillsstatus
    year_of_experience?: IntFieldUpdateOperationsInput | number
    is_certifield?: BoolFieldUpdateOperationsInput | boolean
  }

  export type skillsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    skill_name?: StringFieldUpdateOperationsInput | string
    proficiency?: EnumskillsstatusFieldUpdateOperationsInput | $Enums.skillsstatus
    year_of_experience?: IntFieldUpdateOperationsInput | number
    is_certifield?: BoolFieldUpdateOperationsInput | boolean
  }

  export type skillsUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    skill_name?: StringFieldUpdateOperationsInput | string
    proficiency?: EnumskillsstatusFieldUpdateOperationsInput | $Enums.skillsstatus
    year_of_experience?: IntFieldUpdateOperationsInput | number
    is_certifield?: BoolFieldUpdateOperationsInput | boolean
  }

  export type languagesUpdateWithoutUserInput = {
    languages?: StringFieldUpdateOperationsInput | string
    proficiency?: EnumproficiencylanguagesFieldUpdateOperationsInput | $Enums.proficiencylanguages
    is_primary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type languagesUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    languages?: StringFieldUpdateOperationsInput | string
    proficiency?: EnumproficiencylanguagesFieldUpdateOperationsInput | $Enums.proficiencylanguages
    is_primary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type languagesUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    languages?: StringFieldUpdateOperationsInput | string
    proficiency?: EnumproficiencylanguagesFieldUpdateOperationsInput | $Enums.proficiencylanguages
    is_primary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type certificationsUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    issuing_organization?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expiration_date?: DateTimeFieldUpdateOperationsInput | Date | string
    credential_id?: StringFieldUpdateOperationsInput | string
    credential_url?: StringFieldUpdateOperationsInput | string
    is_foreign_certification?: BoolFieldUpdateOperationsInput | boolean
  }

  export type certificationsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    issuing_organization?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expiration_date?: DateTimeFieldUpdateOperationsInput | Date | string
    credential_id?: StringFieldUpdateOperationsInput | string
    credential_url?: StringFieldUpdateOperationsInput | string
    is_foreign_certification?: BoolFieldUpdateOperationsInput | boolean
  }

  export type certificationsUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    issuing_organization?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expiration_date?: DateTimeFieldUpdateOperationsInput | Date | string
    credential_id?: StringFieldUpdateOperationsInput | string
    credential_url?: StringFieldUpdateOperationsInput | string
    is_foreign_certification?: BoolFieldUpdateOperationsInput | boolean
  }

  export type visa_informationUpdateWithoutVisaInput = {
    visa_type?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    expiry__date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_multiple_entry?: BoolFieldUpdateOperationsInput | boolean
    notes?: StringFieldUpdateOperationsInput | string
  }

  export type visa_informationUncheckedUpdateWithoutVisaInput = {
    id?: IntFieldUpdateOperationsInput | number
    visa_type?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    expiry__date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_multiple_entry?: BoolFieldUpdateOperationsInput | boolean
    notes?: StringFieldUpdateOperationsInput | string
  }

  export type visa_informationUncheckedUpdateManyWithoutVisaInput = {
    id?: IntFieldUpdateOperationsInput | number
    visa_type?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    expiry__date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_multiple_entry?: BoolFieldUpdateOperationsInput | boolean
    notes?: StringFieldUpdateOperationsInput | string
  }

  export type applicationsUpdateWithoutAplicationInput = {
    cover_letter?: StringFieldUpdateOperationsInput | string
    status?: EnumapplicationStatusFieldUpdateOperationsInput | $Enums.applicationStatus
    applited_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    application?: jobsUpdateOneRequiredWithoutApplicationNestedInput
    applications?: resumesUpdateOneRequiredWithoutApplicationsNestedInput
    document?: application_documentsUpdateManyWithoutDocumentNestedInput
    interview?: interviewsUpdateManyWithoutInterviewNestedInput
  }

  export type applicationsUncheckedUpdateWithoutAplicationInput = {
    id?: IntFieldUpdateOperationsInput | number
    job_id?: IntFieldUpdateOperationsInput | number
    resume_id?: IntFieldUpdateOperationsInput | number
    cover_letter?: StringFieldUpdateOperationsInput | string
    status?: EnumapplicationStatusFieldUpdateOperationsInput | $Enums.applicationStatus
    applited_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    document?: application_documentsUncheckedUpdateManyWithoutDocumentNestedInput
    interview?: interviewsUncheckedUpdateManyWithoutInterviewNestedInput
  }

  export type applicationsUncheckedUpdateManyWithoutAplicationInput = {
    id?: IntFieldUpdateOperationsInput | number
    job_id?: IntFieldUpdateOperationsInput | number
    resume_id?: IntFieldUpdateOperationsInput | number
    cover_letter?: StringFieldUpdateOperationsInput | string
    status?: EnumapplicationStatusFieldUpdateOperationsInput | $Enums.applicationStatus
    applited_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
  }

  export type contactsUpdateWithoutContactsInput = {
    contact_type?: EnumcontactTypeFieldUpdateOperationsInput | $Enums.contactType
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    probation_period_months?: IntFieldUpdateOperationsInput | number
    salary_amount?: IntFieldUpdateOperationsInput | number
    salary_currency?: StringFieldUpdateOperationsInput | string
    salary_payment_period?: EnumcontactSalaryPaymentPeriodFieldUpdateOperationsInput | $Enums.contactSalaryPaymentPeriod
    benefits_description?: StringFieldUpdateOperationsInput | string
    visa_sponsorship_details?: StringFieldUpdateOperationsInput | string
    relocation_assistance_details?: StringFieldUpdateOperationsInput | string
    status?: EnumcontactStatusFieldUpdateOperationsInput | $Enums.contactStatus
    signed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: jobsUpdateOneRequiredWithoutContactNestedInput
    contac?: companiesUpdateOneRequiredWithoutContactsNestedInput
  }

  export type contactsUncheckedUpdateWithoutContactsInput = {
    id?: IntFieldUpdateOperationsInput | number
    job_id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    contact_type?: EnumcontactTypeFieldUpdateOperationsInput | $Enums.contactType
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    probation_period_months?: IntFieldUpdateOperationsInput | number
    salary_amount?: IntFieldUpdateOperationsInput | number
    salary_currency?: StringFieldUpdateOperationsInput | string
    salary_payment_period?: EnumcontactSalaryPaymentPeriodFieldUpdateOperationsInput | $Enums.contactSalaryPaymentPeriod
    benefits_description?: StringFieldUpdateOperationsInput | string
    visa_sponsorship_details?: StringFieldUpdateOperationsInput | string
    relocation_assistance_details?: StringFieldUpdateOperationsInput | string
    status?: EnumcontactStatusFieldUpdateOperationsInput | $Enums.contactStatus
    signed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type contactsUncheckedUpdateManyWithoutContactsInput = {
    id?: IntFieldUpdateOperationsInput | number
    job_id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    contact_type?: EnumcontactTypeFieldUpdateOperationsInput | $Enums.contactType
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    probation_period_months?: IntFieldUpdateOperationsInput | number
    salary_amount?: IntFieldUpdateOperationsInput | number
    salary_currency?: StringFieldUpdateOperationsInput | string
    salary_payment_period?: EnumcontactSalaryPaymentPeriodFieldUpdateOperationsInput | $Enums.contactSalaryPaymentPeriod
    benefits_description?: StringFieldUpdateOperationsInput | string
    visa_sponsorship_details?: StringFieldUpdateOperationsInput | string
    relocation_assistance_details?: StringFieldUpdateOperationsInput | string
    status?: EnumcontactStatusFieldUpdateOperationsInput | $Enums.contactStatus
    signed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsUpdateWithoutNotificationInput = {
    notification_type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    related_entity_type?: StringFieldUpdateOperationsInput | string
    related_entity_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsUncheckedUpdateWithoutNotificationInput = {
    id?: IntFieldUpdateOperationsInput | number
    notification_type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    related_entity_type?: StringFieldUpdateOperationsInput | string
    related_entity_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsUncheckedUpdateManyWithoutNotificationInput = {
    id?: IntFieldUpdateOperationsInput | number
    notification_type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    related_entity_type?: StringFieldUpdateOperationsInput | string
    related_entity_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type saved_jobsUpdateWithoutSavedjobInput = {
    saved_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    savedjobs?: jobsUpdateOneRequiredWithoutSavedjobNestedInput
  }

  export type saved_jobsUncheckedUpdateWithoutSavedjobInput = {
    id?: IntFieldUpdateOperationsInput | number
    job_id?: IntFieldUpdateOperationsInput | number
    saved_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
  }

  export type saved_jobsUncheckedUpdateManyWithoutSavedjobInput = {
    id?: IntFieldUpdateOperationsInput | number
    job_id?: IntFieldUpdateOperationsInput | number
    saved_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
  }

  export type job_searchesUpdateWithoutSearchesInput = {
    search_query?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    job_catregory?: StringFieldUpdateOperationsInput | string
    experience_level?: StringFieldUpdateOperationsInput | string
    job_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_searchesUncheckedUpdateWithoutSearchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    search_query?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    job_catregory?: StringFieldUpdateOperationsInput | string
    experience_level?: StringFieldUpdateOperationsInput | string
    job_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_searchesUncheckedUpdateManyWithoutSearchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    search_query?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    job_catregory?: StringFieldUpdateOperationsInput | string
    experience_level?: StringFieldUpdateOperationsInput | string
    job_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type applicationsCreateManyApplicationsInput = {
    id?: number
    job_id: number
    user_id: number
    cover_letter: string
    status: $Enums.applicationStatus
    applited_at?: Date | string
    updated_at?: Date | string
    notes: string
  }

  export type applicationsUpdateWithoutApplicationsInput = {
    cover_letter?: StringFieldUpdateOperationsInput | string
    status?: EnumapplicationStatusFieldUpdateOperationsInput | $Enums.applicationStatus
    applited_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    application?: jobsUpdateOneRequiredWithoutApplicationNestedInput
    aplication?: usersUpdateOneRequiredWithoutApplicationNestedInput
    document?: application_documentsUpdateManyWithoutDocumentNestedInput
    interview?: interviewsUpdateManyWithoutInterviewNestedInput
  }

  export type applicationsUncheckedUpdateWithoutApplicationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    job_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    cover_letter?: StringFieldUpdateOperationsInput | string
    status?: EnumapplicationStatusFieldUpdateOperationsInput | $Enums.applicationStatus
    applited_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    document?: application_documentsUncheckedUpdateManyWithoutDocumentNestedInput
    interview?: interviewsUncheckedUpdateManyWithoutInterviewNestedInput
  }

  export type applicationsUncheckedUpdateManyWithoutApplicationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    job_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    cover_letter?: StringFieldUpdateOperationsInput | string
    status?: EnumapplicationStatusFieldUpdateOperationsInput | $Enums.applicationStatus
    applited_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
  }

  export type company_locationsCreateManyCompaniesInput = {
    id?: number
    country: string
    city: string
    address: string
    is_headquarters?: boolean
    phone_number: string
  }

  export type jobsCreateManyJobInput = {
    id?: number
    title: string
    description: string
    job_category: string
    job_type: $Enums.jobType
    location_country: string
    location_city: string
    is_relocation_assistance?: boolean
    is_remote_possible?: boolean
    salary_currency: string
    salary_min: number
    salary_max: number
    salary_period?: $Enums.salaryPeriod
    visa_sponsorship?: $Enums.visaSponsorship
    experience_level?: $Enums.expLevel
    education_requirement: string
    posted_by: number
    status: $Enums.jobStatus
    posted_at?: Date | string
    deadline: Date | string
    views_count?: number
  }

  export type contactsCreateManyContacInput = {
    id?: number
    job_id: number
    user_id: number
    contact_type: $Enums.contactType
    start_date: Date | string
    end_date: Date | string
    probation_period_months?: number
    salary_amount: number
    salary_currency: string
    salary_payment_period?: $Enums.contactSalaryPaymentPeriod
    benefits_description: string
    visa_sponsorship_details: string
    relocation_assistance_details: string
    status?: $Enums.contactStatus
    signed_at: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type company_locationsUpdateWithoutCompaniesInput = {
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    is_headquarters?: BoolFieldUpdateOperationsInput | boolean
    phone_number?: StringFieldUpdateOperationsInput | string
  }

  export type company_locationsUncheckedUpdateWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    is_headquarters?: BoolFieldUpdateOperationsInput | boolean
    phone_number?: StringFieldUpdateOperationsInput | string
  }

  export type company_locationsUncheckedUpdateManyWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    is_headquarters?: BoolFieldUpdateOperationsInput | boolean
    phone_number?: StringFieldUpdateOperationsInput | string
  }

  export type jobsUpdateWithoutJobInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    job_category?: StringFieldUpdateOperationsInput | string
    job_type?: EnumjobTypeFieldUpdateOperationsInput | $Enums.jobType
    location_country?: StringFieldUpdateOperationsInput | string
    location_city?: StringFieldUpdateOperationsInput | string
    is_relocation_assistance?: BoolFieldUpdateOperationsInput | boolean
    is_remote_possible?: BoolFieldUpdateOperationsInput | boolean
    salary_currency?: StringFieldUpdateOperationsInput | string
    salary_min?: IntFieldUpdateOperationsInput | number
    salary_max?: IntFieldUpdateOperationsInput | number
    salary_period?: EnumsalaryPeriodFieldUpdateOperationsInput | $Enums.salaryPeriod
    visa_sponsorship?: EnumvisaSponsorshipFieldUpdateOperationsInput | $Enums.visaSponsorship
    experience_level?: EnumexpLevelFieldUpdateOperationsInput | $Enums.expLevel
    education_requirement?: StringFieldUpdateOperationsInput | string
    posted_by?: IntFieldUpdateOperationsInput | number
    status?: EnumjobStatusFieldUpdateOperationsInput | $Enums.jobStatus
    posted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    views_count?: IntFieldUpdateOperationsInput | number
    requirements?: job_requirementsUpdateManyWithoutRequirementsNestedInput
    responsibilites?: job_responsibilitesUpdateManyWithoutResponsibilitesNestedInput
    benefits?: job_benefitsUpdateManyWithoutBenefitsNestedInput
    application?: applicationsUpdateManyWithoutApplicationNestedInput
    contact?: contactsUpdateManyWithoutContactNestedInput
    savedjob?: saved_jobsUpdateManyWithoutSavedjobsNestedInput
  }

  export type jobsUncheckedUpdateWithoutJobInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    job_category?: StringFieldUpdateOperationsInput | string
    job_type?: EnumjobTypeFieldUpdateOperationsInput | $Enums.jobType
    location_country?: StringFieldUpdateOperationsInput | string
    location_city?: StringFieldUpdateOperationsInput | string
    is_relocation_assistance?: BoolFieldUpdateOperationsInput | boolean
    is_remote_possible?: BoolFieldUpdateOperationsInput | boolean
    salary_currency?: StringFieldUpdateOperationsInput | string
    salary_min?: IntFieldUpdateOperationsInput | number
    salary_max?: IntFieldUpdateOperationsInput | number
    salary_period?: EnumsalaryPeriodFieldUpdateOperationsInput | $Enums.salaryPeriod
    visa_sponsorship?: EnumvisaSponsorshipFieldUpdateOperationsInput | $Enums.visaSponsorship
    experience_level?: EnumexpLevelFieldUpdateOperationsInput | $Enums.expLevel
    education_requirement?: StringFieldUpdateOperationsInput | string
    posted_by?: IntFieldUpdateOperationsInput | number
    status?: EnumjobStatusFieldUpdateOperationsInput | $Enums.jobStatus
    posted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    views_count?: IntFieldUpdateOperationsInput | number
    requirements?: job_requirementsUncheckedUpdateManyWithoutRequirementsNestedInput
    responsibilites?: job_responsibilitesUncheckedUpdateManyWithoutResponsibilitesNestedInput
    benefits?: job_benefitsUncheckedUpdateManyWithoutBenefitsNestedInput
    application?: applicationsUncheckedUpdateManyWithoutApplicationNestedInput
    contact?: contactsUncheckedUpdateManyWithoutContactNestedInput
    savedjob?: saved_jobsUncheckedUpdateManyWithoutSavedjobsNestedInput
  }

  export type jobsUncheckedUpdateManyWithoutJobInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    job_category?: StringFieldUpdateOperationsInput | string
    job_type?: EnumjobTypeFieldUpdateOperationsInput | $Enums.jobType
    location_country?: StringFieldUpdateOperationsInput | string
    location_city?: StringFieldUpdateOperationsInput | string
    is_relocation_assistance?: BoolFieldUpdateOperationsInput | boolean
    is_remote_possible?: BoolFieldUpdateOperationsInput | boolean
    salary_currency?: StringFieldUpdateOperationsInput | string
    salary_min?: IntFieldUpdateOperationsInput | number
    salary_max?: IntFieldUpdateOperationsInput | number
    salary_period?: EnumsalaryPeriodFieldUpdateOperationsInput | $Enums.salaryPeriod
    visa_sponsorship?: EnumvisaSponsorshipFieldUpdateOperationsInput | $Enums.visaSponsorship
    experience_level?: EnumexpLevelFieldUpdateOperationsInput | $Enums.expLevel
    education_requirement?: StringFieldUpdateOperationsInput | string
    posted_by?: IntFieldUpdateOperationsInput | number
    status?: EnumjobStatusFieldUpdateOperationsInput | $Enums.jobStatus
    posted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    views_count?: IntFieldUpdateOperationsInput | number
  }

  export type contactsUpdateWithoutContacInput = {
    contact_type?: EnumcontactTypeFieldUpdateOperationsInput | $Enums.contactType
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    probation_period_months?: IntFieldUpdateOperationsInput | number
    salary_amount?: IntFieldUpdateOperationsInput | number
    salary_currency?: StringFieldUpdateOperationsInput | string
    salary_payment_period?: EnumcontactSalaryPaymentPeriodFieldUpdateOperationsInput | $Enums.contactSalaryPaymentPeriod
    benefits_description?: StringFieldUpdateOperationsInput | string
    visa_sponsorship_details?: StringFieldUpdateOperationsInput | string
    relocation_assistance_details?: StringFieldUpdateOperationsInput | string
    status?: EnumcontactStatusFieldUpdateOperationsInput | $Enums.contactStatus
    signed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: jobsUpdateOneRequiredWithoutContactNestedInput
    contacts?: usersUpdateOneRequiredWithoutContactsNestedInput
  }

  export type contactsUncheckedUpdateWithoutContacInput = {
    id?: IntFieldUpdateOperationsInput | number
    job_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    contact_type?: EnumcontactTypeFieldUpdateOperationsInput | $Enums.contactType
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    probation_period_months?: IntFieldUpdateOperationsInput | number
    salary_amount?: IntFieldUpdateOperationsInput | number
    salary_currency?: StringFieldUpdateOperationsInput | string
    salary_payment_period?: EnumcontactSalaryPaymentPeriodFieldUpdateOperationsInput | $Enums.contactSalaryPaymentPeriod
    benefits_description?: StringFieldUpdateOperationsInput | string
    visa_sponsorship_details?: StringFieldUpdateOperationsInput | string
    relocation_assistance_details?: StringFieldUpdateOperationsInput | string
    status?: EnumcontactStatusFieldUpdateOperationsInput | $Enums.contactStatus
    signed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type contactsUncheckedUpdateManyWithoutContacInput = {
    id?: IntFieldUpdateOperationsInput | number
    job_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    contact_type?: EnumcontactTypeFieldUpdateOperationsInput | $Enums.contactType
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    probation_period_months?: IntFieldUpdateOperationsInput | number
    salary_amount?: IntFieldUpdateOperationsInput | number
    salary_currency?: StringFieldUpdateOperationsInput | string
    salary_payment_period?: EnumcontactSalaryPaymentPeriodFieldUpdateOperationsInput | $Enums.contactSalaryPaymentPeriod
    benefits_description?: StringFieldUpdateOperationsInput | string
    visa_sponsorship_details?: StringFieldUpdateOperationsInput | string
    relocation_assistance_details?: StringFieldUpdateOperationsInput | string
    status?: EnumcontactStatusFieldUpdateOperationsInput | $Enums.contactStatus
    signed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_requirementsCreateManyRequirementsInput = {
    id?: number
    requirement_type: $Enums.jobRequirements
    requirement_text: string
    is_mandatory?: boolean
    priority?: number
  }

  export type job_responsibilitesCreateManyResponsibilitesInput = {
    id?: number
    responsibility_text: string
    priority?: number
  }

  export type job_benefitsCreateManyBenefitsInput = {
    id?: number
    benefit_type: $Enums.jobBenefit
    description: string
  }

  export type applicationsCreateManyApplicationInput = {
    id?: number
    user_id: number
    resume_id: number
    cover_letter: string
    status: $Enums.applicationStatus
    applited_at?: Date | string
    updated_at?: Date | string
    notes: string
  }

  export type contactsCreateManyContactInput = {
    id?: number
    user_id: number
    company_id: number
    contact_type: $Enums.contactType
    start_date: Date | string
    end_date: Date | string
    probation_period_months?: number
    salary_amount: number
    salary_currency: string
    salary_payment_period?: $Enums.contactSalaryPaymentPeriod
    benefits_description: string
    visa_sponsorship_details: string
    relocation_assistance_details: string
    status?: $Enums.contactStatus
    signed_at: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type saved_jobsCreateManySavedjobsInput = {
    id?: number
    user_id: number
    saved_at?: Date | string
    notes: string
  }

  export type job_requirementsUpdateWithoutRequirementsInput = {
    requirement_type?: EnumjobRequirementsFieldUpdateOperationsInput | $Enums.jobRequirements
    requirement_text?: StringFieldUpdateOperationsInput | string
    is_mandatory?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type job_requirementsUncheckedUpdateWithoutRequirementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    requirement_type?: EnumjobRequirementsFieldUpdateOperationsInput | $Enums.jobRequirements
    requirement_text?: StringFieldUpdateOperationsInput | string
    is_mandatory?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type job_requirementsUncheckedUpdateManyWithoutRequirementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    requirement_type?: EnumjobRequirementsFieldUpdateOperationsInput | $Enums.jobRequirements
    requirement_text?: StringFieldUpdateOperationsInput | string
    is_mandatory?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type job_responsibilitesUpdateWithoutResponsibilitesInput = {
    responsibility_text?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type job_responsibilitesUncheckedUpdateWithoutResponsibilitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    responsibility_text?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type job_responsibilitesUncheckedUpdateManyWithoutResponsibilitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    responsibility_text?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type job_benefitsUpdateWithoutBenefitsInput = {
    benefit_type?: EnumjobBenefitFieldUpdateOperationsInput | $Enums.jobBenefit
    description?: StringFieldUpdateOperationsInput | string
  }

  export type job_benefitsUncheckedUpdateWithoutBenefitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    benefit_type?: EnumjobBenefitFieldUpdateOperationsInput | $Enums.jobBenefit
    description?: StringFieldUpdateOperationsInput | string
  }

  export type job_benefitsUncheckedUpdateManyWithoutBenefitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    benefit_type?: EnumjobBenefitFieldUpdateOperationsInput | $Enums.jobBenefit
    description?: StringFieldUpdateOperationsInput | string
  }

  export type applicationsUpdateWithoutApplicationInput = {
    cover_letter?: StringFieldUpdateOperationsInput | string
    status?: EnumapplicationStatusFieldUpdateOperationsInput | $Enums.applicationStatus
    applited_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    aplication?: usersUpdateOneRequiredWithoutApplicationNestedInput
    applications?: resumesUpdateOneRequiredWithoutApplicationsNestedInput
    document?: application_documentsUpdateManyWithoutDocumentNestedInput
    interview?: interviewsUpdateManyWithoutInterviewNestedInput
  }

  export type applicationsUncheckedUpdateWithoutApplicationInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    resume_id?: IntFieldUpdateOperationsInput | number
    cover_letter?: StringFieldUpdateOperationsInput | string
    status?: EnumapplicationStatusFieldUpdateOperationsInput | $Enums.applicationStatus
    applited_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    document?: application_documentsUncheckedUpdateManyWithoutDocumentNestedInput
    interview?: interviewsUncheckedUpdateManyWithoutInterviewNestedInput
  }

  export type applicationsUncheckedUpdateManyWithoutApplicationInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    resume_id?: IntFieldUpdateOperationsInput | number
    cover_letter?: StringFieldUpdateOperationsInput | string
    status?: EnumapplicationStatusFieldUpdateOperationsInput | $Enums.applicationStatus
    applited_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
  }

  export type contactsUpdateWithoutContactInput = {
    contact_type?: EnumcontactTypeFieldUpdateOperationsInput | $Enums.contactType
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    probation_period_months?: IntFieldUpdateOperationsInput | number
    salary_amount?: IntFieldUpdateOperationsInput | number
    salary_currency?: StringFieldUpdateOperationsInput | string
    salary_payment_period?: EnumcontactSalaryPaymentPeriodFieldUpdateOperationsInput | $Enums.contactSalaryPaymentPeriod
    benefits_description?: StringFieldUpdateOperationsInput | string
    visa_sponsorship_details?: StringFieldUpdateOperationsInput | string
    relocation_assistance_details?: StringFieldUpdateOperationsInput | string
    status?: EnumcontactStatusFieldUpdateOperationsInput | $Enums.contactStatus
    signed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: usersUpdateOneRequiredWithoutContactsNestedInput
    contac?: companiesUpdateOneRequiredWithoutContactsNestedInput
  }

  export type contactsUncheckedUpdateWithoutContactInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    contact_type?: EnumcontactTypeFieldUpdateOperationsInput | $Enums.contactType
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    probation_period_months?: IntFieldUpdateOperationsInput | number
    salary_amount?: IntFieldUpdateOperationsInput | number
    salary_currency?: StringFieldUpdateOperationsInput | string
    salary_payment_period?: EnumcontactSalaryPaymentPeriodFieldUpdateOperationsInput | $Enums.contactSalaryPaymentPeriod
    benefits_description?: StringFieldUpdateOperationsInput | string
    visa_sponsorship_details?: StringFieldUpdateOperationsInput | string
    relocation_assistance_details?: StringFieldUpdateOperationsInput | string
    status?: EnumcontactStatusFieldUpdateOperationsInput | $Enums.contactStatus
    signed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type contactsUncheckedUpdateManyWithoutContactInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    contact_type?: EnumcontactTypeFieldUpdateOperationsInput | $Enums.contactType
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    probation_period_months?: IntFieldUpdateOperationsInput | number
    salary_amount?: IntFieldUpdateOperationsInput | number
    salary_currency?: StringFieldUpdateOperationsInput | string
    salary_payment_period?: EnumcontactSalaryPaymentPeriodFieldUpdateOperationsInput | $Enums.contactSalaryPaymentPeriod
    benefits_description?: StringFieldUpdateOperationsInput | string
    visa_sponsorship_details?: StringFieldUpdateOperationsInput | string
    relocation_assistance_details?: StringFieldUpdateOperationsInput | string
    status?: EnumcontactStatusFieldUpdateOperationsInput | $Enums.contactStatus
    signed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type saved_jobsUpdateWithoutSavedjobsInput = {
    saved_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    savedjob?: usersUpdateOneRequiredWithoutSavedjobNestedInput
  }

  export type saved_jobsUncheckedUpdateWithoutSavedjobsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    saved_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
  }

  export type saved_jobsUncheckedUpdateManyWithoutSavedjobsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    saved_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
  }

  export type application_documentsCreateManyDocumentInput = {
    id?: number
    document_type: $Enums.appDocumentStatus
    file_url: string
    uploaded_at?: Date | string
  }

  export type interviewsCreateManyInterviewInput = {
    id?: number
    interview_type: $Enums.interviewType
    scheduled_time: Date | string
    timezone: string
    duration_minutes?: number
    location: string
    meeting_url: string
    interview_name: string
    interview_position: string
    status: $Enums.interviewStatus
    feedback: string
    rating: number
    notes: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type application_documentsUpdateWithoutDocumentInput = {
    document_type?: EnumappDocumentStatusFieldUpdateOperationsInput | $Enums.appDocumentStatus
    file_url?: StringFieldUpdateOperationsInput | string
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type application_documentsUncheckedUpdateWithoutDocumentInput = {
    id?: IntFieldUpdateOperationsInput | number
    document_type?: EnumappDocumentStatusFieldUpdateOperationsInput | $Enums.appDocumentStatus
    file_url?: StringFieldUpdateOperationsInput | string
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type application_documentsUncheckedUpdateManyWithoutDocumentInput = {
    id?: IntFieldUpdateOperationsInput | number
    document_type?: EnumappDocumentStatusFieldUpdateOperationsInput | $Enums.appDocumentStatus
    file_url?: StringFieldUpdateOperationsInput | string
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type interviewsUpdateWithoutInterviewInput = {
    interview_type?: EnuminterviewTypeFieldUpdateOperationsInput | $Enums.interviewType
    scheduled_time?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    duration_minutes?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    meeting_url?: StringFieldUpdateOperationsInput | string
    interview_name?: StringFieldUpdateOperationsInput | string
    interview_position?: StringFieldUpdateOperationsInput | string
    status?: EnuminterviewStatusFieldUpdateOperationsInput | $Enums.interviewStatus
    feedback?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type interviewsUncheckedUpdateWithoutInterviewInput = {
    id?: IntFieldUpdateOperationsInput | number
    interview_type?: EnuminterviewTypeFieldUpdateOperationsInput | $Enums.interviewType
    scheduled_time?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    duration_minutes?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    meeting_url?: StringFieldUpdateOperationsInput | string
    interview_name?: StringFieldUpdateOperationsInput | string
    interview_position?: StringFieldUpdateOperationsInput | string
    status?: EnuminterviewStatusFieldUpdateOperationsInput | $Enums.interviewStatus
    feedback?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type interviewsUncheckedUpdateManyWithoutInterviewInput = {
    id?: IntFieldUpdateOperationsInput | number
    interview_type?: EnuminterviewTypeFieldUpdateOperationsInput | $Enums.interviewType
    scheduled_time?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    duration_minutes?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    meeting_url?: StringFieldUpdateOperationsInput | string
    interview_name?: StringFieldUpdateOperationsInput | string
    interview_position?: StringFieldUpdateOperationsInput | string
    status?: EnuminterviewStatusFieldUpdateOperationsInput | $Enums.interviewStatus
    feedback?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}